<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>来呀，不服抓个包~~</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://wangjibao.com.cn/"/>
  <updated>2019-08-28T05:28:36.687Z</updated>
  <id>https://wangjibao.com.cn/</id>
  
  <author>
    <name>大宝哥spring</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>LeetCode61-70</title>
    <link href="https://wangjibao.com.cn/2019/08/28/LeetCode61-70/"/>
    <id>https://wangjibao.com.cn/2019/08/28/LeetCode61-70/</id>
    <published>2019-08-28T03:40:37.000Z</published>
    <updated>2019-08-28T05:28:36.687Z</updated>
    
    <content type="html"><![CDATA[<h2 id="61、旋转链表"><a href="#61、旋转链表" class="headerlink" title="61、旋转链表"></a>61、<a href="https://leetcode-cn.com/problems/rotate-list/" target="_blank" rel="noopener">旋转链表</a></h2><p>模拟题</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">rotateRight</span><span class="params">(ListNode* head, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(struct ListNode *ptr = head; ptr; ptr=ptr-&gt;next)&#123;</span><br><span class="line">            len++;</span><br><span class="line">            <span class="keyword">if</span>(ptr-&gt;next==<span class="literal">NULL</span>)&#123;</span><br><span class="line">                ptr-&gt;next = head;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(len==<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        k %= len;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=len-k; i++)</span><br><span class="line">            head = head-&gt;next;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">ans</span> = <span class="title">head</span>;</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;len; i++)</span><br><span class="line">            head = head-&gt;next;</span><br><span class="line">        head-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="62、不同路径"><a href="#62、不同路径" class="headerlink" title="62、不同路径"></a>62、<a href="https://leetcode-cn.com/problems/unique-paths/" target="_blank" rel="noopener">不同路径</a></h2><p>排列组合，当 <code>m</code> 和 <code>n</code> 较大时，应该使用 <code>Lucas</code> 定理。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">uniquePaths</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> total = m+n<span class="number">-2</span>;</span><br><span class="line">        <span class="keyword">int</span> frac = min(m<span class="number">-1</span>, n<span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> fenzi = <span class="number">1</span>, fenmu = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=frac; i++)&#123;</span><br><span class="line">            fenzi *= total-i+<span class="number">1</span>;</span><br><span class="line">            fenmu *= i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> fenzi/fenmu;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="63、不同路径-II"><a href="#63、不同路径-II" class="headerlink" title="63、不同路径 II"></a>63、<a href="https://leetcode-cn.com/problems/unique-paths-ii/" target="_blank" rel="noopener">不同路径 II</a></h2><p>同上一题，只不过加了障碍，判断一下即可。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">uniquePathsWithObstacles</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; obstacleGrid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = obstacleGrid.size(), m = obstacleGrid[<span class="number">0</span>].size();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt; ans(m, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; i++)&#123;</span><br><span class="line">            ans[<span class="number">0</span>] = i==<span class="number">0</span>? (obstacleGrid[i][<span class="number">0</span>]+<span class="number">1</span>)%<span class="number">2</span> : ((obstacleGrid[i][<span class="number">0</span>]+<span class="number">1</span>)%<span class="number">2</span> &amp;&amp; ans[<span class="number">0</span>]);</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>; j&lt;m; j++)</span><br><span class="line">                ans[j] = obstacleGrid[i][j]==<span class="number">1</span>?<span class="number">0</span>:ans[j<span class="number">-1</span>]+ans[j];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans[m<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="64、最小路径和"><a href="#64、最小路径和" class="headerlink" title="64、最小路径和"></a>64、<a href="https://leetcode-cn.com/problems/minimum-path-sum/" target="_blank" rel="noopener">最小路径和</a></h2><p>水 <code>dp</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minPathSum</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i, j;</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">1</span>; i&lt;grid.size(); i++)</span><br><span class="line">            grid[i][<span class="number">0</span>] += grid[i<span class="number">-1</span>][<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(j=<span class="number">1</span>; j&lt;grid[<span class="number">0</span>].size(); j++)</span><br><span class="line">            grid[<span class="number">0</span>][j] += grid[<span class="number">0</span>][j<span class="number">-1</span>];</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">1</span>; i&lt;grid.size(); i++)</span><br><span class="line">            <span class="keyword">for</span>(j=<span class="number">1</span>; j&lt;grid[<span class="number">0</span>].size(); j++)</span><br><span class="line">                grid[i][j] += min(grid[i<span class="number">-1</span>][j], grid[i][j<span class="number">-1</span>]);</span><br><span class="line">        <span class="keyword">return</span> grid[grid.size()<span class="number">-1</span>][grid[<span class="number">0</span>].size()<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="65、-有效数字"><a href="#65、-有效数字" class="headerlink" title="65、 有效数字"></a>65、<a href="https://leetcode-cn.com/problems/valid-number/" target="_blank" rel="noopener"> 有效数字</a></h2><p>见过的最恶心的题目</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isNumber</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; num(<span class="number">10</span>,<span class="number">0</span>);</span><br><span class="line">        s.erase(<span class="number">0</span>,s.find_first_not_of(<span class="string">" "</span>));</span><br><span class="line">        s.erase(s.find_last_not_of(<span class="string">" "</span>) + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span>(s[s.length()<span class="number">-1</span>]==<span class="string">'e'</span> || s[s.length()<span class="number">-1</span>]==<span class="string">'+'</span> || s[s.length()<span class="number">-1</span>]==<span class="string">'-'</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;s.length(); i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i]==<span class="string">'-'</span> || s[i]==<span class="string">'+'</span>)&#123;</span><br><span class="line">                num[<span class="number">0</span>]++;</span><br><span class="line">                <span class="keyword">if</span>(i&gt;<span class="number">0</span> &amp;&amp; (s[i<span class="number">-1</span>]==<span class="string">'-'</span> || s[i<span class="number">-1</span>]==<span class="string">'+'</span>))</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(s[i]==<span class="string">'e'</span>)</span><br><span class="line">                num[<span class="number">1</span>]++;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(s[i]&gt;=<span class="string">'0'</span> &amp;&amp; s[i]&lt;=<span class="string">'9'</span>)</span><br><span class="line">                num[<span class="number">3</span>]++;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(s[i]==<span class="string">'.'</span> &amp;&amp; num[<span class="number">1</span>]==<span class="number">0</span>)&#123;</span><br><span class="line">                num[<span class="number">2</span>]++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(num[<span class="number">0</span>]&gt;<span class="number">2</span> || num[<span class="number">1</span>]&gt;<span class="number">1</span> || num[<span class="number">2</span>]&gt;<span class="number">1</span> || s[<span class="number">0</span>]==<span class="string">'e'</span> || num[<span class="number">3</span>]==<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(num[<span class="number">1</span>]==<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">int</span> index = s.find(<span class="string">'e'</span>);</span><br><span class="line">            <span class="keyword">if</span>(index==s.length()<span class="number">-1</span> || (index==<span class="number">1</span> &amp;&amp; s[<span class="number">0</span>]==<span class="string">'.'</span>) || (index&gt;<span class="number">0</span> &amp;&amp; (s[index<span class="number">-1</span>]==<span class="string">'-'</span> || s[index<span class="number">-1</span>]==<span class="string">'+'</span>)))</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(num[<span class="number">0</span>])&#123;</span><br><span class="line">            <span class="keyword">int</span> index = s.find(<span class="string">'-'</span>);</span><br><span class="line">            <span class="keyword">if</span>(index&lt;<span class="number">0</span> || index&gt;=s.length())</span><br><span class="line">                index = s.find(<span class="string">'+'</span>);</span><br><span class="line">            <span class="keyword">if</span>(index==s.length()<span class="number">-1</span> || (index&gt;<span class="number">0</span> &amp;&amp; ((<span class="built_in">isdigit</span>(s[index<span class="number">-1</span>]) &amp;&amp; <span class="built_in">isdigit</span>(s[index+<span class="number">1</span>])) || s[index<span class="number">-1</span>]==<span class="string">'.'</span>)))</span><br><span class="line">               <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=index+<span class="number">1</span>; i&lt;s.length(); i++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(s[i]&gt;=<span class="string">'0'</span> &amp;&amp; s[i]&lt;=<span class="string">'9'</span>)</span><br><span class="line">                    sum++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(sum==<span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="66、-加一"><a href="#66、-加一" class="headerlink" title="66、 加一"></a>66、<a href="https://leetcode-cn.com/problems/plus-one/" target="_blank" rel="noopener"> 加一</a></h2><p>模拟题，考虑下进位即可。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; plusOne(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; digits) &#123;</span><br><span class="line">        <span class="keyword">int</span> num = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=digits.size()<span class="number">-1</span>; i&gt;=<span class="number">0.</span>; i--)&#123;</span><br><span class="line">            num += digits[i];</span><br><span class="line">            digits[i] = num % <span class="number">10</span>;</span><br><span class="line">            num /= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(num)</span><br><span class="line">            digits.insert(digits.begin(), <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> digits;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="67、二进制求和"><a href="#67、二进制求和" class="headerlink" title="67、二进制求和"></a>67、<a href="https://leetcode-cn.com/problems/add-binary/" target="_blank" rel="noopener">二进制求和</a></h2><p>模拟题，考虑二进制进位即可。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">addBinary</span><span class="params">(<span class="built_in">string</span> a, <span class="built_in">string</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">string</span> ans = <span class="string">""</span>;</span><br><span class="line">        <span class="keyword">int</span> flag = <span class="number">0</span>, sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> len_a = a.size(), len_b = b.size();</span><br><span class="line">        <span class="keyword">while</span>(len_a&gt;<span class="number">0</span> || len_b&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            sum = flag;</span><br><span class="line">            <span class="keyword">if</span>(len_a&gt;<span class="number">0</span>)</span><br><span class="line">                sum += a[--len_a]-<span class="string">'0'</span>;</span><br><span class="line">            <span class="keyword">if</span>(len_b&gt;<span class="number">0</span>)</span><br><span class="line">                sum += b[--len_b]-<span class="string">'0'</span>;</span><br><span class="line">            flag = sum/<span class="number">2</span>;            ans.insert(ans.begin(), <span class="string">'0'</span>+sum%<span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(flag)</span><br><span class="line">            ans = <span class="string">'1'</span> + ans;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="68、文本左右对齐"><a href="#68、文本左右对齐" class="headerlink" title="68、文本左右对齐"></a>68、<a href="https://leetcode-cn.com/problems/text-justification/" target="_blank" rel="noopener">文本左右对齐</a></h2><p>模拟题，对空格数做判断。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; fullJustify(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; words, <span class="keyword">int</span> maxWidth) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; ans;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; tmp;</span><br><span class="line">        <span class="keyword">int</span> len = <span class="number">0</span>, pos = <span class="number">0</span>, i;</span><br><span class="line">        <span class="keyword">while</span>(pos&lt;words.size())&#123;</span><br><span class="line">            ans.clear();</span><br><span class="line">            i = pos;</span><br><span class="line">            ans.push_back(words[i]);</span><br><span class="line">            len = words[i++].length()+<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span>(i&lt;words.size() &amp;&amp; len+words[i].length()&lt;=maxWidth)&#123;</span><br><span class="line">                ans.push_back(words[i]);</span><br><span class="line">                len += words[i++].length() + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            tmp.push_back(ans);</span><br><span class="line">            pos = i;</span><br><span class="line">        &#125;</span><br><span class="line">        ans.clear();</span><br><span class="line">        <span class="built_in">string</span> tmp_ans;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>; k&lt;tmp.size()<span class="number">-1</span>; k++)&#123;</span><br><span class="line">            len = <span class="number">0</span>;</span><br><span class="line">            tmp_ans = <span class="string">""</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;tmp[k].size(); j++)</span><br><span class="line">                len += tmp[k][j].length();</span><br><span class="line">            <span class="keyword">int</span> konggeshu, yushu;</span><br><span class="line">            <span class="keyword">if</span>(tmp[k].size()==<span class="number">1</span>)&#123;</span><br><span class="line">                tmp_ans = tmp[k][<span class="number">0</span>] + <span class="built_in">string</span>(maxWidth-tmp[k][<span class="number">0</span>].length(), <span class="string">' '</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                konggeshu = (maxWidth-len)/(tmp[k].size()<span class="number">-1</span>);</span><br><span class="line">                yushu = (maxWidth-len)%(tmp[k].size()<span class="number">-1</span>);</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;tmp[k].size()<span class="number">-1</span>; i++)&#123;</span><br><span class="line">                    tmp_ans += tmp[k][i]+<span class="built_in">string</span>(konggeshu, <span class="string">' '</span>);</span><br><span class="line">                    <span class="keyword">if</span>(yushu&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                        tmp_ans += <span class="string">" "</span>;</span><br><span class="line">                        yushu--;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                tmp_ans += tmp[k][tmp[k].size()<span class="number">-1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            ans.push_back(tmp_ans);</span><br><span class="line">        &#125;</span><br><span class="line">        tmp_ans = tmp[tmp.size()<span class="number">-1</span>][<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;tmp[tmp.size()<span class="number">-1</span>].size(); i++)</span><br><span class="line">            tmp_ans += <span class="string">" "</span> + tmp[tmp.size()<span class="number">-1</span>][i];</span><br><span class="line">        tmp_ans += <span class="built_in">string</span>(maxWidth-tmp_ans.length(), <span class="string">' '</span>);</span><br><span class="line">        ans.push_back(tmp_ans);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="69、x-的平方根"><a href="#69、x-的平方根" class="headerlink" title="69、x 的平方根"></a>69、<a href="https://leetcode-cn.com/problems/sqrtx/" target="_blank" rel="noopener">x 的平方根</a></h2><p>直接用库函数，思考如何自己手动计算一个数的平方根。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">mySqrt</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">int</span>(<span class="built_in">sqrt</span>(x));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="70、爬楼梯"><a href="#70、爬楼梯" class="headerlink" title="70、爬楼梯"></a>70、<a href="https://leetcode-cn.com/problems/climbing-stairs/" target="_blank" rel="noopener">爬楼梯</a></h2><p>斐波那契数列，这里使用矩阵快速幂加速。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">transferMatrix</span>&#123;</span></span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> matrix[<span class="number">2</span>][<span class="number">2</span>];</span><br><span class="line">    transferMatrix <span class="keyword">operator</span>*(<span class="keyword">const</span> transferMatrix&amp; matrix_tmp)&#123;</span><br><span class="line">        transferMatrix matrix_ans;</span><br><span class="line">        <span class="built_in">memset</span>(matrix_ans.matrix, <span class="number">0</span>, <span class="keyword">sizeof</span>(matrix_ans.matrix));</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">2</span>; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;<span class="number">2</span>; j++)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>; k&lt;<span class="number">2</span>; k++)&#123;</span><br><span class="line">                    matrix_ans.matrix[i][j] += matrix[i][k] * matrix_tmp.matrix[k][j];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> matrix_ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">transferMatrix <span class="title">quick_pow</span><span class="params">(transferMatrix a, <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">        transferMatrix ans;</span><br><span class="line">        ans.matrix[<span class="number">0</span>][<span class="number">0</span>] = ans.matrix[<span class="number">1</span>][<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        ans.matrix[<span class="number">0</span>][<span class="number">1</span>] = ans.matrix[<span class="number">1</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(n)&#123;</span><br><span class="line">            <span class="keyword">if</span>(n%<span class="number">2</span>)</span><br><span class="line">                ans = ans*a;</span><br><span class="line">            a = a*a;</span><br><span class="line">            n /= <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">climbStairs</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        transferMatrix ans;</span><br><span class="line">        ans.matrix[<span class="number">0</span>][<span class="number">0</span>] = ans.matrix[<span class="number">0</span>][<span class="number">1</span>] = ans.matrix[<span class="number">1</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        ans.matrix[<span class="number">1</span>][<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">        ans = quick_pow(ans, n);</span><br><span class="line">        <span class="keyword">return</span> ans.matrix[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;61、旋转链表&quot;&gt;&lt;a href=&quot;#61、旋转链表&quot; class=&quot;headerlink&quot; title=&quot;61、旋转链表&quot;&gt;&lt;/a&gt;61、&lt;a href=&quot;https://leetcode-cn.com/problems/rotate-list/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;旋转链表&lt;/a&gt;&lt;/h2&gt;&lt;p&gt;模拟题&lt;/p&gt;
&lt;figure class=&quot;highlight c++&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;31&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;/**&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt; * Definition for singly-linked list.&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt; * struct ListNode &amp;#123;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt; *     int val;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt; *     ListNode *next;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt; *     ListNode(int x) : val(x), next(NULL) &amp;#123;&amp;#125;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt; * &amp;#125;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt; */&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Solution&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt;:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;ListNode* &lt;span class=&quot;title&quot;&gt;rotateRight&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(ListNode* head, &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; k)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; len = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt;(struct ListNode *ptr = head; ptr; ptr=ptr-&amp;gt;next)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            len++;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;(ptr-&amp;gt;next==&lt;span class=&quot;literal&quot;&gt;NULL&lt;/span&gt;)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                ptr-&amp;gt;next = head;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &lt;span class=&quot;keyword&quot;&gt;break&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;(len==&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;literal&quot;&gt;NULL&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        k %= len;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt;(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; i=&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;; i&amp;lt;=len-k; i++)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            head = head-&amp;gt;next;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;ListNode&lt;/span&gt; *&lt;span class=&quot;title&quot;&gt;ans&lt;/span&gt; = &lt;span class=&quot;title&quot;&gt;head&lt;/span&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt;(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; i=&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;; i&amp;lt;len; i++)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            head = head-&amp;gt;next;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        head-&amp;gt;next = &lt;span class=&quot;literal&quot;&gt;NULL&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; ans;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="LeetCode" scheme="https://wangjibao.com.cn/categories/LeetCode/"/>
    
      <category term="LeetCode61-70" scheme="https://wangjibao.com.cn/categories/LeetCode/LeetCode61-70/"/>
    
    
      <category term="LeetCode" scheme="https://wangjibao.com.cn/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode51-60</title>
    <link href="https://wangjibao.com.cn/2019/08/28/LeetCode51-60/"/>
    <id>https://wangjibao.com.cn/2019/08/28/LeetCode51-60/</id>
    <published>2019-08-28T03:39:40.000Z</published>
    <updated>2019-08-28T06:25:27.914Z</updated>
    
    <content type="html"><![CDATA[<h2 id="51、N皇后"><a href="#51、N皇后" class="headerlink" title="51、N皇后"></a>51、<a href="https://leetcode-cn.com/problems/n-queens/" target="_blank" rel="noopener">N皇后</a></h2><p>回溯法</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> record[<span class="number">100</span>];</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> step)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;step; i++)</span><br><span class="line">            <span class="keyword">if</span>(record[i]==record[step] || <span class="built_in">fabs</span>(i-step)==<span class="built_in">fabs</span>(record[i]-record[step]))</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">DFS</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; &amp;ans, <span class="keyword">int</span> n, <span class="keyword">int</span> step)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(step&gt;n)&#123;</span><br><span class="line">            <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; cur_ans(n,<span class="built_in">string</span>(n,<span class="string">'.'</span>));</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++)</span><br><span class="line">                cur_ans[i<span class="number">-1</span>][record[i]<span class="number">-1</span>] = <span class="string">'Q'</span>;</span><br><span class="line">            ans.push_back(cur_ans);</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++)&#123;</span><br><span class="line">            record[step] = i;</span><br><span class="line">            <span class="keyword">if</span>(check(n, step))</span><br><span class="line">                DFS(ans, n, step+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; solveNQueens(<span class="keyword">int</span> n) &#123;</span><br><span class="line">        <span class="built_in">memset</span>(record, <span class="number">0</span>, <span class="keyword">sizeof</span>(record));</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; ans;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++)&#123;</span><br><span class="line">            record[<span class="number">1</span>] = i;</span><br><span class="line">            DFS(ans, n, <span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="52、N皇后-II"><a href="#52、N皇后-II" class="headerlink" title="52、N皇后 II"></a>52、<a href="https://leetcode-cn.com/problems/n-queens-ii/" target="_blank" rel="noopener">N皇后 II</a></h2><p>同上一题</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> record[<span class="number">100</span>];</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> step)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;step; i++)</span><br><span class="line">            <span class="keyword">if</span>(record[i]==record[step] || <span class="built_in">fabs</span>(i-step)==<span class="built_in">fabs</span>(record[i]-record[step]))</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">DFS</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> step)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(step&gt;n)&#123;</span><br><span class="line">            ans++;</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++)&#123;</span><br><span class="line">            record[step] = i;</span><br><span class="line">            <span class="keyword">if</span>(check(n, step))</span><br><span class="line">                DFS(n, step+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">totalNQueens</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">memset</span>(record, <span class="number">0</span>, <span class="keyword">sizeof</span>(record));</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++)&#123;</span><br><span class="line">            record[<span class="number">1</span>] = i;</span><br><span class="line">            DFS(n, <span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="53、最大子序和"><a href="#53、最大子序和" class="headerlink" title="53、最大子序和"></a>53、<a href="https://leetcode-cn.com/problems/maximum-subarray/" target="_blank" rel="noopener">最大子序和</a></h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxSubArray</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> max_sum = <span class="number">-9999999999999</span>, sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> i : nums)&#123;</span><br><span class="line">            sum += i;</span><br><span class="line">            max_sum = max(max_sum, sum);</span><br><span class="line">            <span class="keyword">if</span>( sum&lt;=<span class="number">0</span> )</span><br><span class="line">                sum = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">int</span>(max_sum);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="54、螺旋矩阵"><a href="#54、螺旋矩阵" class="headerlink" title="54、螺旋矩阵"></a>54、<a href="https://leetcode-cn.com/problems/spiral-matrix/" target="_blank" rel="noopener">螺旋矩阵</a></h2><p>模拟题</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; spiralOrder(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; matrix) &#123;</span><br><span class="line">        <span class="keyword">int</span> direct[<span class="number">4</span>][<span class="number">2</span>] = &#123;&#123;<span class="number">0</span>,<span class="number">1</span>&#125;, &#123;<span class="number">1</span>,<span class="number">0</span>&#125;, &#123;<span class="number">0</span>,<span class="number">-1</span>&#125;, &#123;<span class="number">-1</span>,<span class="number">0</span>&#125;&#125;;</span><br><span class="line">        <span class="keyword">int</span> direction = <span class="number">0</span>, row = <span class="number">0</span>, col = <span class="number">0</span>, iter;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line">        <span class="keyword">if</span>(matrix.size()==<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> ans;</span><br><span class="line">        <span class="keyword">int</span> total_nums = <span class="number">0</span>, rotal = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(total_nums &lt; matrix.size() * matrix[<span class="number">0</span>].size())&#123;</span><br><span class="line">            <span class="keyword">if</span>(direction%<span class="number">2</span>)</span><br><span class="line">                iter = matrix.size() - (<span class="number">2</span>*(rotal/<span class="number">4</span>) + <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                iter = matrix[<span class="number">0</span>].size() - (<span class="number">2</span>*(rotal/<span class="number">4</span>) + <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span>(direction==<span class="number">0</span> &amp;&amp; rotal&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                row += <span class="number">1</span>;</span><br><span class="line">                col += <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(matrix.size()*matrix[<span class="number">0</span>].size()-total_nums==<span class="number">1</span>)&#123;</span><br><span class="line">                ans.push_back(matrix[row][col]);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=iter; i++)&#123;</span><br><span class="line">                ans.push_back(matrix[row][col]);</span><br><span class="line">                total_nums++;</span><br><span class="line">                row += direct[direction][<span class="number">0</span>];</span><br><span class="line">                col += direct[direction][<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            rotal += <span class="number">1</span>;</span><br><span class="line">            direction = (direction+<span class="number">1</span>)%<span class="number">4</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="55、跳跃游戏"><a href="#55、跳跃游戏" class="headerlink" title="55、跳跃游戏"></a>55、<a href="https://leetcode-cn.com/problems/jump-game/" target="_blank" rel="noopener">跳跃游戏</a></h2><p>判断能否到达最后一个位置，倒序遍历判断即可。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">canJump</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = nums.size();</span><br><span class="line">        <span class="keyword">int</span> pos = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=len<span class="number">-2</span>; i&gt;=<span class="number">0</span>; i--)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i]==<span class="number">0</span> &amp;&amp; pos==<span class="number">-1</span>)</span><br><span class="line">                pos = i;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(pos-i &lt; nums[i])</span><br><span class="line">                pos = <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pos==<span class="number">-1</span>? <span class="literal">true</span> : <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="56、合并区间"><a href="#56、合并区间" class="headerlink" title="56、合并区间"></a>56、<a href="https://leetcode-cn.com/problems/merge-intervals/" target="_blank" rel="noopener">合并区间</a></h2><p>模拟题</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; vec1, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; vec2)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(vec1[<span class="number">0</span>]!=vec2[<span class="number">0</span>])</span><br><span class="line">            <span class="keyword">return</span> vec1[<span class="number">0</span>] &lt; vec2[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">return</span> vec1[<span class="number">1</span>] &lt; vec2[<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; merge(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; intervals) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt; <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; ans;</span><br><span class="line">        <span class="keyword">if</span>(intervals.size()==<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> ans;</span><br><span class="line">        sort(intervals.begin(), intervals.end(), cmp);</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; tmp_ans = intervals[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;intervals.size(); i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(tmp_ans[<span class="number">1</span>] &gt;= intervals[i][<span class="number">0</span>])</span><br><span class="line">                tmp_ans[<span class="number">1</span>] = max(intervals[i][<span class="number">1</span>], tmp_ans[<span class="number">1</span>]);</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                ans.push_back(tmp_ans);</span><br><span class="line">                tmp_ans = intervals[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ans.push_back(tmp_ans);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="57、插入区间"><a href="#57、插入区间" class="headerlink" title="57、插入区间"></a>57、<a href="https://leetcode-cn.com/problems/insert-interval/" target="_blank" rel="noopener">插入区间</a></h2><p>模拟题</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; insert(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; intervals, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; newInterval) &#123;</span><br><span class="line">        <span class="keyword">if</span>(intervals.size()==<span class="number">0</span>)&#123;</span><br><span class="line">            intervals.push_back(newInterval);</span><br><span class="line">            <span class="keyword">return</span> intervals;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> pos = <span class="number">-1</span>, i = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;intervals.size(); i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(newInterval[<span class="number">0</span>]&gt;intervals[i][<span class="number">0</span>])&#123; <span class="comment">//²åÔÚ i+1 µÄÎ»ÖÃ</span></span><br><span class="line">                pos = i;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        pos++;</span><br><span class="line">        <span class="keyword">for</span>(i=pos<span class="number">-1</span>; i&gt;=<span class="number">0</span>; i--)&#123;</span><br><span class="line">            <span class="keyword">if</span>(intervals[i][<span class="number">1</span>]&gt;=newInterval[<span class="number">0</span>])&#123;</span><br><span class="line">                newInterval[<span class="number">0</span>] = min(intervals[i][<span class="number">0</span>], newInterval[<span class="number">0</span>]);</span><br><span class="line">                newInterval[<span class="number">1</span>] = max(newInterval[<span class="number">1</span>], intervals[i][<span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(j=pos; j&lt;intervals.size(); j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(newInterval[<span class="number">1</span>]&gt;=intervals[j][<span class="number">0</span>])&#123;</span><br><span class="line">                newInterval[<span class="number">0</span>] = min(intervals[j][<span class="number">0</span>], newInterval[<span class="number">0</span>]);</span><br><span class="line">                newInterval[<span class="number">1</span>] = max(newInterval[<span class="number">1</span>], intervals[j][<span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        intervals.erase(intervals.begin()+(i+<span class="number">1</span>), intervals.begin()+j);</span><br><span class="line">        intervals.insert(intervals.begin()+(i+<span class="number">1</span>),newInterval);</span><br><span class="line">        <span class="keyword">return</span> intervals;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="58、最后一个单词的长度"><a href="#58、最后一个单词的长度" class="headerlink" title="58、最后一个单词的长度"></a>58、<a href="https://leetcode-cn.com/problems/length-of-last-word/" target="_blank" rel="noopener">最后一个单词的长度</a></h2><p>水题</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">lengthOfLastWord</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        s.erase(<span class="number">0</span>, s.find_first_not_of(<span class="string">" "</span>));  <span class="comment">//find_ 返回下标</span></span><br><span class="line">        s.erase(s.find_last_not_of(<span class="string">" "</span>)+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span>(s.size()==<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> index = s.find_last_of(<span class="string">" "</span>);</span><br><span class="line">        <span class="keyword">if</span>(index==s.size())</span><br><span class="line">            <span class="keyword">return</span> s.size();</span><br><span class="line">        <span class="keyword">return</span> s.size()-index<span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="59、螺旋矩阵-II"><a href="#59、螺旋矩阵-II" class="headerlink" title="59、螺旋矩阵 II"></a>59、<a href="https://leetcode-cn.com/problems/spiral-matrix-ii/" target="_blank" rel="noopener">螺旋矩阵 II</a></h2><p>模拟题</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; generateMatrix(<span class="keyword">int</span> n) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt; <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; ans(n, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(n));</span><br><span class="line">        <span class="keyword">int</span> direct[<span class="number">4</span>][<span class="number">2</span>] = &#123;&#123;<span class="number">0</span>,<span class="number">1</span>&#125;, &#123;<span class="number">1</span>,<span class="number">0</span>&#125;, &#123;<span class="number">0</span>,<span class="number">-1</span>&#125;, &#123;<span class="number">-1</span>,<span class="number">0</span>&#125;&#125;;</span><br><span class="line">        <span class="keyword">int</span> direction = <span class="number">0</span>, row = <span class="number">0</span>, col = <span class="number">0</span>, iter;</span><br><span class="line">        <span class="keyword">int</span> total_nums = <span class="number">1</span>, rotal = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(total_nums&lt;=n*n)&#123;</span><br><span class="line">            iter = n - (<span class="number">2</span>*(rotal/<span class="number">4</span>) + <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span>(direction==<span class="number">0</span> &amp;&amp; rotal&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                row += <span class="number">1</span>;</span><br><span class="line">                col += <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(n*n==total_nums)&#123;</span><br><span class="line">                ans[row][col] = total_nums++;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=iter; i++)&#123;</span><br><span class="line">                ans[row][col] = total_nums++;</span><br><span class="line">                row += direct[direction][<span class="number">0</span>];</span><br><span class="line">                col += direct[direction][<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            rotal += <span class="number">1</span>;</span><br><span class="line">            direction = (direction+<span class="number">1</span>)%<span class="number">4</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="60、第k个排列"><a href="#60、第k个排列" class="headerlink" title="60、第k个排列"></a>60、<a href="https://leetcode-cn.com/problems/permutation-sequence/" target="_blank" rel="noopener">第k个排列</a></h2><p>逆康拓展开的应用, 康拓展开公式为：<br>$$<br>X=a[n]\times(n-1)!+a[n-1]\times(n-2)!+…+a[i]\times(i-1)!+…+a[1]\times0!<br>$$<br>其中 <code>a[n]</code> 代表当前位置之前比自己小的未出现过的数字的个数。例如：</p><p>计算<code>34152</code> 的康托展开值为：<br>$$<br>X = 2 \times 4! + 2 \times 3! + 0 \times 2! + 1 \times 1! + 0 \times 0! = 61<br>$$</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">getPermutation</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">string</span> ans = <span class="string">""</span>;</span><br><span class="line">        <span class="keyword">int</span> nums[<span class="number">9</span>] = &#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">6</span>, <span class="number">24</span>, <span class="number">120</span>, <span class="number">720</span>, <span class="number">720</span>*<span class="number">7</span>, <span class="number">720</span>*<span class="number">56</span>&#125;;</span><br><span class="line">        <span class="keyword">bool</span> book[<span class="number">10</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">10</span>; i++)</span><br><span class="line">            book[i] = <span class="literal">false</span>;</span><br><span class="line">        k = k<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=n<span class="number">-1</span>; i&gt;=<span class="number">0</span>; i--)&#123;</span><br><span class="line">            <span class="keyword">int</span> large_num = k/nums[i];</span><br><span class="line">            k %= nums[i];</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(large_num==<span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">int</span> j=i; j&lt;=n; j++)&#123;</span><br><span class="line">                        <span class="keyword">if</span>(book[j]==<span class="literal">false</span>)&#123;</span><br><span class="line">                            ans += <span class="string">'0'</span> + j;</span><br><span class="line">                            book[j] = <span class="literal">true</span>;</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(book[i]==<span class="literal">false</span>)</span><br><span class="line">                    large_num--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;51、N皇后&quot;&gt;&lt;a href=&quot;#51、N皇后&quot; class=&quot;headerlink&quot; title=&quot;51、N皇后&quot;&gt;&lt;/a&gt;51、&lt;a href=&quot;https://leetcode-cn.com/problems/n-queens/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;N皇后&lt;/a&gt;&lt;/h2&gt;&lt;p&gt;回溯法&lt;/p&gt;
&lt;figure class=&quot;highlight c++&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;31&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;32&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;33&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Solution&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt;:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; record[&lt;span class=&quot;number&quot;&gt;100&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;bool&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;check&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; n, &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; step)&lt;/span&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt;(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; i=&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;; i&amp;lt;step; i++)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;(record[i]==record[step] || &lt;span class=&quot;built_in&quot;&gt;fabs&lt;/span&gt;(i-step)==&lt;span class=&quot;built_in&quot;&gt;fabs&lt;/span&gt;(record[i]-record[step]))&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;literal&quot;&gt;false&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;literal&quot;&gt;true&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;DFS&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;built_in&quot;&gt;vector&lt;/span&gt;&amp;lt;&lt;span class=&quot;built_in&quot;&gt;vector&lt;/span&gt;&amp;lt;&lt;span class=&quot;built_in&quot;&gt;string&lt;/span&gt;&amp;gt;&amp;gt; &amp;amp;ans, &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; n, &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; step)&lt;/span&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;(step&amp;gt;n)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;built_in&quot;&gt;vector&lt;/span&gt;&amp;lt;&lt;span class=&quot;built_in&quot;&gt;string&lt;/span&gt;&amp;gt; cur_ans(n,&lt;span class=&quot;built_in&quot;&gt;string&lt;/span&gt;(n,&lt;span class=&quot;string&quot;&gt;&#39;.&#39;&lt;/span&gt;));&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt;(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; i=&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;; i&amp;lt;=n; i++)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                cur_ans[i&lt;span class=&quot;number&quot;&gt;-1&lt;/span&gt;][record[i]&lt;span class=&quot;number&quot;&gt;-1&lt;/span&gt;] = &lt;span class=&quot;string&quot;&gt;&#39;Q&#39;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            ans.push_back(cur_ans);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; ;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt;(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; i=&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;; i&amp;lt;=n; i++)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            record[step] = i;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;(check(n, step))&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                DFS(ans, n, step+&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;vector&lt;/span&gt;&amp;lt;&lt;span class=&quot;built_in&quot;&gt;vector&lt;/span&gt;&amp;lt;&lt;span class=&quot;built_in&quot;&gt;string&lt;/span&gt;&amp;gt;&amp;gt; solveNQueens(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; n) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;built_in&quot;&gt;memset&lt;/span&gt;(record, &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;, &lt;span class=&quot;keyword&quot;&gt;sizeof&lt;/span&gt;(record));&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;built_in&quot;&gt;vector&lt;/span&gt;&amp;lt;&lt;span class=&quot;built_in&quot;&gt;vector&lt;/span&gt;&amp;lt;&lt;span class=&quot;built_in&quot;&gt;string&lt;/span&gt;&amp;gt;&amp;gt; ans;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt;(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; i=&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;; i&amp;lt;=n; i++)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            record[&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;] = i;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            DFS(ans, n, &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; ans;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="LeetCode" scheme="https://wangjibao.com.cn/categories/LeetCode/"/>
    
      <category term="LeetCode51-60" scheme="https://wangjibao.com.cn/categories/LeetCode/LeetCode51-60/"/>
    
    
      <category term="LeetCode" scheme="https://wangjibao.com.cn/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>加密流量测量和分析</title>
    <link href="https://wangjibao.com.cn/2019/07/07/%E5%8A%A0%E5%AF%86%E6%B5%81%E9%87%8F%E6%B5%8B%E9%87%8F%E5%92%8C%E5%88%86%E6%9E%90/"/>
    <id>https://wangjibao.com.cn/2019/07/07/加密流量测量和分析/</id>
    <published>2019-07-07T01:16:31.000Z</published>
    <updated>2019-08-28T07:23:32.201Z</updated>
    
    <content type="html"><![CDATA[<h5 id="一、加密与非加密流量识别"><a href="#一、加密与非加密流量识别" class="headerlink" title="一、加密与非加密流量识别"></a>一、加密与非加密流量识别</h5><p>1、利用 <strong>信息熵</strong> 的方法对加密流量进行识别。</p><p>对不同类型的文件，如文本、图片、压缩文件、加密文件等的前 <strong><code>1KB</code></strong>  数据的熵进行计算分析，可以发现文本文件的熵处于较低水平，压缩文件和加密文件的熵处于较高的水平，且两者较难区分。</p><p>多元组熵的定义：</p><p>（1）n元字符组集合指以大小为 n 的滑动窗口对报文序列 P 进行切割后得到的字符串 $s_i (1 \le i \le L-n+1)$ 的集合，L 表示分析报文序列以 <strong>字节</strong> 为单位的长度：<br>$$<br>S_n = \lbrace s_1, s_2, …, s_{L-n+1} \rbrace<br>$$<br> 如 <code>“data.dat”</code> 对应的二元字符组集合为 $S_2 = \lbrace da, at, ta, a., .d, da, at \rbrace​$。</p><a id="more"></a><p>（2）从 n 元字符组集合中各元素出现的频率进行考虑，选择 n 元字符组集合中出现频数高于 k 的元素 $s\prime_{i, k}(1 \le i \le m)$ ，并统计其在集合中出现的频数 $f_{i, k}$ ，组成 k 频 n 元字符组集合为：</p><p>其中，频数阈值 k 为 [1, L-n+1] 区间内的整数， $m(0 \le m \le n)​$ 表示频数不小于 k 的不重复元素的个数。在上文例子中，若取 $n=2, k=1​$ ，则有 $S\prime_{2,1} = \lbrace da:2,\  at:2,\  ta:1,\  a.:1,\  .d:1\rbrace​$ ; 若取 n=2, k=2, 则有 $S\prime_{2,2} = \lbrace da:2, \ at:2\rbrace​$。</p><p>根据以上定义， k 频 n 元字符组集合 $S’<em>{n,k}​$ 的信息熵可以表示为：<br>$$<br>H</em>{n,k} = -\sum_{i=1}^{m} P(s\prime_{i,k}) log_2P(s\prime_{i,k})<br>$$<br>其中，$P\prime_{i,k} = f_{i,k}/\sum_{t=1}^{m}f_{t,k}​$。</p><p>（3）若对长度 n, 频数阈值 k 各取不同的值时，则可以得到一系列关于报文序列 P 的熵值特征，就构成了多元组熵值特征集：<br>$$<br>H = \lbrace H_{n,k} \ \rvert \ n \in[N_a, N_b], k \in [K_a, K_b] \rbrace其中，H 中元素(熵值) 的个数为 $(N_b - N_a) \times (K_b - K_a)​$ 。一般地，对 n, k 的取值区间分别定义为 $[1, N]  和 [1, K]​$ 。在上例中，取 N=2, K=2，则序列 <code>“data.dat”</code> 的多元熵值特征集为 $H = \lbrace H_{1,1}\approx1.906, \ H_{1,2}\approx0.835, \ H_{2,1}\approx1.514, H_{2,2}\approx1\rbrace​$。<br>$$<br>其中，H 中元素(熵值) 的个数为 $(N_b - N_a) \times (K_b - K_a)$ 。一般地，对 n, k 的取值区间分别定义为 $[1, N]  和 [1, K]$ 。在上例中，取 N=2, K=2，则序列 <code>“data.dat”</code> 的多元熵值特征集为 $H = \lbrace H_{1,1}\approx1.906, \ H_{1,2}\approx0.835, \ H_{2,1}\approx1.514, H_{2,2}\approx1\rbrace$。</p><p>2、利用 <strong>累加和检测</strong> 的方法对加密流量进行识别。</p><p>多元组熵是以字节为单位的随机性检测，其需要一定数量的数据，计算相对复杂；而累加和检验是以比特位单位的随机性检测，通常只需要较少的数据即可有较好的检验效果，且具有较快的计算速度。</p><p>累加和检验有正向和反向两种模式，两个模式的区别仅在于遍历顺序，其中，正向模式下的累加和检测的步骤如下：</p><ul><li><p>将比特序列 $\varepsilon$ 调整为 $(-1, 1)$ 的形式的序列 X。 $X_i = 2\varepsilon_i - 1$</p></li><li><p>计算序列 X 的前 k 项和 $S_k$</p></li><li><p>计算正向模式下 $\lvert S_k \rvert$ 的最大值 z</p></li><li><p>计算检验值 P</p></li></ul><p>P 的取值一般在 $0\thicksim1$ 之间，其值越大，则待检测序列的随机性越高。通常情况下，设定一个 $\alpha$ 为阈值，当 $P &gt; \alpha$ ，接受检验序列为随机，反之，则拒绝随机性假设。</p><h4 id="二、加密流量应用服务识别"><a href="#二、加密流量应用服务识别" class="headerlink" title="二、加密流量应用服务识别"></a>二、加密流量应用服务识别</h4><p><strong>1、基于选择性集成的特征选择方法</strong></p><p>该方法可以克服基于端口和深度包检测方法的不足，但特征属性中包含的冗余和不相关特征会增加模型复杂度、降低模型可信度，导致分类效果和效率同时下降。</p><p>算法流程：第一部分，将多个特征选择器选取的特征子集根据评价指标进行排序，再根据选择性集成策略选择部分特征选择器，从已有的特征选择器中将作用不大和性能不好的特征选择器剔除，将保留的特征选择器集成（特征的并集）。第二部分，采用朴素贝叶斯算法评估<strong>序列前向搜索</strong>（先选择一个最优的特征，再选择一个与其组合起来最优的特征，一直一个个特征往最优特征子集中加，直到判据值 $J$ 降低为结束准则）产生的特征子集，以分类准确率下降为结束准则，再比较多个数据集（同一目的的数据集，只是不同类别的分布状况不一样）的最优特征子集选出全局特征子集，提高特征子集的稳定性。流程如下图：</p><p><img src="/2019/07/07/加密流量测量和分析/FSEN.png" alt=""></p><p><strong>2、基于加权集成学习的自适应分类方法</strong></p><p>针对 <code>DPI</code> 分类方法解析数据包负载内容侵犯隐私，且对加密业务无能为力，促使研究人员转向基于机器学习的流量分类方法。</p><p>如果能够准确地识别网络流的变化，就可以及时有效地更新分类器，从而避免仅根据经验设置固定的时间间隔频繁更新分类器。首先，多个集成的分类器根据他们的分类性能设置不同的权重（分类精度高的分类器权值大），然后，根据信息熵检测网络流的变化，一但网络流发生变化，再建立一个分类器，这个新的分类器是用最新的样本训练出来的，之后，用它替换掉原始多个分类器中权值最小的那个。</p><p>这样，一方面充分利用先前训练的分类器，另一方面在保留先前训练的分类器的基础上引入当前样本训练的分类器集成，并剔除性能下降的分类器，保证模型集成分类器的泛化能力。</p><p><strong><a href="https://www.cs.waikato.ac.nz/ml/weka/" target="_blank" rel="noopener">Weka 3</a>: Machine Learning Software in Java</strong></p><p><strong>3、<code>non-VPN</code> 和 <code>VPN</code> 加密流量分类方法</strong></p><p><code>TCP</code> 流通常在会话结束时（通过 <code>FIN</code> 数据包） 终止，而 <code>UDP</code> 流由流超时终止。</p><p>通过提取 <strong>流</strong> 中与时间相关的特征来识别 <code>加密和VPN</code> 流量，进行分类。用到的特征如下图：</p><p><img src="/2019/07/07/加密流量测量和分析/feature.jpg" alt=""></p><h4 id="三、TLS-加密流量分类方法"><a href="#三、TLS-加密流量分类方法" class="headerlink" title="三、TLS 加密流量分类方法"></a>三、<code>TLS</code> 加密流量分类方法</h4><p><strong>1、基于<code>Markov</code>链的分类</strong></p><p>识别<code>SSL/TLS</code> 加密应用，二阶<code>Markov</code>链和<code>HMM</code> 模型分别建立在 <code>SSL/TLS</code> 协议交互的握手过程和数据传输过程（使用握手过程中的报文类型和分组长度，数据传输过程中的数据包长度），然后建立加权集成分类器。每个每类器的权重与当前分类器的分类误差 成反比，具体的：<br>$$<br>MSE_i = \frac{1}{|S_n|} \sum_{(x,c) \in S_n }(1-f_c^i(x))^2<br>$$</p><p>$$<br>MSE_r = \sum_c p(c)(1-p(c))^2<br>$$</p><p>$$<br>第i个分类器的权重：w_i = MSE_r - MSE_i<br>$$</p><p><strong>2、<code>Tor</code> 行为分析 </strong></p><p>默认情况下，<code>Tor</code> 服务器生成的证书的<strong>颁发者</strong>和<strong>证书主体</strong>都使用随机公共名称，<strong>主题</strong> 和 <strong>发布者</strong> 字段是独立生成的，因此彼此不同。主题和发行者字段都不包含证书中常见的（并有证书颁发机构强制要求）的其他信息，例如<strong>位置</strong> 或 <strong>公司名称</strong>。这些特征允许通过解析数据集中的 <code>X.509</code> 证书，然后在其 <strong>主题</strong> 和 <strong>颁发者</strong>  字段上匹配相应的正则表达式来识别 <code>Tor</code> 连接。</p><p>但以这种方式识别 <code>Tor</code> 连接的一个潜在缺陷在于 <code>TLS</code> 会话恢复，其跳过大多数<code>TLS</code> 握手，包括证书交换，用于连接到同一<code>TLS</code> 服务器的连接。但是，<code>Tor</code> 规范声名 <code>Tor</code> 客户端和服务器不能实现会话恢复。</p><h4 id="四、HTTPS-加密流量分类方法"><a href="#四、HTTPS-加密流量分类方法" class="headerlink" title="四、HTTPS 加密流量分类方法"></a>四、<code>HTTPS</code> 加密流量分类方法</h4><p><strong>1、<code>HTTPS</code> 加密流量的识别方法</strong></p><p>会话（流）用五元组 <code>(协议、源IP、目的IP、源端口、目的端口)</code>  表示，标签是元组 <code>(OS、浏览器、应用)</code> 。提取特征，训练分类器对其进行识别。</p><p><strong>2、<code>HTTPS</code> 协议语义推断</strong></p><p>在不解密 <code>HTTPS</code> 流量的情况下，训练分类器识别 <code>HTTPS</code> 流中的某些字段，如状态码、方法、是否含有 <code>Cookie</code> 字段、<code>Content-Type</code> 字段的类型 等等。</p><p><strong>3、识别<code>TLS</code> 连接拦截</strong></p><p>如网络中间件和防病毒安全产品会对 <code>TLS</code> 连接进行拦截，其在本地客户端和远程服务器中间充当一个中间人。为了识别出是否发生了 <code>TLS</code> 连接拦截，可以通过 <code>Client Hello</code> 消息中宣称的浏览器类型和其中的<strong><code>TLS</code>扩展、密码、椭圆曲线和压缩方法</strong> 等生成的指纹是否匹配来识别，因为每个浏览器虽然有不同的客户端类型和版本，但也可以为它们生成特定的指纹库。</p><p>当发生了拦截时，可进一步识别出是谁（什么设备）拦截了此<code>TLS</code> 连接，通过为市面上的大量产品生成一个设备指纹库，然后匹配被拦截修改后的 <code>Client Hello</code> 中的<strong>版本、密码、扩展、压缩方法、椭圆曲线和签名算法</strong> 等生成的指纹和库中的那个设备的指纹相匹配。</p><p>通过对 <code>TLS</code> 连接的安全性进行量化后，发现网络中间件或拦截产品降低了原始连接的安全性。</p><h4 id="五、加密视频流量参数识别"><a href="#五、加密视频流量参数识别" class="headerlink" title="五、加密视频流量参数识别"></a>五、加密视频流量参数识别</h4><p><strong>1、对视频 <code>QoE</code> 进行量化评估</strong></p><p>1）视频是分块传输的，其中，视频源质量、初始缓冲时延和卡顿时长 是影响用户体验的最重要的外部因素。</p><p>视频源质量 <code>sQuality</code> 表示如下：<br>$$<br>sQuality = Qualitymax \times (1-\frac{1}{(1+VB \times VC \times \frac{CP}{VR})^2})<br>$$<br>其中，<code>VC</code> 代表 视频压缩算法，<code>CP</code> 代表 视频源编码等级， <code>VR</code> 代表 视频清晰度， <code>VB</code> 代表 码率， <code>Qualitymax</code> 代表当前清晰度视频源质量评分的最高值，对于清晰度为 <code>4K, 2K, 1080P, 720P 和 360P</code> 的视频，<code>Qualitymax</code> 值分别为 <code>4.9, 4.8, 4.5, 4, 3.6 和 2.8</code>。</p><p>2）初始缓冲时延<code>(IBL)</code>是从点击<code>播放</code> 到视频播放的等待时间，初始缓冲时延 <code>sLatency</code> 表示如下：</p><p><img src="/2019/07/07/加密流量测量和分析/1.png" alt=""></p><p>3）卡顿是指播放过程中缓冲的数据量被消耗完所产生的视频播放停止（与 卡顿时长、次数等相关），卡顿时长占比 <code>sStalling</code> 表示如下：</p><p><img src="/2019/07/07/加密流量测量和分析/2.png" alt=""></p><p>综合考虑视频源质量、初始缓冲时延和卡顿占比 3 个 <code>KPIs</code> 提出的 <code>vMOS</code> 模型对视频 <code>QoE</code> 进行客观评估，<code>vMoS</code> 表示如下：<br>$$<br>\begin{equation}<br>vMoS =<br>(1-0.092 \times (1+2e^{-sLatency})) \times (5-sLatency) \times sQuality - \<br>0.018 \times (1+2e^{-sStalling}) \times (5-sStalling)<br>\end{equation}<br>$$<br><strong>2、基于视频块特征的视频 <code>QoE</code> 参数识别</strong></p><p><code>SSL/TLS</code> 加密 <code>YouTube</code> 流量识别模块、传输模式识别模块、<code>QoE</code> 参数识别模块以及视频<code>QoE</code> 评估模块。首先，根据 <code>SSL/TLS</code> 协议握手过程中 <code>Client Hello</code> 数据包中的未加密内容识别加密 <code>YouTube</code> 流量；然后，根据视频流的前几个包的特征识别出不同传输模式，在根据视频块统计特征建立分类模式识别视频块的码率和清晰度；最后，根据该视频参数和传输参数计算视频 <code>QoE</code>。</p><p>1）在 <code>SSL/TLS</code> 加密 <code>YouTube</code> 流量识别模块中，根据预先建立视频服务器 <code>IP</code> 白名单，过滤出混乱流量中的加密 <code>YouTube</code> 流量。</p><p>2）在传输模式识别模块中，当前加密 <code>YouTube</code> 自适应码流传输模式主要有 <code>Apple HLS</code>、<code>MPEG DASH</code> 和 <code>HPD</code>。在同一时间，<code>HPD</code>采用单流传输（视频和音频没有分离），而<code>DASH</code> 和 <code>HLS</code> 采用多条流传输，采用相邻两条流之间的 <code>SYN-ACK</code> 包的到达时间间隔来区分出 <code>HPD</code> 传输模式。</p><p><code>DASH</code> 和 <code>HLS</code> 视频传输都是将视频进行分段后使用基于 <code>TCP</code> 的 <code>HTTPS</code> 流传输的，由于 <code>TCP</code> 的 <code>MSS</code> 所限制，视频片段被分割成大量 <code>1.4KB</code> 左右的数据包传输，而这些数据包响应的都是同一个请求，所以他们的 <code>ACK Number</code> 相同。但是在 <code>DASH</code> 传输模式下，服务器需要先向客户端发送 <code>Initial Segment</code>，<code>Initial Segment</code> 包含了视频解码器所需的初始化信息，然后再开始传输视频数据，在加密数据包中的表现就是经过 <code>SSL/TLS</code> 握手阶段后开始传输的前 <code>P</code> 个 <code>Application data</code> 数据包出现 <code>S</code> 种 <code>ACK Number</code>。可以利用此特征来区分 <code>DASH</code> 和 <code>HLS</code> 视频传输模式，统计发现 <code>DASH</code> 前 <strong>三</strong> 个数据包的 <code>ACK Number</code> 种类数为 <code>2</code> 或 <code>3</code> ，而 <code>HLS</code> 和 <code>HPD</code> 的种类数都为 <code>1</code>。</p><p><strong>3、加密视频 <code>QoE</code> 评估</strong></p><p>影响自适应和经典视频流 <code>QoE</code> 的 3 个关键因素：卡顿、清晰度质量和质量切换。</p><p>研究发现，视频片段的大小和到达间隔时间的变化是影响质量的两个重要指标。</p><h4 id="六、加密恶意流量识别"><a href="#六、加密恶意流量识别" class="headerlink" title="六、加密恶意流量识别"></a>六、加密恶意流量识别</h4><p><strong>1、处理数据类别不平衡问题</strong></p><p>存在两种方法，一种是<strong>过采样</strong>：不断将少数类重新采样到训练数据集中的方法；另一种是<strong>欠采样</strong>：随机消除多数类数据的方法。</p><p><strong>2、梯度稀释问题</strong><br>$$<br>\frac{\partial Loss}{\partial \theta} = \sum_{M_i \in M}\sum_{A_{ik} \in M_i}\frac{\partial Loss_{A_{ik}}}{\partial \theta}<br>$$<br><code>M</code> 代表训练数据集，$M_i$ 代表 <code>M</code> 的第 <code>i</code> 类，$A_{ik}$ 是 $M_i$ 的第 <code>k</code> 个数据， $Loss_{A_{ik}}$ 是数据 $A_{ik}$ 贡献的损失。可以看到参数 $\theta$ 相对于每个类的更新次数取决于每个类的大小。一旦数据的数量严重不同，模型将倾向于偏向多数类，因为总梯度将由多数类在频率方面贡献的梯度所支配。这种现象将导致模型对少数类的不敏感，因为模型很少更新关于少数类的参数。由少数群体贡献的梯度逐渐消失，好像被多数群体所贡献的那样稀释了，这种现象称为 <strong>梯度稀释</strong>。</p><p><strong>3、零样本学习</strong></p><p>网络社会中存在各种恶意软件，每天都有许多新的变种，所以不可能手机每个家族的数据样本。为了评估所提出模型的泛化性能，检查<code>***</code>模型识别从未训练过的一些恶意软件的能力，这种场景被创造为机器学习术语中的“零样本学习”。</p><p><strong>4、字节分布特征</strong></p><p>字节分布是长度为 <code>256</code> 的数组，它保持流中每个数据包的有效负载中遇到的每个字节值的计数。通过将字节分布计数除以在分组的有效载荷中的总字节数，可以容易地计算字节值概率。</p><p>完整的字节分布提供了大量有关数据编码的信息。</p><p><strong>5、正常企业流量和恶意软件流量中的<code>TLS</code>连接的区别</strong></p><ul><li>密码套件。 一般企业流量中提供的密码套件安全性比较高，而恶意软件流量中提供的密码套件安全性低，两者存在比较大的区别。</li><li><code>TLS</code> 扩展。 几乎一半的企业客户端会支持多达 9 个扩展，但恶意客户端只会一致地支持一个。</li><li>客户端的公钥长度。 大多数企业流量使用 <code>512</code> 位<code>(ECDHE_RSA)</code> 公钥，恶意软件几乎只使用 <code>2048</code> 位 <code>(DHE_RSA)</code> 公钥。</li></ul><p><strong>6、分类恶意 <code>TLS</code> 流量</strong></p><p><code>DNS</code> + <code>HTTP</code> + <code>TLS</code> 三者相关联，提取特征进行分类识别。</p><p>用到的特征:</p><ul><li>可观察元特征。 包长及时间间隔转移矩阵，字节分布等。</li><li><code>TLS</code> 数据。 密码套件、支持的扩展及公钥长度； 服务器选定的密码套件、支持的扩展、证书数量、有效天数及是否有自签名等。 统计出现的所有种类，然后<code>onehot</code>编码生成一个特征向量。</li><li><code>DNS</code> 数据。 <code>TTL</code> 值、<code>DNS</code>响应中域名的数字字符数、非字母数字字符数、返回的 <code>IP</code>地址的个数、域名是否出现在 <code>Alexa</code> 列表前 100、 前1000、 前10000、 前 100000里等。</li><li><code>HTTP</code> 数据。 <code>Content-Type</code> 、 <code>User-Agent</code> 、<code>Accept-Language</code> 、 <code>Server</code> 和 <code>Code</code> 等。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h5 id=&quot;一、加密与非加密流量识别&quot;&gt;&lt;a href=&quot;#一、加密与非加密流量识别&quot; class=&quot;headerlink&quot; title=&quot;一、加密与非加密流量识别&quot;&gt;&lt;/a&gt;一、加密与非加密流量识别&lt;/h5&gt;&lt;p&gt;1、利用 &lt;strong&gt;信息熵&lt;/strong&gt; 的方法对加密流量进行识别。&lt;/p&gt;
&lt;p&gt;对不同类型的文件，如文本、图片、压缩文件、加密文件等的前 &lt;strong&gt;&lt;code&gt;1KB&lt;/code&gt;&lt;/strong&gt;  数据的熵进行计算分析，可以发现文本文件的熵处于较低水平，压缩文件和加密文件的熵处于较高的水平，且两者较难区分。&lt;/p&gt;
&lt;p&gt;多元组熵的定义：&lt;/p&gt;
&lt;p&gt;（1）n元字符组集合指以大小为 n 的滑动窗口对报文序列 P 进行切割后得到的字符串 $s_i (1 \le i \le L-n+1)$ 的集合，L 表示分析报文序列以 &lt;strong&gt;字节&lt;/strong&gt; 为单位的长度：&lt;br&gt;$$&lt;br&gt;S_n = \lbrace s_1, s_2, …, s_{L-n+1} \rbrace&lt;br&gt;$$&lt;br&gt; 如 &lt;code&gt;“data.dat”&lt;/code&gt; 对应的二元字符组集合为 $S_2 = \lbrace da, at, ta, a., .d, da, at \rbrace​$。&lt;/p&gt;
    
    </summary>
    
      <category term="笔记" scheme="https://wangjibao.com.cn/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="笔记" scheme="https://wangjibao.com.cn/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>HTTP2协议解析及抓包分析</title>
    <link href="https://wangjibao.com.cn/2019/07/05/HTTP2%E5%8D%8F%E8%AE%AE%E8%A7%A3%E6%9E%90%E5%8F%8A%E6%8A%93%E5%8C%85%E5%88%86%E6%9E%90/"/>
    <id>https://wangjibao.com.cn/2019/07/05/HTTP2协议解析及抓包分析/</id>
    <published>2019-07-05T12:17:27.000Z</published>
    <updated>2019-07-05T12:34:48.856Z</updated>
    
    <content type="html"><![CDATA[<h4 id="一、HTTP2协议简介"><a href="#一、HTTP2协议简介" class="headerlink" title="一、HTTP2协议简介"></a>一、HTTP2协议简介</h4><h5 id="1、HTTP2的帧格式"><a href="#1、HTTP2的帧格式" class="headerlink" title="1、HTTP2的帧格式"></a>1、HTTP2的帧格式</h5><p>HTTP2的所有帧都是由一个固定的<strong>9</strong>字节头部（payload之前）和一个指定长度的负载（payload）组成，如下图所示：</p><p><img src="/2019/07/05/HTTP2协议解析及抓包分析/h2帧格式.jpg" alt=""></p><p>其中，<code>Stream Identifier</code>用作流控制，用31位无符号整数表示。客户端建立的<code>sid</code>必须为奇数，服务端建立的<code>sid</code>必须为偶数，<strong>值（0x0）保留给与整个连接相关联的帧（连接控制消息），而不是单个流。</strong></p><p><code>Frame Payload</code>是主体内容，有帧类型决定，HTTP2一共有<strong>10</strong>种类型的帧：</p><a id="more"></a><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">   名称           描述         type值</span><br><span class="line"> HEADERS        报头帧          0x1</span><br><span class="line">   DATA         数据帧          0x0</span><br><span class="line"> PRIORITY       优先级帧        0x2</span><br><span class="line">RST_STREAM      流终止帧        0x3</span><br><span class="line"> SETTINGS       设置帧          0x4</span><br><span class="line">PUSH_PROMISE    推送帧          0x5</span><br><span class="line">   PING         PING帧         0x6</span><br><span class="line">  GOAWAY        GOAWAY帧       0x7</span><br><span class="line">WINDOW_UPDATE   窗口更新帧       0x8</span><br><span class="line">CONTINUATION    延续帧          0x9</span><br></pre></td></tr></table></figure><p>实际上，HTTP2并没有改变HTTP1.x的语义，只是把原来HTTP1.x的<code>Header</code>和<code>Body</code>部分用<code>Frame</code>重新封装了一层而已。调试的时候浏览器设置会把<code>HTTP2</code>的<code>Frame</code>自动还原成<code>HTTP1.x</code>的格式。两者的帧格式对比如下图：</p><p><img src="/2019/07/05/HTTP2协议解析及抓包分析/h1_vs_h2.png" alt=""></p><h5 id="2、HTTP2的改进及优点"><a href="#2、HTTP2的改进及优点" class="headerlink" title="2、HTTP2的改进及优点"></a>2、HTTP2的改进及优点</h5><ul><li><p>二进制分帧</p><p>帧是客户端和服务端之间通信的最小单位，比起<code>HTTP1.x</code>这样的文本协议，二进制协议解析起来更高效，且没有冗余字段（HTTP1.x 协议每个包都会有重复传输的头部字段），占用带宽少。</p></li><li><p>多路复用</p><blockquote><p>可以并行交错地发送请求，请求之间互不影响；</p><p>可以并行交错地发送响应，响应之间互不干扰；</p><p>只使用一个连接即可并行发送多个请求和响应；</p><p>消除不必要的延迟，从而减少页面加载的时间；</p></blockquote></li></ul><p>增加了<strong>请求优先级</strong>字段，服务器可以根据流的优先级，控制资源分配，而在响应数据准备好之后，将优先级最高的帧发送给客户端。</p><p>增加了<strong>Header压缩</strong>，通信双方各自 <code>cache</code> 一份 <code>header fields</code>表。</p><p>增加了<strong>服务器推送</strong>，服务器可以对一个客户端请求发送多个响应，服务器向客户端推送资源无需客户端明确地请求。服务器推送通过<code>PUSH</code>那些它认为客户端将会需要的内容到客户端的缓存中，避免往返的延迟。比如，请求<code>index.html</code>，但服务器会把<code>style.css, example.png</code>等资源也发送给浏览器。</p><p><strong>流量控制</strong>，每个<code>HTTP2</code>的流都拥有自己公示的流量窗口，它可以限制另一端发送数据。</p><p><img src="/2019/07/05/HTTP2协议解析及抓包分析/h2.png" alt=""></p><h4 id="二、配置Wireshark抓取HTTP2数据包"><a href="#二、配置Wireshark抓取HTTP2数据包" class="headerlink" title="二、配置Wireshark抓取HTTP2数据包"></a>二、配置Wireshark抓取HTTP2数据包</h4><p>1、在电脑里创建一个后缀名为 <code>.log</code> 的文件，记住其路径。</p><p>2、在电脑的系统变量里创建一个新的变量，名为<code>SSLKEYLOGFILE</code>。配置了此变量后，浏览器会到这里来记录通信过程中密钥。</p><p><img src="/2019/07/05/HTTP2协议解析及抓包分析/h2_4.png" alt=""></p><p>3、在<code>wireshark</code>中，<code>分析 &gt;&gt; 已解析的协议...</code>中，启用<code>HTTP2</code>的解析。并在 <code>编辑 &gt;&gt; 首选项 &gt;&gt; Protocols &gt;&gt; TLS</code> 中，配置 <code>(Pre)-Master-Secret</code> 为之前创建的<code>log</code>文件，之后，<code>wireshark</code>就可以凭借此文件中的秘钥解密<code>HTTP2</code>中的各个加密字段，便于我们进行协议分析。</p><p><img src="/2019/07/05/HTTP2协议解析及抓包分析/h2_2.png" alt=""></p><h4 id="三、HTTP2协议数据包解析"><a href="#三、HTTP2协议数据包解析" class="headerlink" title="三、HTTP2协议数据包解析"></a>三、HTTP2协议数据包解析</h4><p>数据包<a href="/download/h2.rar">点击下载</a></p><p><img src="/2019/07/05/HTTP2协议解析及抓包分析/h2_3.png" alt=""></p><p>1、从上图可以看到，<code>HTTP2</code>协议的工作流程为：建立<code>TCP</code>连接、建立<code>TLS</code>连接、<code>HTTP2</code>通信，断开<code>TCP</code>连接 四个过程。在<code>Client Hello</code>中，客户端再扩展字段中会说明其所支持的协议，指定<code>ALPN Next Protocol</code> 为 <code>h2</code> 或 <code>HTTP/1.1</code>。之后，服务端在<code>Server Hello</code>中，回复所协商的接下来使用的应用层协议。如下图：</p><p><img src="/2019/07/05/HTTP2协议解析及抓包分析/h2_5.png" alt=""></p><p>2、在<code>TLS</code>连接过程中，如果服务器支持<code>session ticket</code>，则发送<code>New Session Ticket</code>类型的握手报文，其中包含了能够恢复包括主密钥在内的会话信息。为了不让中间人可见，这个<code>session ticket</code>部分会进行编码、加密等操作，同时，还会指定此<code>ticket</code>的过期时间等。</p><p><img src="/2019/07/05/HTTP2协议解析及抓包分析/h2_6.png" alt=""></p><p>3、从第一幅图中可以看出，在客户端发送<code>Finished</code>消息（#11）之后，就开始将<code>HTTP</code>封装到<code>Application Data</code>协议中发送给服务器（#12，#13，#14，#15，#16）了，此时，<code>TLS</code>握手还没有完全完成。</p><p><code>HTTP2</code>中基本的协议单位是帧，每个帧都有不同的类型和用途。例如，报头<code>(HEADERS)</code>和数据<code>(DATA)</code>帧组成了基本的<code>HTTP</code>请求和响应；其他帧如设置<code>(SETTINGS)</code>，窗口更新<code>(WINDOW_UPDATE)</code>和推送承诺<code>(PUSH_PROMISE)</code>是用来实现<code>HTTP2</code>的其他功能。</p><p>4、<strong>（#12）</strong>帧分析：在<code>HTTP2</code>请求创建连接发送<code>SETTINGS</code>帧初始化之前有一个<code>Magic</code>帧，为建立<code>HTTP2</code>请求的前言<code>(connection preface)</code>，此前言作为对所使用协议的最终确认，并确定<code>HTTP2</code>连接的初始设置。在发送完前言后，双方都得向对方发送带有<code>ACK</code>标识的<code>SETTINGS</code>帧标识确认，对应图中的<strong>#21</strong> 和 <strong>#22</strong> 号帧：</p><p><img src="/2019/07/05/HTTP2协议解析及抓包分析/h2_7.png" alt=""></p><p>12号帧，组合了<code>Magic</code>、<code>SETTINGS</code>和<code>WINDOW_UPDATE</code>三种帧为一个数据包，其中包含的参数如下图：</p><p><img src="/2019/07/05/HTTP2协议解析及抓包分析/h2_8.png" alt=""></p><p><code>WINDOW_UPDATE</code>中的<code>stream identifier</code>为<code>0</code>表示此窗口更新帧作用于整个连接，指定其他具体值可使其作用于某个特定的单独连接。</p><p>5、<strong>（#13）</strong>号帧分析，客户端在发送完连接前言后，可立即跟上一个请求<code>(request)</code>。这里客户端向服务器发送<code>GET /HEADERS</code>，<code>HEADERS</code>帧用来打开一个流或携带一个首部块片段，此<code>HEADERS</code>帧包括了请求行和请求头的内容，属于<code>1</code> 号流：</p><p><img src="/2019/07/05/HTTP2协议解析及抓包分析/h2_9.png" alt=""></p><p>其中，<code>Exclusive</code>：一个比特位声明流的依赖性是否是排它的，这里为 <code>1</code>，代表此流不依赖其他的流。<code>Weight</code>：代表当前流的优先级权重。<code>End Headers</code>：这里为 <code>1</code> 代表<code>header</code>块结束。<code>Priority</code>设置为 <code>1</code>，代表存在<code>Exclusive</code>、<code>Stream Dependency</code> 和 <code>Weight</code>。</p><p>6、<strong>(#19)</strong> 号包分析，服务器向客户端发送<code>SETTINGS</code> 和 <code>WINDOW_UPDATE</code> 帧，<code>SETTINGS</code>帧为连接前言 <code>(connection preface)</code>，帧中设置了最大并行流数量、初始窗口大小、最大帧长度，<code>WINDOW_UPDATE</code> 给出扩大窗口的大小。这两个帧属于 <code>0</code> 号流。</p><p><img src="/2019/07/05/HTTP2协议解析及抓包分析/h2_10.png" alt=""></p><p>7、<code>DATA</code> 帧，服务器向客户端发送<code>DATA</code>帧，即响应主体。<code>DATA</code> 帧用来装填主体信息，可以用一个或多个<code>DATA</code> 帧来返回一个请求的响应主体。</p><p><img src="/2019/07/05/HTTP2协议解析及抓包分析/h2_11.png" alt=""></p><p>上图左边为<code>HEADERS</code>帧，服务器向客户端返回响应<code>(response)</code>，此报头帧包含了状态行和响应头的内容，此帧属于 <code>3</code> 号流。 <code>Status: 200 OK</code> 表示状态码为 200，客户端请求成功。此外，响应头还给出了服务器所使用的的服务器型号、内容类型等。注意观察图中的标志位 <code>End Stream</code> 和 <code>End Headers</code> 的变化。</p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;一、HTTP2协议简介&quot;&gt;&lt;a href=&quot;#一、HTTP2协议简介&quot; class=&quot;headerlink&quot; title=&quot;一、HTTP2协议简介&quot;&gt;&lt;/a&gt;一、HTTP2协议简介&lt;/h4&gt;&lt;h5 id=&quot;1、HTTP2的帧格式&quot;&gt;&lt;a href=&quot;#1、HTTP2的帧格式&quot; class=&quot;headerlink&quot; title=&quot;1、HTTP2的帧格式&quot;&gt;&lt;/a&gt;1、HTTP2的帧格式&lt;/h5&gt;&lt;p&gt;HTTP2的所有帧都是由一个固定的&lt;strong&gt;9&lt;/strong&gt;字节头部（payload之前）和一个指定长度的负载（payload）组成，如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/2019/07/05/HTTP2协议解析及抓包分析/h2帧格式.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;其中，&lt;code&gt;Stream Identifier&lt;/code&gt;用作流控制，用31位无符号整数表示。客户端建立的&lt;code&gt;sid&lt;/code&gt;必须为奇数，服务端建立的&lt;code&gt;sid&lt;/code&gt;必须为偶数，&lt;strong&gt;值（0x0）保留给与整个连接相关联的帧（连接控制消息），而不是单个流。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Frame Payload&lt;/code&gt;是主体内容，有帧类型决定，HTTP2一共有&lt;strong&gt;10&lt;/strong&gt;种类型的帧：&lt;/p&gt;
    
    </summary>
    
      <category term="笔记" scheme="https://wangjibao.com.cn/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="笔记" scheme="https://wangjibao.com.cn/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>IPSec VPN搭建及协议解析</title>
    <link href="https://wangjibao.com.cn/2019/07/02/IPSec-VPN%E6%90%AD%E5%BB%BA%E5%8F%8A%E5%8D%8F%E8%AE%AE%E8%A7%A3%E6%9E%90/"/>
    <id>https://wangjibao.com.cn/2019/07/02/IPSec-VPN搭建及协议解析/</id>
    <published>2019-07-02T14:08:50.000Z</published>
    <updated>2019-07-03T01:42:36.710Z</updated>
    
    <content type="html"><![CDATA[<h4 id="一、IPSec协议简介"><a href="#一、IPSec协议简介" class="headerlink" title="一、IPSec协议简介"></a>一、IPSec协议简介</h4><p><code>IPSec</code>是<code>IETF</code>制定的为保证在<code>Internet</code>上传送数据的安全保密性能的三层隧道加密协议。<code>IPSec</code>是应用于<code>IP</code>层上网络数据安全的一整套体系结构，他包括<strong>报文首部认证协议</strong><code>（ Authentication Header, AH）</code>、<strong>封装安全载荷协议</strong><code>(Encapsulating Security Payload, ESP)</code>、<strong>互联网间密钥交换协议</strong><code>(Internet Key Exchange, IKE)</code> 和一些用于网络认证及加密的算法等。<code>IPSec</code>协议本身定义了如何在<code>IP</code>数据包中增加字段来保证<code>IP</code>包的完整性、私有性和真实性，以及如何加密数据包。</p><p><code>IPSec</code>有传输<code>(transport)</code>和隧道<code>(tunnel)</code>两种工作方式，其中，传输模式适用于主机之间建立<code>IPSec</code>安全传输，隧道模式更适合网关之间的通信，常用来实现虚拟专用网<code>VPN</code>。</p><h4 id="二、IPSec-VPN搭建"><a href="#二、IPSec-VPN搭建" class="headerlink" title="二、IPSec-VPN搭建"></a>二、IPSec-VPN搭建</h4><p>详细教程请参考：<a href="https://github.com/hwdsl2/setup-ipsec-vpn/blob/master/README-zh.md" target="_blank" rel="noopener">https://github.com/hwdsl2/setup-ipsec-vpn/blob/master/README-zh.md</a></p><p>以 <code>Ubuntu 16.04</code>为例，首先执行：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget https://git.io/vpnsetup -O vpnsetup.sh</span><br></pre></td></tr></table></figure><p>之后，在<code>vpnsetup.sh</code>文件中，设置<code>YOUR_IPSEC_PSK, YOUR_USERNAME 和 YOUR_PASSWORD</code>三个字段，如下图：</p><p><img src="/2019/07/02/IPSec-VPN搭建及协议解析/vpnsetup.png" alt=""></p><a id="more"></a><p>最后，通过命令 <code>sudo sh vpnsetup.sh</code> 启动服务器的 <code>ipsec vpn</code>服务。接下来，就是客户端的配置，以安卓手机为例：</p><p><img src="/2019/07/02/IPSec-VPN搭建及协议解析/ipsec1.png" alt=""></p><p>选择对应的 <code>VPN</code> 添加类型，其中<code>IPSec Xauth</code> 类型也称 <code>Cisco IPsec</code> 模式，更加高效一些。填写好服务器地址、预共享密钥<code>(PSK)</code> 、用户名和密码后，即可使用该 <code>VPN</code>，如果服务器在香港或国外的话，即可实现<code>翻墙</code>的功能。</p><h4 id="三、IPSec协议解析"><a href="#三、IPSec协议解析" class="headerlink" title="三、IPSec协议解析"></a>三、<code>IPSec</code>协议解析</h4><p><code>IPSec</code>主要包括两部分协议，分别是 <code>ISAKMP</code> 协议和 <code>ESP</code>协议，可使用<code>wireshark</code>采集以上两种协议的报文。</p><p><strong>(1) <code>ISAKMP</code>协议</strong></p><blockquote><p>第一阶段，通信双方彼此间建立一个已通过身份认证和安全保护的通道，即建立一个<code>ISAKMP SA</code>。第一阶段有主模式<code>（Main Mode）</code>和野蛮模式<code>（Aggressive Mode）</code>两种<code>IKE</code>交换方法。        </p><p> 第二阶段，使用在第一阶段建立的安全隧道为<code>IPsec</code>协商安全服务，即为<code>IPsec</code>协商具体的<code>SA</code>，建立用于最终的<code>IP</code>数据安全传输的<code>IPsec SA</code>。</p></blockquote><p><strong>第一阶段</strong>的<strong>主模式</strong>交换过程：</p><p><img src="/2019/07/02/IPSec-VPN搭建及协议解析/isakmp.png" alt=""></p><p>对应的数据包为<a href="/download/isakmp.pcap">点我下载</a>：</p><p><img src="/2019/07/02/IPSec-VPN搭建及协议解析/isakmp_1.png" alt=""></p><ul><li>消息①和②用于策略交换（包为明文）</li></ul><blockquote><p>发起方发送一个或多个<code>IKE</code>安全提议，响应方查找最先匹配的<code>IKE</code>安全提议，并将这个<code>IKE</code>安全提议回应给发起方。匹配的原则为协商双方具有相同的加密算法、认证算法、认证方法和<code>Diffie-Hellman</code>组标识。</p></blockquote><ul><li>消息③和④用于密钥信息交换（包为明文）</li></ul><blockquote><p>双方交换<code>Diffie-Hellman</code>公共值和<code>nonce</code>值，用于<code>IKE SA</code>的认证和加密密钥在这个阶段产生。</p></blockquote><ul><li>消息⑤和⑥用于身份和认证信息交换（包为密文）</li></ul><blockquote><p>双方使用生成的密钥发送信息，双方进行身份认证和对整个主模式交换内容的认证。</p></blockquote><p><strong>第二阶段</strong>的<code>IPSEC SA</code>协商:</p><p>上图中的 8、9、10 号包使用快速模式，进行<code>IPSec SA</code>的协商。</p><p>最后的 <code>11、12、13、14</code>号数据包为断开连接。</p><p><strong>(2) <code>ESP</code>协议</strong></p><p><img src="/2019/07/02/IPSec-VPN搭建及协议解析/esp.png" alt=""></p><p>因为 <code>IPSec</code>协议要求通信双方建立单工的安全联盟，所以两个<code>SPI</code> 分别标识了两个方向的通信报文。</p><h4 id="四、IPSec穿越NAT"><a href="#四、IPSec穿越NAT" class="headerlink" title="四、IPSec穿越NAT"></a>四、IPSec穿越NAT</h4><p><strong><code>IPSec VPN</code>中标准身份标识是<code>IP</code>地址，<code>NAT</code>处理过程中会改变<code>IP</code>地址，因此<code>IPSec</code>的身份确认机制必须能够适应<code>IP</code>地址变化。</strong><code>IPSec</code>的身份确认最常见是通过<code>IKE</code>协议代劳，<code>IKE</code>支持的身份认证机制有两种:</p><ul><li><p>数字证书方式，通过CA数字证书体系确认身份，是最为安全、可靠的方式。</p></li><li><p>身份标识+预共享密钥方式，通过发起方和响应方预先配置相同的密钥，完成双方对彼此身份的认证，这是最为常见的方式。在预共享秘密钥认证机制中，身份标识则可以分为几类：</p><ul><li><p>指定<code>IP</code>地址，使用<code>IP</code>地址作为身份标识，是<code>IKE</code>的默认方式，响应方只允许指定<code>IP</code>地址发起协商，安全性比较高。</p></li><li><p>指定<code>IP</code>地址范围，这种方式依然使用<code>IP</code>地址作为身份标识，由于发起方必须要指定<code>IP</code>地址，否则无法发起协商，指定<code>IP</code>地址范围是响应方特性，如响应方可以指定<code>2.0.0.0/8</code>范围内的地址都可以发起协商，而不是只允许<code>2.1.1.2</code>发起协商，能够减少配置，但安全性略有下降。</p></li><li><p>什么都不指定，也是使用IP地址作为身份标识，但允许任意IP地址发起协商，只要预共享密钥一致，双方就能够通过身份确认，这种方式虽然不是非常安全，但是可以简化配置，安全性再次下降；</p></li><li><p>指定对端名字，发起方和响应方都预先配置好本端名字，使用该名字作为身份标识，与指定<code>IP</code>地址类似，通过指定对端名字方式，即使双方预共享密钥一致，只要对端名字不合法，立即中断协商，由于名字未与<code>IP</code>地址进行绑定，而且名字在网络中明文传递，故安全性不如指定<code>IP</code>地址方式高，但这种身份标识方式可以穿<code>NAT</code>。</p></li></ul></li></ul><p>具体过程如下：</p><p> 1、开启<code>NAT</code>穿越时，协商第一阶段的前两个消息会发送标识<code>NAT</code>穿越（<code>NAT Traversal</code>，简称<code>NAT-T</code>）能力的<code>Vendor ID</code>载荷。用于检查通信双方是否支持<code>NAT-T</code>。</p><p><img src="/2019/07/02/IPSec-VPN搭建及协议解析/nat1.png" alt=""></p><p>当双方都在各自的消息中包含了该载荷时，才会进行相关的<code>NAT-T</code>协商。</p><p>2、主模式消息3和消息4中发送<code>NAT-D（NAT Discovery）</code>载荷。<code>NAT-D</code>载荷用于探测两个要建立<code>IPSec</code>隧道的网关之间是否存在<code>NAT</code>网关以及<code>NAT</code>网关的位置。</p><p><img src="/2019/07/02/IPSec-VPN搭建及协议解析/nat2.png" alt=""></p><p>通过协商双方向对端发送源和目的的<code>IP</code>地址与端口的<code>Hash</code>值，就可以检测到地址和端口在传输过程中是否发生变化。若果协商双方计算出来的<code>Hash</code>值与它收到的<code>Hash</code>值一样，则表示它们之间没有<code>NAT</code>。否则，则说明传输过程中对<code>IP</code>或端口进行了<code>NAT</code>转换。</p><p>第一个<code>NAT-D</code>载荷为对端<code>IP</code>和端口的<code>Hash</code>值，第二个<code>NAT-D载</code>荷为本端<code>IP</code>和端口的<code>Hash</code>值。</p><p>3、发现<code>NAT</code>网关后，后续<code>ISAKMP</code>消息的端口号转换为<strong>4500</strong>。<code>ISAKMP</code>报文标识了<code>“Non-ESP Marker”</code>。</p><p><img src="/2019/07/02/IPSec-VPN搭建及协议解析/nat3.png" alt=""></p><p>4、在第二阶段会启用<code>NAT</code>穿越协商。在<code>IKE</code>中增加了两种<code>IPSec</code>报文封装模式：<code>UDP</code>封装隧道模式报文（<code>UDP-Encapsulated-Tunnel</code>）和<code>UDP</code>封装传输模式报文（<code>UDP-Encapsulated-Transport</code>）。<strong>通过为<code>ESP</code>报文封装<code>UDP</code>头</strong>，当封装后的报文通过<code>NAT</code>设备时，<code>NAT</code>设备对该报文的外层<code>IP</code>头和增加的<code>UDP</code>头进行地址和端口号转换。<code>UDP</code>报文端口号修改为<code>4500</code>。</p><p><img src="/2019/07/02/IPSec-VPN搭建及协议解析/nat4.png" alt=""></p><h4 id="五、IPSec协议流量特征分析"><a href="#五、IPSec协议流量特征分析" class="headerlink" title="五、IPSec协议流量特征分析"></a>五、<code>IPSec</code>协议流量特征分析</h4><p><img src="/2019/07/02/IPSec-VPN搭建及协议解析/feature.jpg" alt=""></p><p>在上图 4.14 (a) 中，<code>IPSec</code>流量与原始流量几乎完全重合，这符合<code>ESP</code>协议的特性，即一一对应，一条<code>ESP</code>报文封装一条原始报文，然后进行转发。折线的重合说明<code>IPSec</code>不会对原始流量进行分片等操作，且自身不会产生大量与传输内容无关的流量，它在得到一条原始报文后，仅对其进行加密并加上<code>IPSec</code>头部，然后忠实地发送到目的地。</p><p>在上图 4.14 (b) 中，<code>IPSec</code>流量与原始流量基本重合，但是<code>IPSec</code>流量的字节数到达速率在每个峰值处均比原始流量高。这说明<code>IPSec</code>每条报文的大小都要大于原始报文，这符合<code>IPSec</code>协议的封装特征。加密与完整性保护会产生额外的数据开销，同时无论在隧道模式还是传输模式下，<code>IPSec</code>协议都会对报文进行重新封装，再加上额外的头部，使得讲<code>IPSec</code>处理后的报文数据量大于原始报文。</p><p>在上图 4.15 (a) 中，不论是<code>IPSec</code>流量还是原始流量，其报文大小分布都是<code>U</code>形，即报文大小多集中在<code>0--200</code>字节与<code>1400--1500</code>字节之间，尤其是<code>1400--1500</code>的部分，而<code>200--1400</code>字节的报文数量明显较少。<code>U</code>形分布原因有以下几点：1、有大量数据正在传输；2、网络状况理想，<code>TCP</code>链路极少堵塞，可以持续以较大的发送窗口传输数据；3、左边部分为大量的<code>ACK</code>报文与相关协议的控制报文，以及数据量较小的报文。然后再对比<code>IPSec</code>流量与原始流量，可以观察到其报文大小分布模式及其相似，原始流量相较<code>IPSec</code>流量整体左偏，说明原始流量的报文教<code>IPSec</code>流量较小，这和折线图的结论一致。</p><p>在上图 4.15 (b) 中，可以看到横坐标的报文到达时间间隔范围较大。这与流量采集的方法与环境相关，偶发性的网络阻塞，可能瞬间将报文到达时间间隔提升到千毫秒级。当然，还有很多原因会导致报文到达时间间隔发生异常，因此，报文到达时间间隔时间是一种很不稳定的特征。从图中还可以看到，大部分的到达间隔时间极小，且<code>IPSec</code>流量和原始流量的到达间隔时间分布及其相似。</p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;一、IPSec协议简介&quot;&gt;&lt;a href=&quot;#一、IPSec协议简介&quot; class=&quot;headerlink&quot; title=&quot;一、IPSec协议简介&quot;&gt;&lt;/a&gt;一、IPSec协议简介&lt;/h4&gt;&lt;p&gt;&lt;code&gt;IPSec&lt;/code&gt;是&lt;code&gt;IETF&lt;/code&gt;制定的为保证在&lt;code&gt;Internet&lt;/code&gt;上传送数据的安全保密性能的三层隧道加密协议。&lt;code&gt;IPSec&lt;/code&gt;是应用于&lt;code&gt;IP&lt;/code&gt;层上网络数据安全的一整套体系结构，他包括&lt;strong&gt;报文首部认证协议&lt;/strong&gt;&lt;code&gt;（ Authentication Header, AH）&lt;/code&gt;、&lt;strong&gt;封装安全载荷协议&lt;/strong&gt;&lt;code&gt;(Encapsulating Security Payload, ESP)&lt;/code&gt;、&lt;strong&gt;互联网间密钥交换协议&lt;/strong&gt;&lt;code&gt;(Internet Key Exchange, IKE)&lt;/code&gt; 和一些用于网络认证及加密的算法等。&lt;code&gt;IPSec&lt;/code&gt;协议本身定义了如何在&lt;code&gt;IP&lt;/code&gt;数据包中增加字段来保证&lt;code&gt;IP&lt;/code&gt;包的完整性、私有性和真实性，以及如何加密数据包。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;IPSec&lt;/code&gt;有传输&lt;code&gt;(transport)&lt;/code&gt;和隧道&lt;code&gt;(tunnel)&lt;/code&gt;两种工作方式，其中，传输模式适用于主机之间建立&lt;code&gt;IPSec&lt;/code&gt;安全传输，隧道模式更适合网关之间的通信，常用来实现虚拟专用网&lt;code&gt;VPN&lt;/code&gt;。&lt;/p&gt;
&lt;h4 id=&quot;二、IPSec-VPN搭建&quot;&gt;&lt;a href=&quot;#二、IPSec-VPN搭建&quot; class=&quot;headerlink&quot; title=&quot;二、IPSec-VPN搭建&quot;&gt;&lt;/a&gt;二、IPSec-VPN搭建&lt;/h4&gt;&lt;p&gt;详细教程请参考：&lt;a href=&quot;https://github.com/hwdsl2/setup-ipsec-vpn/blob/master/README-zh.md&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/hwdsl2/setup-ipsec-vpn/blob/master/README-zh.md&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;以 &lt;code&gt;Ubuntu 16.04&lt;/code&gt;为例，首先执行：&lt;/p&gt;
&lt;figure class=&quot;highlight shell&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;wget https://git.io/vpnsetup -O vpnsetup.sh&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;之后，在&lt;code&gt;vpnsetup.sh&lt;/code&gt;文件中，设置&lt;code&gt;YOUR_IPSEC_PSK, YOUR_USERNAME 和 YOUR_PASSWORD&lt;/code&gt;三个字段，如下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/2019/07/02/IPSec-VPN搭建及协议解析/vpnsetup.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="笔记" scheme="https://wangjibao.com.cn/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="笔记" scheme="https://wangjibao.com.cn/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode41-50</title>
    <link href="https://wangjibao.com.cn/2019/05/09/LeetCode41-50/"/>
    <id>https://wangjibao.com.cn/2019/05/09/LeetCode41-50/</id>
    <published>2019-05-09T06:50:40.000Z</published>
    <updated>2019-08-28T03:39:02.973Z</updated>
    
    <content type="html"><![CDATA[<h2 id="41、缺失的第一个正数"><a href="#41、缺失的第一个正数" class="headerlink" title="41、缺失的第一个正数"></a>41、<a href="https://leetcode-cn.com/problems/first-missing-positive" target="_blank" rel="noopener">缺失的第一个正数</a></h2><p>数组中元素互换，让元素大小与下标相对应。数值小于0或者大于数组长度的元素值，直接略过，之后遍历整个数组，第一次出现数值和下标不相等的位置就是<code>ans</code>，如果全部满足，返回数组长度即可。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">firstMissingPositive</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        nums.push_back(<span class="number">-1</span>);  <span class="comment">// 添加一个无用元素，方便后续操作</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;nums.size(); i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>( nums[i]&lt;<span class="number">0</span> || nums[i]&gt;=nums.size() || nums[nums[i]]==nums[i] )</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            swap(nums[nums[i]], nums[i]);</span><br><span class="line">            i--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;nums.size(); i++)&#123; <span class="comment">// i 从 1 开始，保证正整数</span></span><br><span class="line">            <span class="keyword">if</span>( nums[i]!=i )</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums.size();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="42、接雨水"><a href="#42、接雨水" class="headerlink" title="42、接雨水"></a>42、<a href="https://leetcode-cn.com/problems/trapping-rain-water" target="_blank" rel="noopener">接雨水</a></h2><p>先找到全局最高的那个柱子，然后从两边往最高柱靠近，靠近过程中不断更新当前最高柱，并根据当前最高柱的值来计算当前遍历点能够接雨水的量。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">trap</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; height)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(height.size()==<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> max_index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;height.size(); i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>( height[max_index]&lt;height[i] )</span><br><span class="line">                max_index = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> cur_max = height[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;max_index; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>( height[i]&gt;=cur_max )&#123;</span><br><span class="line">                cur_max = height[i];</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            ans += cur_max - height[i];</span><br><span class="line">        &#125;</span><br><span class="line">        cur_max = height[height.size()<span class="number">-1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=height.size()<span class="number">-2</span>; i&gt;max_index; i--)&#123;</span><br><span class="line">            <span class="keyword">if</span>( height[i]&gt;=cur_max )&#123;</span><br><span class="line">                cur_max = height[i];</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            ans += cur_max - height[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="43、字符串相乘"><a href="#43、字符串相乘" class="headerlink" title="43、字符串相乘"></a>43、<a href="https://leetcode-cn.com/problems/multiply-strings" target="_blank" rel="noopener">字符串相乘</a></h2><p>模拟题，使用字符串模拟乘法运算即可。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">multiply</span><span class="params">(<span class="built_in">string</span> num1, <span class="built_in">string</span> num2)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">string</span> ans, cur_multi;</span><br><span class="line">        <span class="keyword">int</span> multiplier, product_step;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=num2.size()<span class="number">-1</span>; i&gt;=<span class="number">0</span>; i--)&#123;</span><br><span class="line">            cur_multi = num1;</span><br><span class="line">            multiplier = num2[i] - <span class="string">'0'</span>;</span><br><span class="line">            product_step = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=cur_multi.size()<span class="number">-1</span>; j&gt;=<span class="number">0</span>; j--)&#123;</span><br><span class="line">                product_step += (cur_multi[j]-<span class="string">'0'</span>)*multiplier;</span><br><span class="line">                cur_multi[j] = product_step%<span class="number">10</span> + <span class="string">'0'</span>;</span><br><span class="line">                product_step /= <span class="number">10</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(product_step)</span><br><span class="line">                cur_multi.insert(cur_multi.begin(), product_step+<span class="string">'0'</span>);</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;num2.size()<span class="number">-1</span>-i; j++)</span><br><span class="line">                cur_multi += <span class="string">"0"</span>;</span><br><span class="line">            <span class="comment">// 计算 cur_multi + ans</span></span><br><span class="line">            <span class="keyword">int</span> m=<span class="number">0</span>, n=<span class="number">0</span>, sum=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(m=ans.size()<span class="number">-1</span>, n=cur_multi.size()<span class="number">-1</span>; m&gt;=<span class="number">0</span>&amp;&amp;n&gt;=<span class="number">0</span>; m--,n--)&#123;</span><br><span class="line">                sum += (ans[m]-<span class="string">'0'</span>) + (cur_multi[n]-<span class="string">'0'</span>);</span><br><span class="line">                ans[m] = sum%<span class="number">10</span> + <span class="string">'0'</span>;</span><br><span class="line">                sum /= <span class="number">10</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span>(m&gt;=<span class="number">0</span>)&#123;</span><br><span class="line">                sum += (ans[m]-<span class="string">'0'</span>);</span><br><span class="line">                ans[m] = sum%<span class="number">10</span> + <span class="string">'0'</span>;</span><br><span class="line">                sum /= <span class="number">10</span>;</span><br><span class="line">                m--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span>(n&gt;=<span class="number">0</span>)&#123;</span><br><span class="line">                sum += (cur_multi[n]-<span class="string">'0'</span>);</span><br><span class="line">                ans.insert(ans.begin(), sum%<span class="number">10</span>+<span class="string">'0'</span>);</span><br><span class="line">                sum /= <span class="number">10</span>;</span><br><span class="line">                n--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(sum)</span><br><span class="line">                ans.insert(ans.begin(), sum+<span class="string">'0'</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(ans.size()&gt;<span class="number">0</span> &amp;&amp; ans[<span class="number">0</span>]==<span class="string">'0'</span>)  <span class="comment">//过滤前导 0 </span></span><br><span class="line">            ans.erase(ans.begin());</span><br><span class="line">        <span class="keyword">return</span> ans.size()==<span class="number">0</span>? <span class="string">"0"</span> : ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="44、通配符匹配"><a href="#44、通配符匹配" class="headerlink" title="44、通配符匹配"></a>44、<a href="https://leetcode-cn.com/problems/wildcard-matching/" target="_blank" rel="noopener">通配符匹配</a></h2><p><code>dp</code> 题，写出状态转移方程即可。根据 <code>*</code> 号考虑各种情况。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isMatch</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">string</span> p)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> lenS = s.length(), lenP = p.length();</span><br><span class="line">        <span class="keyword">bool</span> match[lenS+<span class="number">1</span>][lenP+<span class="number">1</span>] = &#123;<span class="literal">true</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=lenS; i++)</span><br><span class="line">            match[i][<span class="number">0</span>] = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=lenP; i++)</span><br><span class="line">            match[<span class="number">0</span>][i] = p[i<span class="number">-1</span>]==<span class="string">'*'</span> &amp;&amp; match[<span class="number">0</span>][i<span class="number">-1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=lenS; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>; j&lt;=lenP; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>( p[j<span class="number">-1</span>]==<span class="string">'*'</span> )</span><br><span class="line">                    match[i][j] = match[i][j<span class="number">-1</span>] || match[i<span class="number">-1</span>][j];   <span class="comment">//匹配 0 个或多个</span></span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    match[i][j] = (s[i<span class="number">-1</span>]==p[j<span class="number">-1</span>] || p[j<span class="number">-1</span>]==<span class="string">'?'</span>) &amp;&amp; match[i<span class="number">-1</span>][j<span class="number">-1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> match[lenS][lenP];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="45、跳跃游戏-II"><a href="#45、跳跃游戏-II" class="headerlink" title="45、跳跃游戏 II"></a>45、<a href="https://leetcode-cn.com/problems/jump-game-ii/" target="_blank" rel="noopener">跳跃游戏 II</a></h2><p>贪心题，每次选择下次跳的最远的位置。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">jump</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> pos = <span class="number">0</span>, ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(pos &lt; nums.size()<span class="number">-1</span>)&#123;</span><br><span class="line">            <span class="keyword">int</span> max_step = <span class="number">-1</span>, max_index = <span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=nums[pos]; i++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(pos+i==nums.size()<span class="number">-1</span>)</span><br><span class="line">                    <span class="keyword">return</span> ans+<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span>(max_step &lt;= i+nums[pos+i])&#123;</span><br><span class="line">                    max_step = i + nums[pos+i];</span><br><span class="line">                    max_index = i;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            ans++;</span><br><span class="line">            pos = pos + max_index;</span><br><span class="line">            <span class="comment">//cout &lt;&lt; max_index &lt;&lt; " " &lt;&lt; pos &lt;&lt; endl;</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="46、全排列"><a href="#46、全排列" class="headerlink" title="46、全排列"></a>46、<a href="https://leetcode-cn.com/problems/permutations/" target="_blank" rel="noopener">全排列</a></h2><p>直接上 <code>next_permutation</code> 库函数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; permute(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt; <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; ans;</span><br><span class="line">        sort(nums.begin(), nums.end());</span><br><span class="line">        <span class="keyword">do</span>&#123;</span><br><span class="line">            ans.push_back(nums);</span><br><span class="line">        &#125;<span class="keyword">while</span>(next_permutation(nums.begin(), nums.end()));</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="47、全排列-II"><a href="#47、全排列-II" class="headerlink" title="47、全排列 II"></a>47、<a href="https://leetcode-cn.com/problems/permutations-ii/" target="_blank" rel="noopener">全排列 II</a></h2><p>之所以出现重复是因为相同的元素的排列导致的，<code>DFS</code> 实现全排列并去重。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt; <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; ans;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">DFS</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;&amp; book, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; temp_ans)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.size() == temp_ans.size())&#123;</span><br><span class="line">            ans.push_back(temp_ans);</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;nums.size(); i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(book[i]==<span class="literal">true</span>) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span>(i&gt;<span class="number">0</span> &amp;&amp; nums[i<span class="number">-1</span>]==nums[i] &amp;&amp; book[i<span class="number">-1</span>]==<span class="literal">false</span>) <span class="keyword">continue</span>;</span><br><span class="line">            book[i] = <span class="literal">true</span>;</span><br><span class="line">            temp_ans.push_back(nums[i]);</span><br><span class="line">            DFS(nums, book, temp_ans);</span><br><span class="line">            temp_ans.pop_back();</span><br><span class="line">            book[i] = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; permuteUnique(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        sort(nums.begin(), nums.end());</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; book(nums.size(), <span class="literal">false</span>);</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; temp_ans;</span><br><span class="line">        DFS(nums, book, temp_ans);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="48、旋转图像"><a href="#48、旋转图像" class="headerlink" title="48、旋转图像"></a>48、<a href="https://leetcode-cn.com/problems/rotate-image/" target="_blank" rel="noopener">旋转图像</a></h2><p>模拟题，计算好对应的位置即可。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">rotate</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; matrix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = matrix[<span class="number">0</span>].size();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> row=<span class="number">0</span>; row&lt;len/<span class="number">2</span>; row++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> col=row; col&lt;len<span class="number">-1</span>-row; col++)&#123;</span><br><span class="line">                <span class="keyword">int</span> tmp_val = matrix[row][col];</span><br><span class="line"></span><br><span class="line">                <span class="keyword">int</span> row1 = row, col1 = col;</span><br><span class="line">                matrix[row1][col1] = matrix[len<span class="number">-1</span>-col1][row1];</span><br><span class="line"></span><br><span class="line">                <span class="keyword">int</span> row2 = len<span class="number">-1</span>-col1, col2 = row1;</span><br><span class="line">                matrix[row2][col2] = matrix[len<span class="number">-1</span>-col2][row2];</span><br><span class="line"></span><br><span class="line">                <span class="keyword">int</span> row3 = len<span class="number">-1</span>-col2, col3 = row2;</span><br><span class="line">                matrix[row3][col3] = matrix[len<span class="number">-1</span>-col3][row3];</span><br><span class="line"></span><br><span class="line">                <span class="keyword">int</span> row4 = len<span class="number">-1</span>-col3, col4 = row3;</span><br><span class="line">                matrix[row4][col4] = tmp_val;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="49、字母异位词分组"><a href="#49、字母异位词分组" class="headerlink" title="49、字母异位词分组"></a>49、<a href="https://leetcode-cn.com/problems/group-anagrams/" target="_blank" rel="noopener">字母异位词分组</a></h2><p>水题，直接用 <code>map</code> 或者 <code>sort</code> 后使用 <code>vector</code>都可以。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">compare</span><span class="params">(<span class="built_in">string</span> s1, <span class="built_in">string</span> s2)</span></span>&#123;</span><br><span class="line">        sort(s1.begin(), s1.end());</span><br><span class="line">        sort(s2.begin(), s2.end());</span><br><span class="line">        <span class="keyword">return</span> s1 &lt; s2;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; groupAnagrams(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; strs) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; tmp_ans;</span><br><span class="line">        <span class="built_in">vector</span>&lt; <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; &gt; ans;</span><br><span class="line">        sort(strs.begin(), strs.end(), compare);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> str : strs)&#123;</span><br><span class="line">            <span class="keyword">if</span>(tmp_ans.size()==<span class="number">0</span>)&#123;</span><br><span class="line">                tmp_ans.push_back(str);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">string</span> s1 = tmp_ans.back();</span><br><span class="line">            <span class="built_in">string</span> s2 = str;</span><br><span class="line">            sort(s1.begin(), s1.end());</span><br><span class="line">            sort(s2.begin(), s2.end());</span><br><span class="line">            <span class="keyword">if</span>( s1!=s2 )&#123;</span><br><span class="line">                ans.push_back(tmp_ans);</span><br><span class="line">                tmp_ans.clear();</span><br><span class="line">                tmp_ans.push_back(str);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                tmp_ans.push_back(str);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(tmp_ans.size()&gt;=<span class="number">1</span>)</span><br><span class="line">            ans.push_back(tmp_ans);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="50、Pow-x-n"><a href="#50、Pow-x-n" class="headerlink" title="50、Pow(x, n)"></a>50、<a href="https://leetcode-cn.com/problems/powx-n/" target="_blank" rel="noopener">Pow(x, n)</a></h2><p>快速幂</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">myPow</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> flag = n&gt;=<span class="number">0</span>? <span class="number">1</span> : <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> N = (<span class="keyword">long</span> <span class="keyword">long</span>)(flag)*(<span class="keyword">long</span> <span class="keyword">long</span>)(n);</span><br><span class="line">        <span class="keyword">double</span> ans = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(N)&#123;</span><br><span class="line">            <span class="keyword">if</span>(N%<span class="number">2</span>)</span><br><span class="line">                ans *= x;</span><br><span class="line">            x *= x;</span><br><span class="line">            N /= <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> flag==<span class="number">-1</span>? <span class="number">1.0</span>/ans : ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;41、缺失的第一个正数&quot;&gt;&lt;a href=&quot;#41、缺失的第一个正数&quot; class=&quot;headerlink&quot; title=&quot;41、缺失的第一个正数&quot;&gt;&lt;/a&gt;41、&lt;a href=&quot;https://leetcode-cn.com/problems/first-missing-positive&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;缺失的第一个正数&lt;/a&gt;&lt;/h2&gt;&lt;p&gt;数组中元素互换，让元素大小与下标相对应。数值小于0或者大于数组长度的元素值，直接略过，之后遍历整个数组，第一次出现数值和下标不相等的位置就是&lt;code&gt;ans&lt;/code&gt;，如果全部满足，返回数组长度即可。&lt;/p&gt;
&lt;figure class=&quot;highlight c++&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Solution&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt;:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;firstMissingPositive&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;built_in&quot;&gt;vector&lt;/span&gt;&amp;lt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt;&amp;gt;&amp;amp; nums)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        nums.push_back(&lt;span class=&quot;number&quot;&gt;-1&lt;/span&gt;);  &lt;span class=&quot;comment&quot;&gt;// 添加一个无用元素，方便后续操作&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt;(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; i=&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;; i&amp;lt;nums.size(); i++)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;( nums[i]&amp;lt;&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt; || nums[i]&amp;gt;=nums.size() || nums[nums[i]]==nums[i] )&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &lt;span class=&quot;keyword&quot;&gt;continue&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            swap(nums[nums[i]], nums[i]);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            i--;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt;(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; i=&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;; i&amp;lt;nums.size(); i++)&amp;#123; &lt;span class=&quot;comment&quot;&gt;// i 从 1 开始，保证正整数&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;( nums[i]!=i )&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; i;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; nums.size();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="LeetCode" scheme="https://wangjibao.com.cn/categories/LeetCode/"/>
    
      <category term="LeetCode41-50" scheme="https://wangjibao.com.cn/categories/LeetCode/LeetCode41-50/"/>
    
    
      <category term="LeetCode" scheme="https://wangjibao.com.cn/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode31-40</title>
    <link href="https://wangjibao.com.cn/2019/05/09/LeetCode31-40/"/>
    <id>https://wangjibao.com.cn/2019/05/09/LeetCode31-40/</id>
    <published>2019-05-08T16:19:05.000Z</published>
    <updated>2019-05-09T06:52:38.873Z</updated>
    
    <content type="html"><![CDATA[<h2 id="31、下一个排列"><a href="#31、下一个排列" class="headerlink" title="31、下一个排列"></a>31、<a href="https://leetcode-cn.com/problems/next-permutation" target="_blank" rel="noopener">下一个排列</a></h2><p>偷个懒，直接使用库函数<code>next_permutation</code>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">nextPermutation</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        next_permutation(nums.begin(), nums.end());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="32、最长有效括号"><a href="#32、最长有效括号" class="headerlink" title="32、最长有效括号"></a>32、<a href="https://leetcode-cn.com/problems/longest-valid-parentheses" target="_blank" rel="noopener">最长有效括号</a></h2><p>用栈进行括号匹配消除，在消除过程中记录最大长度值。</p><a id="more"></a><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">longestValidParentheses</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">stack</span>&lt; pair&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt; &gt; st;</span><br><span class="line">        st.push(make_pair(<span class="string">'#'</span>, <span class="number">-1</span>));</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;s.length(); i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>( st.top().first==<span class="string">'('</span> &amp;&amp; s[i]==<span class="string">')'</span> )&#123;</span><br><span class="line">                st.pop();</span><br><span class="line">                ans = max(ans, i-st.top().second);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                st.push(make_pair(s[i], i));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="33、搜索旋转排序数组"><a href="#33、搜索旋转排序数组" class="headerlink" title="33、搜索旋转排序数组"></a>33、<a href="https://leetcode-cn.com/problems/search-in-rotated-sorted-array" target="_blank" rel="noopener">搜索旋转排序数组</a></h2><p>变形的二分搜索，关键点一：判断<code>mid</code>到底位于数组的前半段还是后半段；关键点二：判断下一步的搜索方向。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">search</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>, r = nums.size()<span class="number">-1</span>, mid;</span><br><span class="line">        <span class="keyword">while</span>(l&lt;=r)&#123;</span><br><span class="line">            mid = (l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>( nums[mid] &gt;= nums[l] )&#123;  <span class="comment">//落在左边</span></span><br><span class="line">                <span class="keyword">if</span>( target &gt; nums[mid] )</span><br><span class="line">                    l = mid + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>( target &lt; nums[mid] )&#123;</span><br><span class="line">                    <span class="keyword">if</span>( target&gt;nums[l] )</span><br><span class="line">                        r = mid - <span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span>( target&lt;nums[l] )</span><br><span class="line">                        l = mid + <span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                        <span class="keyword">return</span>  l;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    <span class="keyword">return</span> mid;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>( nums[mid] &lt;= nums[r] )&#123;   <span class="comment">//落在右边</span></span><br><span class="line">                <span class="keyword">if</span>( target &lt; nums[mid] )</span><br><span class="line">                    r = mid - <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>( target &gt; nums[mid] )&#123;</span><br><span class="line">                    <span class="keyword">if</span>( target&lt;nums[r] )</span><br><span class="line">                        l = mid + <span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span>( target&gt;nums[r] )</span><br><span class="line">                        r = mid - <span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                        <span class="keyword">return</span> r;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    <span class="keyword">return</span> mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="34、在排序数组中查找元素的第一个和最后一个位置"><a href="#34、在排序数组中查找元素的第一个和最后一个位置" class="headerlink" title="34、在排序数组中查找元素的第一个和最后一个位置"></a>34、<a href="https://leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array" target="_blank" rel="noopener">在排序数组中查找元素的第一个和最后一个位置</a></h2><p>使用模板库里的二分查找函数，<code>lower_bound</code>查找第一个大于或等于某个元素的位置，<code>upper_bound</code>查找第一个大于某个元素的位置。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; searchRange(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        <span class="keyword">int</span> l = lower_bound(nums.begin(), nums.end(), target) - nums.begin();</span><br><span class="line">        <span class="keyword">int</span> r = upper_bound(nums.begin(), nums.end(), target) - nums.begin();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ans&#123;l,r<span class="number">-1</span>&#125;;</span><br><span class="line">        <span class="keyword">if</span>(l==r)</span><br><span class="line">           ans[<span class="number">0</span>] = ans[<span class="number">1</span>] = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="35、搜索插入位置"><a href="#35、搜索插入位置" class="headerlink" title="35、搜索插入位置"></a>35、<a href="https://leetcode-cn.com/problems/search-insert-position" target="_blank" rel="noopener">搜索插入位置</a></h2><p>同样偷懒使用库提供的二分查找函数<code>lower_bound</code>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">searchInsert</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> lower_bound(nums.begin(), nums.end(), target) - nums.begin();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="36、有效的数独"><a href="#36、有效的数独" class="headerlink" title="36、有效的数独"></a>36、<a href="https://leetcode-cn.com/problems/valid-sudoku" target="_blank" rel="noopener">有效的数独</a></h2><p>搞个<code>book</code>数组记录，然后直接暴力循环判断就行了。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isValidSudoku</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; board)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">bool</span> book_row[<span class="number">9</span>][<span class="number">9</span>], book_col[<span class="number">9</span>][<span class="number">9</span>], book_cell[<span class="number">9</span>][<span class="number">9</span>];</span><br><span class="line">        <span class="built_in">memset</span>(book_row, <span class="number">0</span>, <span class="keyword">sizeof</span>(book_row));</span><br><span class="line">        <span class="built_in">memset</span>(book_col, <span class="number">0</span>, <span class="keyword">sizeof</span>(book_col));</span><br><span class="line">        <span class="built_in">memset</span>(book_cell, <span class="number">0</span>, <span class="keyword">sizeof</span>(book_cell));</span><br><span class="line">        <span class="keyword">int</span> num;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">9</span>; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;<span class="number">9</span>; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(board[i][j]==<span class="string">'.'</span>)</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                num = board[i][j] - <span class="string">'0'</span> - <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span>(book_row[i][num] || book_col[j][num] || book_cell[i/<span class="number">3</span>*<span class="number">3</span>+j/<span class="number">3</span>][num])</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                book_row[i][num] = <span class="literal">true</span>;</span><br><span class="line">                book_col[j][num] = <span class="literal">true</span>;</span><br><span class="line">                book_cell[i/<span class="number">3</span>*<span class="number">3</span>+j/<span class="number">3</span>][num] = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="37、解数独"><a href="#37、解数独" class="headerlink" title="37、解数独"></a>37、<a href="https://leetcode-cn.com/problems/sudoku-solver" target="_blank" rel="noopener">解数独</a></h2><p>深搜入门题，注意期间的剪枝操作。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">bool</span> book_row[<span class="number">9</span>][<span class="number">9</span>];</span><br><span class="line">    <span class="keyword">bool</span> book_col[<span class="number">9</span>][<span class="number">9</span>];</span><br><span class="line">    <span class="keyword">bool</span> book_cell[<span class="number">9</span>][<span class="number">9</span>];</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">mySolve</span><span class="params">(<span class="built_in">vector</span>&lt; <span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt; &gt;&amp; board, <span class="keyword">int</span> position)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>( position==<span class="number">81</span> )</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">int</span> row = position/<span class="number">9</span>;</span><br><span class="line">        <span class="keyword">int</span> col = position%<span class="number">9</span>;</span><br><span class="line">        <span class="keyword">if</span>(board[row][col]!=<span class="string">'.'</span>)</span><br><span class="line">            <span class="keyword">return</span> mySolve(board, position+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">9</span>; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>( !book_row[row][i] &amp;&amp; !book_col[col][i] &amp;&amp; !book_cell[row/<span class="number">3</span>*<span class="number">3</span>+col/<span class="number">3</span>][i] )&#123;</span><br><span class="line">                board[row][col] = <span class="string">'1'</span>+i;</span><br><span class="line">                book_row[row][i] = <span class="literal">true</span>;</span><br><span class="line">                book_col[col][i] = <span class="literal">true</span>;</span><br><span class="line">                book_cell[row/<span class="number">3</span>*<span class="number">3</span>+col/<span class="number">3</span>][i] = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">if</span>(!mySolve(board, position+<span class="number">1</span>))&#123;</span><br><span class="line">                    board[row][col] = <span class="string">'.'</span>;</span><br><span class="line">                    book_row[row][i] = <span class="literal">false</span>;</span><br><span class="line">                    book_col[col][i] = <span class="literal">false</span>;</span><br><span class="line">                    book_cell[row/<span class="number">3</span>*<span class="number">3</span>+col/<span class="number">3</span>][i] = <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;  <span class="comment">//唯一解</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">solveSudoku</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; board)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">9</span>; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;<span class="number">9</span>; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>( board[i][j]!=<span class="string">'.'</span> )&#123;</span><br><span class="line">                    <span class="keyword">int</span> num = board[i][j] - <span class="string">'0'</span> - <span class="number">1</span>;</span><br><span class="line">                    book_row[i][num] = <span class="literal">true</span>;</span><br><span class="line">                    book_col[j][num] = <span class="literal">true</span>;</span><br><span class="line">                    book_cell[i/<span class="number">3</span>*<span class="number">3</span>+j/<span class="number">3</span>][num] = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        mySolve(board, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="38、报数"><a href="#38、报数" class="headerlink" title="38、报数"></a>38、<a href="https://leetcode-cn.com/problems/count-and-say" target="_blank" rel="noopener">报数</a></h2><p>模拟题</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">countAndSay</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">string</span> ans = <span class="string">"1"</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> step=<span class="number">1</span>; step&lt;n; step++)&#123;</span><br><span class="line">            <span class="built_in">string</span> tmp_ans;</span><br><span class="line">            <span class="keyword">int</span> sum = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">char</span> ch = ans[<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;ans.size(); i++)&#123;</span><br><span class="line">                <span class="keyword">if</span>( ch == ans[i] )&#123;</span><br><span class="line">                    sum++;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                tmp_ans += (to_string(sum) + ch);</span><br><span class="line">                ch = ans[i];</span><br><span class="line">                sum = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            tmp_ans += (to_string(sum) + ch);</span><br><span class="line">            ans = tmp_ans;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="39、组合总和"><a href="#39、组合总和" class="headerlink" title="39、组合总和"></a>39、<a href="https://leetcode-cn.com/problems/combination-sum" target="_blank" rel="noopener">组合总和</a></h2><p>深搜入门题，注意期间的剪枝操作。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt; <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; ans;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">DFS</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; candidates, <span class="keyword">int</span> target, <span class="keyword">int</span> position, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; tmp_ans)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(target==<span class="number">0</span>)&#123;</span><br><span class="line">            ans.push_back(tmp_ans);</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=position; i&lt;candidates.size(); i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>( target&gt;=candidates[i] )&#123;  <span class="comment">//一个小剪枝</span></span><br><span class="line">                tmp_ans.push_back(candidates[i]);</span><br><span class="line">                DFS(candidates, target-candidates[i], i, tmp_ans);</span><br><span class="line">                tmp_ans.pop_back();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; combinationSum(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; candidates, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        sort(candidates.begin(), candidates.end());  <span class="comment">// 排序为了后期剪枝用</span></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; tmp_ans;</span><br><span class="line">        DFS(candidates, target, <span class="number">0</span>, tmp_ans);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="40、组合总和-II"><a href="#40、组合总和-II" class="headerlink" title="40、组合总和 II"></a>40、<a href="https://leetcode-cn.com/problems/combination-sum-ii" target="_blank" rel="noopener">组合总和 II</a></h2><p>在<code>39</code>题的基础上稍微改一下即可，一是<code>13</code>行的禁止元素重复使用，二是<code>15</code>行的去重操作。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt; <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; ans;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">DFS</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; candidates, <span class="keyword">int</span> target, <span class="keyword">int</span> position, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; tmp_ans)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(target==<span class="number">0</span>)&#123;</span><br><span class="line">            ans.push_back(tmp_ans);</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=position; i&lt;candidates.size(); i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>( target&gt;=candidates[i] )&#123;  <span class="comment">//一个小剪枝</span></span><br><span class="line">                tmp_ans.push_back(candidates[i]);</span><br><span class="line">                DFS(candidates, target-candidates[i], i+<span class="number">1</span>, tmp_ans);</span><br><span class="line">                tmp_ans.pop_back();</span><br><span class="line">                <span class="keyword">while</span>(i+<span class="number">1</span>&lt;candidates.size() &amp;&amp; candidates[i+<span class="number">1</span>]==candidates[i]) <span class="comment">// 去重操作</span></span><br><span class="line">                    i++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; combinationSum2(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; candidates, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        sort(candidates.begin(), candidates.end());  <span class="comment">// 排序为了后期剪枝用</span></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; tmp_ans;</span><br><span class="line">        ans.clear();</span><br><span class="line">        DFS(candidates, target, <span class="number">0</span>, tmp_ans);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;31、下一个排列&quot;&gt;&lt;a href=&quot;#31、下一个排列&quot; class=&quot;headerlink&quot; title=&quot;31、下一个排列&quot;&gt;&lt;/a&gt;31、&lt;a href=&quot;https://leetcode-cn.com/problems/next-permutation&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;下一个排列&lt;/a&gt;&lt;/h2&gt;&lt;p&gt;偷个懒，直接使用库函数&lt;code&gt;next_permutation&lt;/code&gt;。&lt;/p&gt;
&lt;figure class=&quot;highlight c++&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Solution&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt;:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;nextPermutation&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;built_in&quot;&gt;vector&lt;/span&gt;&amp;lt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt;&amp;gt;&amp;amp; nums)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        next_permutation(nums.begin(), nums.end());&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h2 id=&quot;32、最长有效括号&quot;&gt;&lt;a href=&quot;#32、最长有效括号&quot; class=&quot;headerlink&quot; title=&quot;32、最长有效括号&quot;&gt;&lt;/a&gt;32、&lt;a href=&quot;https://leetcode-cn.com/problems/longest-valid-parentheses&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;最长有效括号&lt;/a&gt;&lt;/h2&gt;&lt;p&gt;用栈进行括号匹配消除，在消除过程中记录最大长度值。&lt;/p&gt;
    
    </summary>
    
      <category term="LeetCode" scheme="https://wangjibao.com.cn/categories/LeetCode/"/>
    
      <category term="LeetCode31-40" scheme="https://wangjibao.com.cn/categories/LeetCode/LeetCode31-40/"/>
    
    
      <category term="LeetCode" scheme="https://wangjibao.com.cn/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>双仓库部署实现博客访问加速</title>
    <link href="https://wangjibao.com.cn/2019/04/22/%E5%8F%8C%E4%BB%93%E5%BA%93%E9%83%A8%E7%BD%B2%E5%AE%9E%E7%8E%B0%E5%8D%9A%E5%AE%A2%E8%AE%BF%E9%97%AE%E5%8A%A0%E9%80%9F/"/>
    <id>https://wangjibao.com.cn/2019/04/22/双仓库部署实现博客访问加速/</id>
    <published>2019-04-21T16:53:40.000Z</published>
    <updated>2019-04-21T18:03:28.139Z</updated>
    
    <content type="html"><![CDATA[<p>博客停更了将近半年的时间，然后近期闲着打算接着写写记录下日常学习过程，其中被同学吐槽，你这访问太慢了啊，页面好大会转不出来，怎么回事小老弟？<code>github pages</code>国内访问的话，速度还是很慢的，想要更好的提升访问速度，得将博客迁移到国内才行，幸运的是，国内的<code>coding.net</code>也提供<code>pages</code>服务。下面，我们主要讲解如何实现个人博客的<strong>双仓库</strong>部署。</p><p>1、注册 <code>coding</code> 账号，创建一个和注册名一样的仓库，部署公钥，此处部署的公钥一定要和<code>github pages</code>上的公钥一致。运行 <code>ssh -T git@git.coding.net</code> 指令，测试公钥是否添加成功，如下图所示，代表成功添加了公钥。</p><p><img src="/2019/04/22/双仓库部署实现博客访问加速/public_key.png" alt=""></p><p>2、<code>deploy</code>部署配置，更改本地 根目录下的<code>_config.yml</code>文件，如下图，这样才可以实现两个仓库的同步推送。</p><a id="more"></a><p><img src="/2019/04/22/双仓库部署实现博客访问加速/deploy.png" alt=""></p><p>配置完成后，<code>hexo clean;   hexo g -d</code> 将博客内容同步到两个仓库，在 <code>coding.net</code>中记得同步完成后开启<code>pages 服务</code>，此时便可以访问地址 <code>localdomain.coding.net</code>来浏览博客内容了。</p><p><img src="/2019/04/22/双仓库部署实现博客访问加速/pages.png" alt=""></p><p>3、<code>Pages 服务 &gt;&gt; 设置</code>中，绑定个人域名。我对此步骤的理解是，因为后期要将自己个人域名的<code>CNAME</code>指向这里，所以要绑定一下个人域名来实现验证的效果，如果没有验证的话，任何人买个域名，然后设置<code>CNAME</code>指向这里，就可以通过其他人的域名肆意访问我的资源了，这是不能容忍的。通过绑定机制，属于我的资源我可以控制通过哪些域名可以来访问。</p><p><img src="/2019/04/22/双仓库部署实现博客访问加速/bind_dns.png" alt=""></p><p>4、之前在 阿里云 买的域名， 设置域名解析如图：</p><p><img src="/2019/04/22/双仓库部署实现博客访问加速/dns.png" alt=""></p><p>当在国内访问 <code>www.wangjibao.com.cn</code>时，会解析国内的<code>localdomain.coding.net</code>，这样速度比较快。</p><p>无论在国内还是国外访问<code>wangjibao.com.cn</code>时，会直接返回<code>185.199.111.153</code>的<code>github.io</code>的地址，虽然速度可能有些慢，但这样实现了无论加不加<code>www</code>的头都可以访问博客的目的。</p><p>当在国外访问<code>www.wangjibao.com.cn</code>时，会解析国外的<code>wangjibao.github.io</code>的地址，对外国人来说的话， 速度也不慢。</p><p><img src="/2019/04/22/双仓库部署实现博客访问加速/nslookup.png" alt=""></p><p>5、上图中的 <code>nslookup</code>印证了我们的想法，接下来使用站长之家的<a href="http://tool.chinaz.com/speedtest.aspx" target="_blank" rel="noopener">网站测速</a>功能，查看改造前与改造后的访问速度效果图，如下：</p><p><img src="/2019/04/22/双仓库部署实现博客访问加速/qian.png" alt=""></p><p><img src="/2019/04/22/双仓库部署实现博客访问加速/hou.png" alt=""></p><p>看着就舒坦啊，要想生活过得去，就需要来点绿。穷X一枚，等后期有空看看能不能通过免费的<code>CDN</code>再加速一波。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;博客停更了将近半年的时间，然后近期闲着打算接着写写记录下日常学习过程，其中被同学吐槽，你这访问太慢了啊，页面好大会转不出来，怎么回事小老弟？&lt;code&gt;github pages&lt;/code&gt;国内访问的话，速度还是很慢的，想要更好的提升访问速度，得将博客迁移到国内才行，幸运的是，国内的&lt;code&gt;coding.net&lt;/code&gt;也提供&lt;code&gt;pages&lt;/code&gt;服务。下面，我们主要讲解如何实现个人博客的&lt;strong&gt;双仓库&lt;/strong&gt;部署。&lt;/p&gt;
&lt;p&gt;1、注册 &lt;code&gt;coding&lt;/code&gt; 账号，创建一个和注册名一样的仓库，部署公钥，此处部署的公钥一定要和&lt;code&gt;github pages&lt;/code&gt;上的公钥一致。运行 &lt;code&gt;ssh -T git@git.coding.net&lt;/code&gt; 指令，测试公钥是否添加成功，如下图所示，代表成功添加了公钥。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/2019/04/22/双仓库部署实现博客访问加速/public_key.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;2、&lt;code&gt;deploy&lt;/code&gt;部署配置，更改本地 根目录下的&lt;code&gt;_config.yml&lt;/code&gt;文件，如下图，这样才可以实现两个仓库的同步推送。&lt;/p&gt;
    
    </summary>
    
      <category term="笔记" scheme="https://wangjibao.com.cn/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="笔记" scheme="https://wangjibao.com.cn/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>Ubuntu个性美化</title>
    <link href="https://wangjibao.com.cn/2019/04/20/Ubuntu%E4%B8%AA%E6%80%A7%E7%BE%8E%E5%8C%96/"/>
    <id>https://wangjibao.com.cn/2019/04/20/Ubuntu个性美化/</id>
    <published>2019-04-20T08:26:33.000Z</published>
    <updated>2019-04-20T08:40:49.852Z</updated>
    
    <content type="html"><![CDATA[<p>1、<strong>安装<code>VMware Tools</code></strong></p><p>在<code>VMware</code>中安装虚拟机后，记得安装<code>VMware Tools</code>。在虚拟机中找到名为<code>VMwareTools…tar.gz</code>的压缩包（一般在<code>media</code>文件夹中），复制到某个文件夹中后执行：<code>tar -xvzf VMwareTools…tar.gz</code>进行解压。之后会看到一个 <code>./vmware-install.pl</code>的执行程序，执行后安装，一路默认即可，安装完成后，重启虚拟机。</p><p>2、<strong>卸载自带软件</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dpkg --list   # 查看自带已安装程序</span><br><span class="line">sudo apt-get --purge remove &lt;programname&gt;      # 卸载程序和所有配置文件</span><br><span class="line">sudo apt-get remove &lt;programname&gt;              # 只卸载程序</span><br></pre></td></tr></table></figure><p>当然也可以在<code>软件管理</code>中进行查看已安装软件，卸载软件等操作。</p><p>3、<strong><code>GTK</code>,<code>GTK+</code>,<code>Qt</code>, <code>KDE</code>,<code>GNOME</code>, <code>Unity</code>的区别与联系</strong></p><a id="more"></a><p>Linux本身没有图形界面，Linux现在的图形界面系统只是Linux下的应用程序。</p><p><code>GTK</code>,  <code>GTK+</code>, <code>Qt</code>是图形界面开发库(GUI Toolkit)，用户可以使用这些开发库编写GUI应用。</p><p><code>KDE</code>，<code>GNOME</code>，<code>Unity</code>是<code>linux</code>下的桌面环境(Desktop Environment)，其中<code>KDE</code>使用<code>Qt</code>开发，<code>GNOME</code>使用<code>GTK+</code>开发，<code>Unity</code>是基于<code>GNOME</code>开发的一个桌面环境。</p><p>从 <code>Ubuntu 16.04 LTS</code> 到<code>Ubuntu 18.04 LTS</code> 最显著的变化是 Unity 用户界面被替换为了GNOME 桌面环境。</p><p>4、<strong>安装美化主题</strong></p><p><a href="https://www.cnblogs.com/feipeng8848/p/8970556.html" target="_blank" rel="noopener">参考博客</a>，本文用到的主题工具包<a href="/download/Ubuntu美化.rar">下载</a></p><p>美化过程中涉及的两个目录：<code>/usr/share/themes</code> 和 <code>/usr/share/icons</code>。</p><p>1）安装 <code>TweakTool</code> 工具：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install gnome-tweak-tool</span><br><span class="line">sudo apt-get install gnome-shell-extensions   # 解决Tweaks中shell无法设置的问题</span><br></pre></td></tr></table></figure><p>2）安装<code>GTK</code>主题，修改图标，更改桌面<code>shell</code>，<a href="https://www.opendesktop.org/" target="_blank" rel="noopener">下载网址</a>，将主题和桌面shell放到<code>/usr/share/themes/</code>目录下，图标包放到<code>/usr/share/icons/</code>文件夹下，之后在<code>Tweaks</code>工具中，即可选择使用它们</p><p><img src="/2019/04/20/Ubuntu个性美化/tweaks.png" alt=""></p><p>效果图如下：</p><p><img src="/2019/04/20/Ubuntu个性美化/macos.png" alt=""></p><p>3）更改开机动画，<a href="https://www.gnome-look.org/" target="_blank" rel="noopener">下载网址</a></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">将下载的开机动画解压并拷贝到： usr/share/plymouth/themes</span><br><span class="line">sudo update-alternatives --install /usr/share/plymouth/themes/default.plymouth default.plymouth /usr/share/plymouth/themes/***/***.plymouth 100</span><br><span class="line">sudo update-alternatives --config default.plymouth  # 选择对应序号即可，*号代表当前使用</span><br><span class="line">sudo update-initramfs -u</span><br></pre></td></tr></table></figure><p>4）更改<a href="https://github.com/taeven/Ocean-blue-GDM3" target="_blank" rel="noopener">登录界面的背景</a>（也可只修改<code>css</code>文件中对应的图片链接即可）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">cp 下载的登录界面.jpg /usr/share/backgrounds/</span><br><span class="line"><span class="meta">#</span> 备份自带登录css文件</span><br><span class="line">cp /usr/share/gnome-shell/theme/ubuntu.css /usr/share/gnome-shell/theme/ubuntu.css.bak</span><br><span class="line">cp 下载的并更名为ubuntu.css的文件 /usr/share/gnome-shell/theme/</span><br><span class="line">reboot</span><br></pre></td></tr></table></figure><p>效果图：</p><p><img src="/2019/04/20/Ubuntu个性美化/login.png" alt=""></p><p>4）修改桌面<code>shell</code>的宽度和字体等。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;1、&lt;strong&gt;安装&lt;code&gt;VMware Tools&lt;/code&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在&lt;code&gt;VMware&lt;/code&gt;中安装虚拟机后，记得安装&lt;code&gt;VMware Tools&lt;/code&gt;。在虚拟机中找到名为&lt;code&gt;VMwareTools…tar.gz&lt;/code&gt;的压缩包（一般在&lt;code&gt;media&lt;/code&gt;文件夹中），复制到某个文件夹中后执行：&lt;code&gt;tar -xvzf VMwareTools…tar.gz&lt;/code&gt;进行解压。之后会看到一个 &lt;code&gt;./vmware-install.pl&lt;/code&gt;的执行程序，执行后安装，一路默认即可，安装完成后，重启虚拟机。&lt;/p&gt;
&lt;p&gt;2、&lt;strong&gt;卸载自带软件&lt;/strong&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight shell&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;dpkg --list   # 查看自带已安装程序&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;sudo apt-get --purge remove &amp;lt;programname&amp;gt;      # 卸载程序和所有配置文件&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;sudo apt-get remove &amp;lt;programname&amp;gt;              # 只卸载程序&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;当然也可以在&lt;code&gt;软件管理&lt;/code&gt;中进行查看已安装软件，卸载软件等操作。&lt;/p&gt;
&lt;p&gt;3、&lt;strong&gt;&lt;code&gt;GTK&lt;/code&gt;,&lt;code&gt;GTK+&lt;/code&gt;,&lt;code&gt;Qt&lt;/code&gt;, &lt;code&gt;KDE&lt;/code&gt;,&lt;code&gt;GNOME&lt;/code&gt;, &lt;code&gt;Unity&lt;/code&gt;的区别与联系&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="笔记" scheme="https://wangjibao.com.cn/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="笔记" scheme="https://wangjibao.com.cn/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>Ubuntu官方源和PPA源简介</title>
    <link href="https://wangjibao.com.cn/2019/04/20/Ubuntu%E5%AE%98%E6%96%B9%E6%BA%90%E5%92%8CPPA%E6%BA%90%E7%AE%80%E4%BB%8B/"/>
    <id>https://wangjibao.com.cn/2019/04/20/Ubuntu官方源和PPA源简介/</id>
    <published>2019-04-20T08:12:10.000Z</published>
    <updated>2019-04-20T08:25:32.475Z</updated>
    
    <content type="html"><![CDATA[<p>在<code>ubuntu</code>中，软件的安装主要有3种方式：</p><ul><li><p>通过<code>apt</code>包管理工具从官方软件源安装</p></li><li><p>通过<code>deb</code>格式的软件包安装，以安装<code>搜狗输入法</code>为例：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">下载 sogou.deb</span><br><span class="line">sudo dpkg -i sogou.deb       #出现安装不成功，需要依赖</span><br><span class="line">sudo apt-get install -f      #安装依赖</span><br><span class="line">sudo dpkg -i sogou.deb</span><br></pre></td></tr></table></figure></li><li><p>使用软件的源码手动编译安装</p></li></ul><p>下面我们主要介绍第一种安装方式，即<code>apt</code>命令从软件源安装。软件源分为 <code>Ubuntu官方软件源</code> 和 <code>PPA软件源</code> 两种。</p><a id="more"></a><p>1）<code>Ubuntu</code> 官方软件源，其中包含了系统中绝大多数的软件，对应的目录为 <code>/etc/apt/sources.list</code>，如下所示：</p><p><img src="/2019/04/20/Ubuntu官方源和PPA源简介/sources_list.png" alt=""></p><p>一般情况下，我们会将其改成国内的镜像源，因为访问国外的资源太慢了，<a href="https://segmentfault.com/a/1190000000375848" target="_blank" rel="noopener">国内开源镜像站点汇总</a>。</p><p>安装和卸载软件也非常的简单：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install &lt;package-name&gt;    # 安装</span><br><span class="line">sudo apt-get remove &lt;package-name&gt;     # 卸载</span><br></pre></td></tr></table></figure><p>每当通过 <code>install</code> 命令去安装一个软件时，apt 包管理工具就会从系统中的<code>/etc/apt/sources.list</code>文件或<code>/etc/apt/sources.list.d</code>文件夹中去读取软件源的网址信息，查找可以包含该软件的软件源的网址，然后就从这个网址上把指定的软件给下载下来，然后由 apt 包管理工具在本地进行一些解压和安装的其他操作。</p><p>2）<code>PPA(Personal Package Archives)</code>个人软件包集，它出现的原因是：系统自带的源是非常有限的 ，如果通过<code>deb</code>直接安装其他软件的话，得不到更新和维护，所以此时<code>PPA</code>软件源就应运而生。它其实是一个<a href="https://launchpad.net/" target="_blank" rel="noopener">网站</a>，开发者们在上面建立自己的仓库，上传开发的软件供用户安装。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo add-apt-repository ppa:user/ppa-name    # 添加ppa软件源</span><br><span class="line">sudo add-apt-repository --remove ppa:user/ppa-name    # 删除ppa软件源</span><br></pre></td></tr></table></figure><p>当添加完某个<code>ppa</code>软件源后，会在系统的 <code>/etc/apt/sources.list.d</code> 目录下生成对应的源文件：</p><p><img src="/2019/04/20/Ubuntu官方源和PPA源简介/sources_list_d.png" alt=""></p><p>可见，此操作就是在文件里添加了一个和软件源一模一样的东西，以 <code>notepad++</code> 的使用为例：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> 安装</span><br><span class="line">sudo add-apt-repository ppa:notepadqq-team/notepadqq</span><br><span class="line">sudo apt-get update   # 记得此时要更新一下软件源</span><br><span class="line">sudo apt-get install notepadqq</span><br><span class="line"><span class="meta">#</span> 卸载</span><br><span class="line">sudo apt-get remove notepadqq</span><br><span class="line">sudo add-apt-repository --remove ppa:notepadqq-team/notepadqq</span><br></pre></td></tr></table></figure><p>3）上面两个东西，其实要实现的功能是一样的，之所以在系统中存在<code>/etc/apt/sources.list</code>和<code>/etc/apt/sources.list.d</code>两套东西，是系统为了区分官方源与第三方源，毕竟第三方源存在安全问题的可能性比较大。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在&lt;code&gt;ubuntu&lt;/code&gt;中，软件的安装主要有3种方式：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;通过&lt;code&gt;apt&lt;/code&gt;包管理工具从官方软件源安装&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;通过&lt;code&gt;deb&lt;/code&gt;格式的软件包安装，以安装&lt;code&gt;搜狗输入法&lt;/code&gt;为例：&lt;/p&gt;
&lt;figure class=&quot;highlight shell&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;下载 sogou.deb&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;sudo dpkg -i sogou.deb       #出现安装不成功，需要依赖&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;sudo apt-get install -f      #安装依赖&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;sudo dpkg -i sogou.deb&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;使用软件的源码手动编译安装&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;下面我们主要介绍第一种安装方式，即&lt;code&gt;apt&lt;/code&gt;命令从软件源安装。软件源分为 &lt;code&gt;Ubuntu官方软件源&lt;/code&gt; 和 &lt;code&gt;PPA软件源&lt;/code&gt; 两种。&lt;/p&gt;
    
    </summary>
    
      <category term="笔记" scheme="https://wangjibao.com.cn/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="笔记" scheme="https://wangjibao.com.cn/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>HTTP抓包实战</title>
    <link href="https://wangjibao.com.cn/2018/11/13/HTTP%E6%8A%93%E5%8C%85%E5%AE%9E%E6%88%98/"/>
    <id>https://wangjibao.com.cn/2018/11/13/HTTP抓包实战/</id>
    <published>2018-11-13T15:39:06.000Z</published>
    <updated>2018-11-16T16:33:47.860Z</updated>
    
    <content type="html"><![CDATA[<p>开始读《HTTP抓包实战》，在这个作业满天飞的日子里，计划1周读完，本篇博文对其中的部分知识点做一下简单的记录。</p><p>1、HTTP抓包分析使用的工具不再是wireshark（研究TCP/IP协议使用），而是使用 <a href="https://www.telerik.com/fiddler" target="_blank" rel="noopener">fiddler</a>，版本4。其实 fiddler 做HTTP数据包分析的原理就是相当于一个<strong>web代理</strong>，如下图：</p><p><img src="/2018/11/13/HTTP抓包实战/web_proxy.png" alt=""></p><p>fiddler在中间，可以记录所用的HTTP流量。fiddler启动时，会偷偷把 Internet 选项中的代理修改为 ：127.0.0.1,端口： 8888; fiddler在关闭时，会自动在Internet选项中取消代理，这样就不会对其他程序产生影响。如下图：</p><p><img src="/2018/11/13/HTTP抓包实战/127001.png" alt=""></p><a id="more"></a><p>fiddler界面如下图，使用方法请自行百度或google.</p><p><img src="/2018/11/13/HTTP抓包实战/fiddler.png" alt=""></p><p>2、在 <code>fiddler</code>中抓取 <code>https</code> 的流量，需要做如下图配置并安装证书。</p><p><img src="/2018/11/13/HTTP抓包实战/ca.png" alt=""></p><p>像 <code>IE</code>，<code>chrome</code>等浏览器都是使用<code>windows</code>证书库来验证证书，但是<code>firefox</code>浏览器是自己维护一个证书列表，所以需要在<code>firefox</code>中单独安装 <code>fiddler</code>证书。在上图中的<code>action</code>选项中可以下载<code>fiddler</code>的根证书到桌面，<code>firefox &gt;&gt; 工具 &gt;&gt; 选项 &gt;&gt; 隐私与安全 &gt;&gt; 证书 &gt;&gt; 查看证书 &gt;&gt; 证书机构</code>中可以导入证书，这里，<code>fiddler</code>的作者开了个玩笑，证书名叫<code>DO_NOT_TRUST_FiddlerRoot</code>。</p><p>3、在抓包时，我们经常能看到 <code>tunnel to</code>的握手包，这对我们分析数据包没啥作用，可以在<code>fiddler &gt;&gt; rules &gt;&gt; hide connects</code>中设置其隐藏掉。</p><p><img src="/2018/11/13/HTTP抓包实战/tunnelto.png" alt=""></p><p>4、Win+R输入<code>certmgr.msc</code>查看<code>windows</code>证书管理库</p><p><img src="/2018/11/13/HTTP抓包实战/certmgr.png" alt=""></p><p>5、<code>https://www.wangjibao.com.cn/2018/11/13/HTTP%E6%8A%93%E5%8C%85%E5%AE%9E%E6%88%98/#more</code></p><p>上面是个<code>url</code>的例子，<code>https</code>协议，<code>www.wangjibao.com.cn</code>为域名，这里使用的是默认<code>80</code>端口，所以省略端口显示，后面的<code>/2018/11/13/HTTP%E6%8A%93%E5%8C%85%E5%AE%9E%E6%88%98/</code>代表资源的路径，后面的<code>#</code>号代表啥呢，其实这是个 <code>锚点(anchor)</code>，我们知道，当一个页面非常长的时候，我们可以在页面中根据锚点直接定位到我们需要的地方。</p><p>6、HTTP的状态码，200类是成功，300类代表重定向，400类代表客户端错误，500类错误代表服务器错误。</p><p>其中的<code>206(Partial Content)</code>代表的是部分内容，迅雷、HTTP下载工具就是使用<code>206</code>状态码来实现的断点续传。</p><p>当遇到<code>301 或 302</code>的响应时，浏览器会自动根据<code>response</code>中的重定向<code>url</code>重新访问资源地址。如下图（京东之前叫<code>360buy</code>)：</p><p><img src="/2018/11/13/HTTP抓包实战/location.png" alt=""></p><p>先访问<code>www.360buy.com</code>返回<code>301</code>说这个网址已经<code>move permanently</code>了，给了个<code>http://www.jd.com</code>，然后，浏览器就是访问这个网址，但是服务器说<code>302</code>，代表说，这次对了，但是为了安全，去访问另一个网址吧<code>https://www.jd.com</code>吧，接着就会发现，129号中显示了<code>tunnel to</code>，代表开始握手协商了。</p><p>其实，这里<code>301或302</code>还是有区别的，<code>301</code>代表旧<code>url</code>已经永久移除了，搜索引擎会把权重计算到新的<code>url</code>上。但<code>302</code>代表旧<code>url</code>还在，只是临时重定向到新<code>url</code>上，搜索引擎会把权重计算到旧<code>url</code>上。</p><p>7、常用的HTTP请求方法就是 <code>get</code>和<code>post</code>。</p><p><img src="/2018/11/13/HTTP抓包实战/post.png" alt=""></p><p>我们登录国科大的选课网站，在 <code>fildder</code>中，可以清楚的看到，用户名和密码被包含在<code>post</code>请求的<code>body</code>中，发送给了服务器。同样，如果是<code>get</code>请求，包含在<code>url</code>中<code>?</code>后面的字段可以在<code>QueryString</code>中看到对应的<code>Name--Value</code>字段。</p><p>8、可以在<code>fiddler &gt;&gt; tools &gt;&gt; user-agent</code>中修改<code>User-Agent</code>字段的值，如下图，再浏览某些网页时，就变成了对应的显示模式。</p><p><img src="/2018/11/13/HTTP抓包实战/user-agent.png" alt=""></p><p>9、Ajax (<strong>A</strong>synchronous  <strong>J</strong>avascript  <strong>A</strong>nd  <strong>X</strong>ML”: 异步 JavaScript 和 XML）,是一种在无需重新加载整个网页的情况下，能够更新部分网页的技术。</p><p>10、在 <code>Rules &gt;&gt; Automatic Breakpoint &gt;&gt; after/before Response</code>中可以设置拦截<code>HTTP</code>请求。比如，我可以设置拦击HTTP的响应，然后在<code>raw</code>中修改页面的<code>title</code>字段，点击<code>Run to Completion</code>发成修改后的发送。</p><p><img src="/2018/11/13/HTTP抓包实战/breakpoint.png" alt=""></p><p>1号包中的红色代表拦截到了，这时别忘了，<strong>之前设置的全局断点给取消掉</strong>，不然会影响其他请求的发送和接收。效果如下图：</p><p><img src="/2018/11/13/HTTP抓包实战/modifyresponse.png" alt=""></p><p>注意：修改操作必须在<code>raw</code>选项框里。当然，也可以设置局部断点，<code>bpu www.baidu.com</code>设置只拦截百度的请求，取消拦截在页面左下角的命令框中输入<code>bpu</code>即可；<code>bpafter www.baidu.com</code>拦截响应，<code>bpafter</code>取消拦截响应。</p><p>11、浏览器中的缓存</p><p>如下图，浏览器想请求某个资源的时候，先检查本地缓存，如果本地缓存存在这个文件的时候，直接获取该文件的最后修改时间等信息，构造数据包发送请求（内含有<code>If-Modified-Since</code>字段和<code>If-None-Match</code>字段）给服务器，服务器根据这两个值，结合自身的<code>Last-Modified</code>字段和<code>Etag</code>字段来判断需不需要发送数据给浏览器，如果不需要（1、Request中的If-Modified-Since的时间大于或等于Resonse中的Last-Modified的时间；2、ETag值和If-None-Match相匹配，说明hash值不变文档没改变），则服务器发送 <code>304 Response</code>给浏览器，告诉它，直接使用缓存就行了，节省时间加快网页加载速度。</p><p><img src="/2018/11/13/HTTP抓包实战/lastmodify.png" alt=""></p><p>当然，我们也可以 <code>ctrl + F5</code>强制刷新浏览器，告诉服务器，我不使用缓存，请发送最新的数据资源给我。</p><p><img src="/2018/11/13/HTTP抓包实战/nocache.png" alt=""></p><p>其中的<code>pragma</code>是HTTP1.0中使用的，<code>Cache-Control</code>是现在HTTP1.1用的，同时存在这两个字段，完全是为了兼容。</p><p>12、<code>URL</code>只能使用英文字母、数字或者某些标点符号，URL Encode(URL 编码)就是把所有非英文字母、数字字符都替换成百分号（%）后加两位十六进制数。如：</p><p><code>https://www.wangjibao.com.cn/2018/11/13/HTTP抓包实战</code> 编码后变成了如下模式，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://www.wangjibao.com.cn/2018/11/13/HTTP%E6%8A%93%E5%8C%85%E5%AE%9E%E6%88%98/</span><br></pre></td></tr></table></figure><p>13、<code>Fiddler</code>提供了丰富的插件，可以在<a href="https://www.telerik.com/fiddler/add-ons中下载安装使用，如`Java" target="_blank" rel="noopener">https://www.telerik.com/fiddler/add-ons中下载安装使用，如`Java</a> Script Formatter<code>、</code>Gallery<code>、</code>WinDiff`（比较两个session的不同）等等。</p><p>14、 <code>Fiddler</code>中可以在线调试 <code>JavaScript</code>文件，使用的是<code>AutoResponder</code>功能，如下图，其原理就是当命中某个文件时，自动替换成我们设置的文件返回给客户端，就不去服务器索取了。</p><p><img src="/2018/11/13/HTTP抓包实战/js.png" alt=""></p><p>当然，不仅可以替换 <code>JS</code> 文件，还可以替换网页中的图片为本地我们设置的图片。</p><p>15、我们还可以直接编辑<code>Fiddler Script</code>来修改HTTP请求或者响应，并且不中断程序（之前介绍的设置断点的方式，会使得程序中断）。<code>Rules &gt;&gt; Coustomize Rules</code>中，打开<code>Fiddler ScriptEditor</code>来编辑<code>CustomRules.js</code>文件，如图：</p><p><img src="/2018/11/13/HTTP抓包实战/scripteditor.png" alt=""></p><p>16、HTTP的<code>Cookie</code>机制</p><p>因为<code>HTTP</code>协议是无状态的，可以通过<code>Cookie</code>来维持会话。登录 <code>http://piaoweb.sstm.org.cn</code>，可以在<code>fiddler</code>中看到<code>cookie</code>的运行机制，如下图：</p><p><img src="/2018/11/13/HTTP抓包实战/cookie.png" alt=""></p><p>浏览器把<code>Cookie</code>通过HTTP请求中的<code>Header</code>发送给服务器，同时，服务器通过HTTP响应中的<code>Header</code>(Set-Cookie机制)把<code>Cookie</code>发送给浏览器。</p><p>上图中的 <code>HttpOnly</code>字段是说通过<code>JavaScript</code>脚本无法读取到<code>Cookie</code>信息，可以有效防止<code>XSS</code>攻击。</p><p>浏览器根据服务器返回的<code>Set-Cookie</code>设置好本地<code>Cookie</code>以后，浏览器每次请求服务器的资源时，就在<code>Header</code>中将<code>Cookie</code>附加上，这样，服务器就认为浏览器是登录状态。</p><p>17、Cookie劫持攻击</p><p>这里我们使用<code>豆瓣</code>网为例，演示一下<code>Cookie</code>劫持攻击。</p><p>（1）登录<a href="https://www.douban.com/" target="_blank" rel="noopener">豆瓣网</a>，用<code>Fiddler</code>抓取登录过程产生的数据包，可以看到一个如下图中的包，里面含有我们需要的<code>cookie</code>。</p><p><img src="/2018/11/13/HTTP抓包实战/doubanaccount.png" alt=""></p><p>（2）我们打开这个会话的<code>session</code>，可以看到用户的<code>cookie</code>，其中的<code>dbcl2</code>是和用户登录相关的。</p><p><img src="/2018/11/13/HTTP抓包实战/accounts.png" alt=""></p><p>（3）我们在该会话上右键，<code>replay &gt;&gt; Reissue and Edit</code>，将cookie中的此字段删除，然后<code>Run to Completion</code>放行，可以看到此时我们现在是非登录状态，并且跳转到了登录界面，服务器返回<code>302</code>。</p><p><img src="/2018/11/13/HTTP抓包实战/relocation.png" alt=""></p><p>（4）现在我们知道，这个<code>cookie</code>字段就是和用户登录相关的，并且已经劫持到了，那么如何利用它呢？可以利用之前提到的<code>Fiddler Script</code>，编写脚本，每次发送数据包的时候，自动加上这个cookie不就行了，并且这个操作不会有任何中断。</p><p>在 <code>Fiddler Script</code>中的<code>OnBeforeRequest</code>函数中添加如下代码段：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(oSession.uriContains(<span class="string">"douban.com"</span>))&#123;</span><br><span class="line"><span class="keyword">var</span> sCookie = <span class="string">"dbcl2=\"170842457:NW8ZWiZHFUU\""</span>;</span><br><span class="line">oSession.oRequest[<span class="string">"Cookie"</span>] = sCookie;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再次访问豆瓣网，发现自己已经处于登录状态了。</p><p>18、<code>HTTP</code>基本验证</p><p>把<code>用户名+冒号+密码</code>用<code>Base64</code>编码后生成字符串，放在<code>header</code>中的<code>Authorization</code>字段中，发送给服务器。</p><p>19、手机<code>Fiddler</code>抓包</p><p>手机和电脑处于同一局域网中，在<code>fiddler &gt;&gt; Tools &gt;&gt; Options &gt;&gt; Connections</code>中将<code>allow remote computers to connect</code>勾选上，同时在手机的<code>wlan</code>设置中，将其代理设置成电脑，<code>IP</code>为电脑IP，端口为<code>8888</code>；同时，在手机的安全设置中可以安装之前下载的<code>fiddler root</code>根证书，这样，就可以捕获到手机的<code>https</code>数据包了。</p><p>20、<code>Replay</code>菜单的详细说明：</p><p><code>Reissue Requests</code>：重新发送请求，和菜单栏上的<code>Replay</code>按钮是一样的功能。</p><p><code>Reissue Unconditionally</code>：无条件反复发送选中的请求。</p><p><code>Reissue and Edit</code>：把选中的请求以原来的形式重新发送，在每个新的<code>Session</code>中设置断点，在请求发送给服务器之前，可以修改请求。</p><p><code>Reissue and Verify</code>：重新发送请求，检查响应，如果响应和上一个请求一样，就会变成绿色。</p><p><code>Reissue Sequentially</code>：选中多个<code>Session</code>会按顺序一个一个重新发送请求，是单线程模式。</p><p><code>Reissue from Composer</code>：在<code>Composer</code>中编辑该请求。</p><p><code>Revisit in IE</code>：在<code>IE</code>浏览器中用<code>Get</code>方法访问这个请求。</p><p>21、重放攻击，在<code>Fiddler</code>中，可以使用<code>Composer</code>编辑数据包并进行发送。</p><p><img src="/2018/11/13/HTTP抓包实战/composer.png" alt=""></p><p>其实，重放攻击危害很大，比如说，某网站的投票或者点赞功能，当我们抓取到某个点赞的包时，我们可以重复发送这个数据包来进行刷票。再比如说，某些软件的注册，当我们抓取到某个注册请求包的时候，我们进行大量重复发送，对<code>app</code>造成的损失还是很大的。</p><p>解决方案：在<code>HTTP</code>请求中，添加时间戳<code>stamp</code>和数字签名<code>sign</code>。数字签名保证有效性，时间戳保证时效性。</p><p>22、后面的3–4个章节是使用<code>JMeter</code>对网站做自动化测试和压力测试的，在此略过。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;开始读《HTTP抓包实战》，在这个作业满天飞的日子里，计划1周读完，本篇博文对其中的部分知识点做一下简单的记录。&lt;/p&gt;
&lt;p&gt;1、HTTP抓包分析使用的工具不再是wireshark（研究TCP/IP协议使用），而是使用 &lt;a href=&quot;https://www.telerik.com/fiddler&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;fiddler&lt;/a&gt;，版本4。其实 fiddler 做HTTP数据包分析的原理就是相当于一个&lt;strong&gt;web代理&lt;/strong&gt;，如下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/2018/11/13/HTTP抓包实战/web_proxy.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;fiddler在中间，可以记录所用的HTTP流量。fiddler启动时，会偷偷把 Internet 选项中的代理修改为 ：127.0.0.1,端口： 8888; fiddler在关闭时，会自动在Internet选项中取消代理，这样就不会对其他程序产生影响。如下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/2018/11/13/HTTP抓包实战/127001.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="笔记" scheme="https://wangjibao.com.cn/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="笔记" scheme="https://wangjibao.com.cn/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>小知识科普</title>
    <link href="https://wangjibao.com.cn/2018/11/12/%E5%B0%8F%E7%9F%A5%E8%AF%86%E7%A7%91%E6%99%AE/"/>
    <id>https://wangjibao.com.cn/2018/11/12/小知识科普/</id>
    <published>2018-11-12T15:52:28.000Z</published>
    <updated>2018-11-12T16:26:51.535Z</updated>
    
    <content type="html"><![CDATA[<p>本篇博文记录一下平时生活中遇到的小知识，不定期更新。</p><h4 id="1、判断USB接口类型"><a href="#1、判断USB接口类型" class="headerlink" title="1、判断USB接口类型"></a>1、判断USB接口类型</h4><p>晚上同学过来借扩展坞，看了眼USB接口的颜色，问，这是2.0的口吗？很明显，本渣渣耗费 199大洋 采购的东东，怎么能不是 3.0 的口呢。其实凭借USB接口的颜色能够一定程度上判断接口类型，但并不一定准确。</p><p>准确的做法是：看<strong>接口的针脚数</strong> ，<code>USB2.0</code> 的针脚数目是 <strong>4</strong> 个，<code>USB3.0</code> 的针脚数目是 <strong>9</strong> 个。如下图：</p><p><img src="/2018/11/12/小知识科普/usb2.png" alt=""></p><p>上图是本渣18年从青大毕业时，学院发的纪念U盘，4个引脚，USB2.0的接口。为啥发U盘呢，18年在青岛开上合峰会的时候正值毕业季，各种大型活动统统不让搞，往年的毕业歌会也被无情的取消，那么办晚会的钱就拿来每人发个U盘吧，反正大家都是搞计算机的，以后也用得到，话说要发好歹也发个3.0口的u盘呗，吐槽一下。不过，当时每个U盘里都拷了毕业纪念视频，还是挺走心的，这个得表扬一波。</p><a id="more"></a><p>多说一句，<strong>信息安全班</strong>里当时毕业没有毕业聚餐你敢相信！？？其实知道现在想起来，还是耿耿于怀，原因大家也都心知肚明，怎么说，无愧于心就好！</p><p><img src="/2018/11/12/小知识科普/usb3.png" alt=""></p><p>上图是<strong>3.0</strong> 的口，<strong>9</strong>个引脚能看清不，外面 <strong>5</strong> 个，里面 <strong>4</strong> 个。想一下，为啥2.0的东西插到3.0的口也能正常使用，是不就是使用的里面那<strong>4</strong>个引脚，外面那<strong>5</strong>个是闲着的，当插入3.0的东西时，这9个引脚会全部起作用。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本篇博文记录一下平时生活中遇到的小知识，不定期更新。&lt;/p&gt;
&lt;h4 id=&quot;1、判断USB接口类型&quot;&gt;&lt;a href=&quot;#1、判断USB接口类型&quot; class=&quot;headerlink&quot; title=&quot;1、判断USB接口类型&quot;&gt;&lt;/a&gt;1、判断USB接口类型&lt;/h4&gt;&lt;p&gt;晚上同学过来借扩展坞，看了眼USB接口的颜色，问，这是2.0的口吗？很明显，本渣渣耗费 199大洋 采购的东东，怎么能不是 3.0 的口呢。其实凭借USB接口的颜色能够一定程度上判断接口类型，但并不一定准确。&lt;/p&gt;
&lt;p&gt;准确的做法是：看&lt;strong&gt;接口的针脚数&lt;/strong&gt; ，&lt;code&gt;USB2.0&lt;/code&gt; 的针脚数目是 &lt;strong&gt;4&lt;/strong&gt; 个，&lt;code&gt;USB3.0&lt;/code&gt; 的针脚数目是 &lt;strong&gt;9&lt;/strong&gt; 个。如下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/2018/11/12/小知识科普/usb2.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;上图是本渣18年从青大毕业时，学院发的纪念U盘，4个引脚，USB2.0的接口。为啥发U盘呢，18年在青岛开上合峰会的时候正值毕业季，各种大型活动统统不让搞，往年的毕业歌会也被无情的取消，那么办晚会的钱就拿来每人发个U盘吧，反正大家都是搞计算机的，以后也用得到，话说要发好歹也发个3.0口的u盘呗，吐槽一下。不过，当时每个U盘里都拷了毕业纪念视频，还是挺走心的，这个得表扬一波。&lt;/p&gt;
    
    </summary>
    
      <category term="笔记" scheme="https://wangjibao.com.cn/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="笔记" scheme="https://wangjibao.com.cn/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>树莓派搭建智能路由器</title>
    <link href="https://wangjibao.com.cn/2018/11/12/%E6%A0%91%E8%8E%93%E6%B4%BE%E6%90%AD%E5%BB%BA%E6%99%BA%E8%83%BD%E8%B7%AF%E7%94%B1%E5%99%A8/"/>
    <id>https://wangjibao.com.cn/2018/11/12/树莓派搭建智能路由器/</id>
    <published>2018-11-12T15:40:44.000Z</published>
    <updated>2018-11-12T17:14:51.290Z</updated>
    
    <content type="html"><![CDATA[<p>使用树莓派搭建一个小智能路由器，文档为当年做本科毕业设计时写的，单纯的一个环境搭建记录，放出来，喜欢玩的小伙伴说不定可以参考一下。</p><a id="more"></a><div class="row">    <embed src="树莓派搭建智能路由器.pdf" width="100%" height="550" type="application/pdf"></div>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;使用树莓派搭建一个小智能路由器，文档为当年做本科毕业设计时写的，单纯的一个环境搭建记录，放出来，喜欢玩的小伙伴说不定可以参考一下。&lt;/p&gt;
    
    </summary>
    
      <category term="资料" scheme="https://wangjibao.com.cn/categories/%E8%B5%84%E6%96%99/"/>
    
    
      <category term="资料" scheme="https://wangjibao.com.cn/tags/%E8%B5%84%E6%96%99/"/>
    
  </entry>
  
  <entry>
    <title>算法课第三次作业</title>
    <link href="https://wangjibao.com.cn/2018/11/12/%E7%AE%97%E6%B3%95%E8%AF%BE%E7%AC%AC%E4%B8%89%E6%AC%A1%E4%BD%9C%E4%B8%9A/"/>
    <id>https://wangjibao.com.cn/2018/11/12/算法课第三次作业/</id>
    <published>2018-11-12T15:39:55.000Z</published>
    <updated>2018-11-13T17:17:47.819Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1、书面作业"><a href="#1、书面作业" class="headerlink" title="1、书面作业"></a>1、书面作业</h3><p>懒得将 latex 转成 markdown了，直接传个PDF得了。</p><a id="more"></a><div class="row">    <embed src="Algorithm3-Greedy.pdf" width="100%" height="550" type="application/pdf"></div><h3 id="5、Cross-the-river"><a href="#5、Cross-the-river" class="headerlink" title="5、Cross the river"></a>5、<a href="http://theory.ict.ac.cn/grad_oj/contest/4/problem/31" target="_blank" rel="noopener">Cross the river</a></h3><p>贪心的基本思想：最重的人和最轻的人如果不超载重，就一起过河，如何超重，就最重的人自己一条船单独过河。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> n,l;</span><br><span class="line">    <span class="keyword">int</span> weight[<span class="number">50005</span>];</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; l;</span><br><span class="line">    <span class="keyword">for</span>( <span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; i++ )&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>,weight+i);</span><br><span class="line">    &#125;</span><br><span class="line">    sort(weight,weight+n);</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>, left = <span class="number">0</span>, right = n<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span>( left&lt;=right )&#123;</span><br><span class="line">        ans++;</span><br><span class="line">        <span class="keyword">if</span>( weight[right]+weight[left] &lt;= l )&#123;</span><br><span class="line">            left++;</span><br><span class="line">            right--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            right--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6、Assign-banana-to-monkeys"><a href="#6、Assign-banana-to-monkeys" class="headerlink" title="6、Assign banana to monkeys"></a>6、<a href="http://theory.ict.ac.cn/grad_oj/contest/4/problem/32" target="_blank" rel="noopener">Assign banana to monkeys</a></h3><p>贪心的基本思路：先按照位置排序，位于第 i 个位置的猴子就拿第 i 个位置的香蕉就好。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> monkey[<span class="number">5000005</span>];</span><br><span class="line"><span class="keyword">int</span> banana[<span class="number">5000005</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">char</span> ch;</span><br><span class="line">    <span class="keyword">do</span>&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>,monkey+n);</span><br><span class="line">        n++;</span><br><span class="line">    &#125;<span class="keyword">while</span>( (ch=getchar())!=<span class="string">'\n'</span> );</span><br><span class="line">    sort(monkey, monkey+n);</span><br><span class="line"></span><br><span class="line">    n=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">do</span>&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>,banana+n);</span><br><span class="line">        n++;</span><br><span class="line">    &#125;<span class="keyword">while</span>( (ch=getchar())!=<span class="string">'\n'</span> );</span><br><span class="line">    sort( banana, banana+n );</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>( <span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; i++ )&#123;</span><br><span class="line">        ans = max( ans, <span class="built_in">abs</span>(monkey[i] - banana[i]) );</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;1、书面作业&quot;&gt;&lt;a href=&quot;#1、书面作业&quot; class=&quot;headerlink&quot; title=&quot;1、书面作业&quot;&gt;&lt;/a&gt;1、书面作业&lt;/h3&gt;&lt;p&gt;懒得将 latex 转成 markdown了，直接传个PDF得了。&lt;/p&gt;
    
    </summary>
    
      <category term="作业" scheme="https://wangjibao.com.cn/categories/%E4%BD%9C%E4%B8%9A/"/>
    
      <category term="算法课第一次作业" scheme="https://wangjibao.com.cn/categories/%E4%BD%9C%E4%B8%9A/%E7%AE%97%E6%B3%95%E8%AF%BE%E7%AC%AC%E4%B8%80%E6%AC%A1%E4%BD%9C%E4%B8%9A/"/>
    
    
      <category term="作业" scheme="https://wangjibao.com.cn/tags/%E4%BD%9C%E4%B8%9A/"/>
    
  </entry>
  
  <entry>
    <title>wireshark网络分析的艺术</title>
    <link href="https://wangjibao.com.cn/2018/11/07/wireshark%E7%BD%91%E7%BB%9C%E5%88%86%E6%9E%90%E7%9A%84%E8%89%BA%E6%9C%AF/"/>
    <id>https://wangjibao.com.cn/2018/11/07/wireshark网络分析的艺术/</id>
    <published>2018-11-07T08:21:17.000Z</published>
    <updated>2018-11-12T03:38:29.334Z</updated>
    
    <content type="html"><![CDATA[<p>1、Linux服务器在收到 SSH 访问请求时，会先查询该客户端 IP 所对应的 PTR 记录（ IP 反向解析，由 IP 地址 获得对应的DNS，常用在垃圾邮件过滤）。假如经过5秒钟还没有收到回复，就再发一次查询。如果第二次查询还是等了5秒还没回复，就彻底放弃查询。</p><p>解决方式： <code>cat /etc/ssh/sshd_config | grep -i usedns</code> ，如果显示 <code>usedns yes</code> ,将其设置成 <code>no</code>即可。</p><p> 其中 <code>grep</code>是文本处理工具，同 <code>sed</code>、<code>awk</code>被称为文本处理三剑客。<code>-i</code> 代表忽略大小写的区别（ignore)。</p><p>2、启用 <code>TCP SACK</code>（ selective acknowledgement) 功能，在大量丢包时，不需要每个重传包都确认一次。可以在 <code>ack</code> 数据包中，告知对方哪些包我已经收到了，比如说，当前 <code>ack = 100</code> ，包中的 <code>sack 字段等于 107--120</code>，那么可以一次性完成 <code>100--106</code> 号包的重传，节约时间。</p><p>3、延迟确认</p><p>当要发送一个 <code>ack</code> 数据包的时候，因为纯粹的ack数据包只是单纯的确认，不含有其他有用信息。启用延迟确认，当收到一个 <code>seq</code>时，不立即发送 <code>ack</code>，而是稍等一会，当本地有数据要发送时，将信息加在 <code>ack</code>数据包里，就一起带过去了，节省带宽。</p><p>4、数据接收方可以积累一些包才对发送方 <code>ack</code> 一次。</p><p>5、愚笨窗口综合症（silly window syndrome)—“小包问题“</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">纳格（Nagle)算法:</span><br><span class="line">if 有新数据要发送</span><br><span class="line">if 数据量超过 MSS (即一个 TCP 包所能携带的最大数据量，通常为 1500-20tcp头-20ip头)</span><br><span class="line">立即发送</span><br><span class="line">else</span><br><span class="line">if 之前发出去的数据尚未确认</span><br><span class="line">把新数据缓存起来，凑够 MSS 或等确认到达再发送</span><br><span class="line">else</span><br><span class="line">立即发送</span><br><span class="line">end if</span><br><span class="line">end if</span><br><span class="line">end if</span><br></pre></td></tr></table></figure><a id="more"></a><p>6、延迟确认和 nagle 算法不能一起用，容易造成网络延迟大的要命</p><p>7、虽然说是 TCP 的三次握手，四次挥手，但是有时候，四次挥手，并不一定就是4个数据包，有可能是3个，即中间的 2号包的 <code>ACK</code> 和3号包的 <code>FIN</code> 结合在一起，形成一个数据包。</p><p>8、NTLM（ NT LAN Manager）,一种身份认证协议</p><p><img src="/2018/11/07/wireshark网络分析的艺术/NTLM.png" alt=""></p><ul><li>客户端向服务器发送一个 NTLM 协商请求，然后服务器立即回复一个随机字符串作为 challenge。</li><li>客户端收到 challenge 之后，向服务器回复 用户名，以及两个 response(用hash过的用户密码对 challenge加密得到的)</li><li>服务器不知道如何验证真假，所以将 <code>challenge</code> 和 两个<code>response</code> 都转发给 域控<code>Domain Controller</code> ，让域控去帮忙验证真假。</li><li>域控收到后，也用 <code>hash</code>过的用户密码对 <code>challenge</code>进行加密。如果加密结果和 <code>reponse</code>一样，说明密码正确，身份验证通过。</li></ul><p>由于从数据包里就能看到 <code>challenge</code> 和 <code>response</code> ，算法也是固定的，所以并不安全。</p><p>9、Kerberos（安全认证协议）</p><p>认证过程如下图，<code>kerberos</code> 认证是个双向的过程，即<code>client</code>可以验证<code>server</code>，<code>server</code> 也可以认证 <code>client</code>。</p><p><img src="/2018/11/07/wireshark网络分析的艺术/kerberos.png" alt=""></p><p>$\blacksquare$ <strong>相关名词解释</strong></p><ul><li>KDC ( key distributed center ): 整个安全认证过程的票据生成管理服务，包括 AS 和 TGS 服务。</li><li>AS ( authentication service ): 为 client 生成TGT的服务。</li><li>TGS( ticket granting service ): 为 client 生成某个服务器的 ticket。</li><li>TGT ( ticket-granting ticket ): 用于获取 ticket 的票据。  </li></ul><p>$\blacksquare$ <strong>认证过程</strong></p><p>(1) client 向 KDC 中的 AS  发送数据，表明自己的身份，AS对client的身份进行验证，验证通过后返给 client一个 TGT.</p><p>(2) client 拿着这个 TGT，给TGS发送数据，说我想访问某个 server。然后TGS会将会话密钥$K_{client-server}$用 client master key加密后传送给client；与此同时，TGS也会将会话密钥$K_{client-server}$连同client的基本信息打包用server master key加密也发client，并经client转发给server，至此client与KDC的交互完成。</p><p>(3) client用自己的 master key 解密 TGS 传过来的第一个包，解密后获得会话密钥$K_{client-server}$，并用这个密钥加密自己的的信息和时间戳打包后传送给server。</p><p>(4) server会收到两个数据包，一个用会话密钥加密，一个用自己的master key加密，server先用自己的master<br>key解密获取会话密钥和一份关于client的信息，然后server拿到解密后获取到的会话密钥再解开另外一个数据包，获得另一份关于client的信息和时间戳，对比一下这两份数据，一样即可验证通过。</p><p>详细过程请参照：<a href="https://blog.csdn.net/yangyang19920306/article/details/51673460" target="_blank" rel="noopener">https://blog.csdn.net/yangyang19920306/article/details/51673460</a></p><p>10、<code>TCP Fast Retransmission</code> ，当发送方收到3个及以上 <code>[TCP Dup ACK]</code> 时，就立刻重传它。</p><p><code>[TCP window Full]</code> 和 <code>[TCP zerowindow]</code> ，前者表示这个包的发送方暂时没办法再发送数据了（比如说接收方之前告诉我，接收窗口是100，我把100个数据发送过去了，但是都没有收到回复，可能在去的途中，所以为了保险起见，我不能再接着发送了）。后者表示这个包的发送方没办法再接收数据了（告诉对方，我的接收窗口满了，别再发了）。</p><p>11、LSO（ large segment offload）</p><p>传统的网络工作方式是这样的：应用层把产生的数据交给TCP层，TCP层再根据MSS大小进行分段（有CPU负责）,然后再交给网卡。而启用LSO之后，TCP层就可以把大于MSS的数据块直接传给网卡，让网卡来负责分段的工作。其实在数据量较大时，数据分段计算校验和等简单操作也挺浪费CPU资源的。在计算机的网卡，高级设置里可以启用这一功能，如下图：</p><p><img src="/2018/11/07/wireshark网络分析的艺术/lso.png" alt=""></p><p>详细说明：<a href="https://www.cnblogs.com/tcicy/p/8442225.html" target="_blank" rel="noopener">https://www.cnblogs.com/tcicy/p/8442225.html</a></p><p>12、TCP中的拥塞控制机制</p><p><img src="/2018/11/07/wireshark网络分析的艺术/cwnd.png" alt=""></p><p>了解其中的 慢开始、拥塞避免、快重传、快恢复机制。</p><p>详细说明：<a href="https://blog.csdn.net/jtracydy/article/details/52366461" target="_blank" rel="noopener">https://blog.csdn.net/jtracydy/article/details/52366461</a></p><p>13、有一种 拥塞窗口的计算方式： $ cwnd = cwnd + MSS*\frac{n \times MSS}{cwnd} $ .  n 代表当前接收到的 ack 的个数，当每个数据片返回一个 ack的时候，这个算法是没问题的，即 $\frac{n \times MSS}{cwnd} = 1$ , 每次拥塞窗口增大一个，如上图中的“拥塞避免”状态。但是，我们之前说过，并不是每个数据片都会返回一个 ack 的，有可能攒了好几个才 ack 一次，所以，这种计算方法存在问题，解决方法是关掉网卡中的 <code>Large Receive Offload</code>。</p><p>14、前面逼逼了辣么多，真实环境抓几个包说道说道。</p><p><img src="/2018/11/07/wireshark网络分析的艺术/tcppcap.png" alt=""></p><p>就拿上面截图的数据包说事吧，数据包<a href="/download/tcppcap.pcap">下载链接</a></p><center>185.199.109.153 为服务器端，192.168.199.160 为 客户端。</center><p>(1) 通信过程详解</p><p>首先，<strong>1203号</strong>包服务器端发送了seq = 939400，len = 1460。</p><p>紧接着客户端回复 <strong>1204号包</strong>，说我已经收到了 ack = 939400+1460 = 940860号包。</p><p>正常情况下，服务器接着应该发送 seq = 940860的包给客户端，但是，在 <strong>1205号</strong>包中，客户端却收到了 seq = 942320 , len = 1460 的数据包，wireshark显示 [ TCP Previous segment not captured ]，说明前一个包（seq = 940860的数据包）可能丢了。</p><p>既然数据包丢了，客户端就得发送 ack 接着请求，所以，在<strong>1206号</strong>包中，客户端第二次要求服务器端发送 seq = 940860 的数据，wireshark显示 [ TCP Dup ACK 1204#1 ]，代表这是1204号包的再一次请求。</p><p>接着，<strong>1207号</strong>包，客户端收到了 seq = 943780，len = 1460 的数据包（ 942320 + 1460 = 943780） 。</p><p><strong>1208号</strong>包，还没收到 seq = 940860  的数据包，客户端那个气啊，妹的，我再一次重复要求服务器重发 ack = 940860，出现了[ TCP Dup ACK 1204#2 ].</p><p>在<strong>1209号</strong>包中，客户端收到了 seq = 946700 ， len = 1460 的数据包，现在问题比较大了，两个应该收到的数据包却没有收到，分别是 seq = 940860, seq = 945240 (1207中：943780+1460 = 945240）。同样的，wireshark显示 [ TCP Previous segment not captured  ]。</p><p>接着，问题得到了改善，在<strong>1210号</strong>包中，客户端收到了本应该早收到的 seq = 945240, len = 1460 的数据包。wireshark显示 [ TCP Out-Of-Order ]，这也说明了，在真实的网络环境中，数据包并不一定是按序到达的。</p><p>客户端收到了 seq = 945240 ，seq = 946700(945240+1460) 的数据包，应该发送确认，直到此时，那个 seq = 940860 的包还是没给我发来，丫丫的，在<strong>1211号</strong>包 和 <strong>1212号</strong>包中客户端再一次发送 ack = 940860，要求服务器发送 seq = 940860号包给我，wireshark显示[ TCP Dup ACK 1204#3 ]，[TCP Dup ACK 1204#4 ]。</p><p>在下面的<strong>1213</strong> ( seq = 946700+1460 = 948160 )、<strong>1214</strong>、<strong>1215</strong> (seq = 948160+1460 = 949620 )、<strong>1216</strong>、<strong>1217</strong> ( seq = 949620+1460 = 951080 )、<strong>1218</strong>号，6个数据包还是重演之前的画面，客户端收到的是后面的数据包，每收到一个包，就重复确认一次 ack = 940860, 于是出现了图中的 [ TCP Dup ACK 1204#5 ] 、 [ TCP Dup ACK 1204#6 ]、 [ TCP Dup ACK 1204#7 ] 。</p><p>最终，好现象终于出现，<strong>1219号</strong>包，服务器终于发来了盼望已久的 seq = 940860， len = 1460 。一起顺利，所有问题已经解决。由于是乱序到达的，wireshark显示 [ TCP Out-Of-Order ]。</p><p>在 <strong>1220号</strong>包中，客户端发送对 seq = 940860 的确认，因为之前已经接收到了 seq = 951080+1460 = 952540，所以此时就显示的 ack = 952540 。</p><p>接下来，一切正常。</p><p>(2) SACK字段展示</p><p><img src="/2018/11/07/wireshark网络分析的艺术/sackshow.png" alt=""></p><p>拿 1211 号数据包详细说一下之前提到的 <code>SACK</code> 字段。1211数据包是 ack 1209号数据包的吧。有个事实是：我本应该收到 seq = 940860 的，但是，从1205和1207号包中，我收到的是 seq = 942320, seq = 943780 ，所以此时，1211的TCP头部可选字段的 <code>sack : 942320---945240</code> (943780+1460 = 955240)。从1209号数据包中我收到的是 seq = 946700，所以 1211数据包的TCP头部字段记录第二个 <code>sack : 946700---948160</code> (946700+1460 = 948160) 。</p><p>在TCP的头部可选字段记录这个两个字段值，花掉了 20 字节，所以TCP的头部长度变成了 20 + 20 = 40 Bytes.</p><p>同样的，当客户端收到了 1210 号数据包的时候，是不是就把这两个字段中间空缺的那 1460 ( 946700-945240 = 1460 ) 字节给补上了。所以，在 <strong>1212号</strong> ack 数据包中，<code>sack : 942320---948160</code> ,如上图所示。</p><p>那么当之前没收到的 seq = 940860 也收到的时候，这个 sack字段就没啥意义了，直接没有了，如 1220号ack包展示的那样。到此，一切那么的完美。</p><p>sack字段在变化，同样的，ack 数据包的头部长度也在变化，如上图中： 74 &gt;&gt; 66 &gt;&gt; 54。每次 ack 都会 <del>浪费</del> 一定的带宽，所以，出现了下面的收到多个 seq ，客户端才 ack 一次。</p><p>(3) 之前说过，真实的环境中，并不会每个数据包都 ack 一次，如下图，在这里是每收到 2 个数据包才发送一个 ack。</p><p><img src="/2018/11/07/wireshark网络分析的艺术/tcppack.png" alt=""></p><p> 15、TCP在三次握手的时候，客户端与服务器之间会协商 MSS 的大小，防止应用层发送的数据在 IP 层被分片。虽然，分片有时候是不可控的，比如数据包中间经过路由器时，也有可能被路由器分片。</p><p>协商过程如下图：</p><p><img src="/2018/11/07/wireshark网络分析的艺术/MSS.png" alt=""></p><p>客户端说我的 MSS = 1460， 但是服务器说他的 MSS = 1370，所以，在接下来的数据包中，应用层的数据按照 MSS= 1370 的大小来传输。</p><p>16、通过如下命令构造分片的包</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ping &lt;ip&gt; -l 9000 -n 4</span><br></pre></td></tr></table></figure><p>其中的 <code>-l</code> 参数指定发送的 ping 包的大小，9000 Bytes，所以会被分片处理，如下图所示。 <code>-n</code>指定发送的包的个数，还可以使用 <code>-f</code>    参数，指定发送的包不允许分片，即 <code>DF = 1</code>。</p><p><img src="/2018/11/07/wireshark网络分析的艺术/ICMP.png" alt=""></p><p>可以看到，分片数据包的 <code>off</code> 偏移字段，客户端可以根据 <code>ID</code> 字段，识别这是属于哪一个数据的分片包。那么，客户端如何确定什么时候开始重组这些分片的数据包？可以根据分片数据包的 <code>MF</code> 字段，最后一个分片包的 <code>MF = 0</code> ，代表这是最后一个数据包了，后面没有数据了，这时，客户端就可以重组这些分片的数据包了。</p><p>有一种网络的攻击方式： 往客户端持续发送 <code>MF = 1</code> 的数据包，导致客户端一直缓存分片，导致内存耗尽。</p><p>17、TCP中避免拥塞的方式有： 接收端通过<strong>接收窗口</strong>的大小来通知发送端，告知其数据接收能力。同时，发送端</p><p>通过<strong>拥塞控制</strong>算法来动态调整自己的数据发送量。其中：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">当前数据发送量 = min( 接收窗口大小， 拥塞控制值大小 )</span><br></pre></td></tr></table></figure><p>18、因为TCP头中只给接收窗口预留了16个比特（因为当时设计的时候，全世界的带宽都很小）,这就意味着它最大只能表示$2^{16} - 1 = 65535$ 字节，网络发展到今天明显不够用啊。后来，想到了一个解决方案，在TCP三次握手的时候，在可选字段中告知对方一个叫 <code>window scale</code> 的值，对方将这个值当做 2 的指数，算出来的值再作为接收窗口的系数。有了这个系数，就可以把接收窗口扩展好多倍了。</p><p><img src="/2018/11/07/wireshark网络分析的艺术/WS.png" alt=""></p><p>从上图中可以看出，客户端告诉服务器，自己的 Win = 65535,放大倍数为 2 倍；接着服务器告诉客户端，自己的 Win = 13600, 放大倍数为 WS = 128 倍。</p><p>数据包详情如下图：</p><p><img src="/2018/11/07/wireshark网络分析的艺术/windowscale.png" alt=""></p><p>19、思考：一个服务器是如何使用 80 端口同时为多个客户端提供服务的？根据连接建立时创建的<strong>五元组</strong>区分。详细点可以看 <strong>多路 I/O复用 epoll</strong>。</p><p>20、在网络层，也就是IP层头部，有那么几个字段：<code>identification</code>、<code>flags</code>、<code>offset</code> 。因为IP层是无连接的，每产生一个数据报，<code>identification</code>就加 1 ，如果中途的路由器将其分片后，接收端可以根据 <code>flags</code> 中的 <code>MF</code>、<code>DF</code>字段以及<code>片偏移</code>字段，将同一个 <code>identification</code> 的数据报重新组装起来。</p><p>21、一种流量劫持的手段如下图所示：</p><p><img src="/2018/11/07/wireshark网络分析的艺术/dns.png" alt=""></p><p>实线代表真实的流量，虚线代表劫持的流量。实现的原理就是，我假的服务比你真的服务先响应客户端，这样，等到真的数据来的时候，就会被用户无情的丢弃掉了。</p><p>可以通过查看数据包中的 <code>TTL</code> 值，分析流量是否存在被劫持的可能性。</p><p>22、HTTP &gt;&gt; HTTP1.1 &gt;&gt; SPDY &gt;&gt; HTTP2.0     QUIC(基于UDP)</p><p>23、<code>[ TCP zerowindow ]</code> 表示这个包的发送方已经没有办法再<strong>接收</strong>数据了，对应包中显示 <code>win = 0</code> 。</p><p><code>[ TCP window Full ]</code> 表示这个包的发送方暂时没有办法再<strong>发送</strong>数据了，已经把对方声称的接收窗口已经发满了确没收到ack，只能先暂停。<del>计算在途字节数</del></p><p>24、书上午看完了，总得来说，作业没有在刻意的讲述知识点，通过一个个案例，真实的说明网络知识是如何应用到现实生活的，内容比较基础，对初学者来说不错的书！</p><p>屁股后面跟着一堆作业，就这样吧。找个时间，读一下 <code>tshark</code> 的官方文档，感觉功能很强，用得好的话可以省很多事。<a href="https://www.wireshark.org/docs/man-pages/tshark.html" target="_blank" rel="noopener">https://www.wireshark.org/docs/man-pages/tshark.html</a></p><p>之前当当搞活动，加上双十一，买了好多书，下一本：《python黑帽子 黑客与渗透测试编程之道》。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;1、Linux服务器在收到 SSH 访问请求时，会先查询该客户端 IP 所对应的 PTR 记录（ IP 反向解析，由 IP 地址 获得对应的DNS，常用在垃圾邮件过滤）。假如经过5秒钟还没有收到回复，就再发一次查询。如果第二次查询还是等了5秒还没回复，就彻底放弃查询。&lt;/p&gt;
&lt;p&gt;解决方式： &lt;code&gt;cat /etc/ssh/sshd_config | grep -i usedns&lt;/code&gt; ，如果显示 &lt;code&gt;usedns yes&lt;/code&gt; ,将其设置成 &lt;code&gt;no&lt;/code&gt;即可。&lt;/p&gt;
&lt;p&gt; 其中 &lt;code&gt;grep&lt;/code&gt;是文本处理工具，同 &lt;code&gt;sed&lt;/code&gt;、&lt;code&gt;awk&lt;/code&gt;被称为文本处理三剑客。&lt;code&gt;-i&lt;/code&gt; 代表忽略大小写的区别（ignore)。&lt;/p&gt;
&lt;p&gt;2、启用 &lt;code&gt;TCP SACK&lt;/code&gt;（ selective acknowledgement) 功能，在大量丢包时，不需要每个重传包都确认一次。可以在 &lt;code&gt;ack&lt;/code&gt; 数据包中，告知对方哪些包我已经收到了，比如说，当前 &lt;code&gt;ack = 100&lt;/code&gt; ，包中的 &lt;code&gt;sack 字段等于 107--120&lt;/code&gt;，那么可以一次性完成 &lt;code&gt;100--106&lt;/code&gt; 号包的重传，节约时间。&lt;/p&gt;
&lt;p&gt;3、延迟确认&lt;/p&gt;
&lt;p&gt;当要发送一个 &lt;code&gt;ack&lt;/code&gt; 数据包的时候，因为纯粹的ack数据包只是单纯的确认，不含有其他有用信息。启用延迟确认，当收到一个 &lt;code&gt;seq&lt;/code&gt;时，不立即发送 &lt;code&gt;ack&lt;/code&gt;，而是稍等一会，当本地有数据要发送时，将信息加在 &lt;code&gt;ack&lt;/code&gt;数据包里，就一起带过去了，节省带宽。&lt;/p&gt;
&lt;p&gt;4、数据接收方可以积累一些包才对发送方 &lt;code&gt;ack&lt;/code&gt; 一次。&lt;/p&gt;
&lt;p&gt;5、愚笨窗口综合症（silly window syndrome)—“小包问题“&lt;/p&gt;
&lt;figure class=&quot;highlight shell&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;纳格（Nagle)算法:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;if 有新数据要发送&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	if 数据量超过 MSS (即一个 TCP 包所能携带的最大数据量，通常为 1500-20tcp头-20ip头)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		立即发送&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	else&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		if 之前发出去的数据尚未确认&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;			把新数据缓存起来，凑够 MSS 或等确认到达再发送&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		else&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;			立即发送&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		end if&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	end if&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;end if&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="笔记" scheme="https://wangjibao.com.cn/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="笔记" scheme="https://wangjibao.com.cn/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>VSCode配置Latex</title>
    <link href="https://wangjibao.com.cn/2018/11/05/VSCode%E9%85%8D%E7%BD%AELatex/"/>
    <id>https://wangjibao.com.cn/2018/11/05/VSCode配置Latex/</id>
    <published>2018-11-05T01:40:31.000Z</published>
    <updated>2018-11-05T02:44:26.521Z</updated>
    
    <content type="html"><![CDATA[<p>因为CTeX套装自带WinEdt编辑器难用、收费且不能实时编译显示pdf效果，本笔记主要记录如何在VSCode中编辑Tex文件，实现代码自动补全及实时查看文本编辑效果等功能。</p><h4 id="1、软件下载"><a href="#1、软件下载" class="headerlink" title="1、软件下载"></a>1、软件下载</h4><p>CTEX下载地址：<a href="http://www.ctex.org/HomePage，建议下载完整版套装。" target="_blank" rel="noopener">http://www.ctex.org/HomePage，建议下载完整版套装。</a></p><p>VSCode下载地址：<a href="https://code.visualstudio.com/" target="_blank" rel="noopener">https://code.visualstudio.com/</a></p><h4 id="2、软件配置"><a href="#2、软件配置" class="headerlink" title="2、软件配置"></a>2、软件配置</h4><h5 id="在VSCode中安装对应的插件"><a href="#在VSCode中安装对应的插件" class="headerlink" title="在VSCode中安装对应的插件"></a>在VSCode中安装对应的插件</h5><p><img src="/2018/11/05/VSCode配置Latex/plugin.png" alt=""></p><h5 id="更改配置文件"><a href="#更改配置文件" class="headerlink" title="更改配置文件"></a>更改配置文件</h5><p>在<code>file &gt;&gt; preferences &gt;&gt; setting &gt;&gt; User Setting &gt;&gt; Extensions &gt;&gt; LaTex Workshop configuration &gt;&gt; active</code> 中，打开 <code>Edit in setting.json</code> 文件。在文件中添加如下字段：</p><a id="more"></a><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">"latex-workshop.latex.recipes": [&#123;</span><br><span class="line">"name": "xelatex",</span><br><span class="line">"tools": ["xelatex"]</span><br><span class="line">&#125;, &#123;</span><br><span class="line">"name": "latexmk",</span><br><span class="line">"tools": ["latexmk"]</span><br><span class="line">&#125;, &#123;</span><br><span class="line">"name": "pdflatex -&gt; bibtex -&gt; pdflatex*2",</span><br><span class="line">"tools": ["pdflatex", "bibtex", "pdflatex", "pdflatex"]</span><br><span class="line">&#125;],</span><br></pre></td></tr></table></figure><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">"latex-workshop.latex.tools": [&#123;</span><br><span class="line">"name": "latexmk",</span><br><span class="line">"command": "latexmk",</span><br><span class="line">"args": ["-synctex=1", "-interaction=nonstopmode", "-file-line-error", "-pdf", "%DOC%"]</span><br><span class="line">&#125;, &#123;</span><br><span class="line">"name": "xelatex",</span><br><span class="line">"command": "xelatex",</span><br><span class="line">"args": ["-synctex=1", "-interaction=nonstopmode", "-file-line-error", "%DOC%"]</span><br><span class="line">&#125;, &#123;</span><br><span class="line">"name": "pdflatex",</span><br><span class="line">"command": "pdflatex",</span><br><span class="line">"args": ["-synctex=1", "-interaction=nonstopmode", "-file-line-error", "%DOC%"]</span><br><span class="line">&#125;, &#123;</span><br><span class="line">"name": "bibtex",</span><br><span class="line">"command": "bibtex",</span><br><span class="line">"args": ["%DOCFILE%"]</span><br><span class="line">&#125;],</span><br></pre></td></tr></table></figure><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">"latex-workshop.view.pdf.viewer": "tab",</span><br></pre></td></tr></table></figure><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">"latex-workshop.latex.clean.fileTypes": ["*.aux", "*.bbl", "*.blg", "*.idx", "*.ind", "*.lof", "*.lot", "*.out", "*.toc", "*.acn", "*.acr", "*.alg", "*.glg", "*.glo", "*.gls", "*.ist", "*.fls", "*.log", "*.fdb_latexmk"],</span><br></pre></td></tr></table></figure><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">"latex-workshop.latex.clean.enabled": false,</span><br></pre></td></tr></table></figure><p>添加后的效果如下图所示：</p><p><img src="/2018/11/05/VSCode配置Latex/jsoncode.png" alt=""></p><h4 id="3、开启自动保存，实时查看编辑效果"><a href="#3、开启自动保存，实时查看编辑效果" class="headerlink" title="3、开启自动保存，实时查看编辑效果"></a>3、开启自动保存，实时查看编辑效果</h4><p>在 <code>file</code>中将 <code>auto saved</code>勾选上即可。效果如下图：</p><p><img src="/2018/11/05/VSCode配置Latex/show.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;因为CTeX套装自带WinEdt编辑器难用、收费且不能实时编译显示pdf效果，本笔记主要记录如何在VSCode中编辑Tex文件，实现代码自动补全及实时查看文本编辑效果等功能。&lt;/p&gt;
&lt;h4 id=&quot;1、软件下载&quot;&gt;&lt;a href=&quot;#1、软件下载&quot; class=&quot;headerlink&quot; title=&quot;1、软件下载&quot;&gt;&lt;/a&gt;1、软件下载&lt;/h4&gt;&lt;p&gt;CTEX下载地址：&lt;a href=&quot;http://www.ctex.org/HomePage，建议下载完整版套装。&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://www.ctex.org/HomePage，建议下载完整版套装。&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;VSCode下载地址：&lt;a href=&quot;https://code.visualstudio.com/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://code.visualstudio.com/&lt;/a&gt;&lt;/p&gt;
&lt;h4 id=&quot;2、软件配置&quot;&gt;&lt;a href=&quot;#2、软件配置&quot; class=&quot;headerlink&quot; title=&quot;2、软件配置&quot;&gt;&lt;/a&gt;2、软件配置&lt;/h4&gt;&lt;h5 id=&quot;在VSCode中安装对应的插件&quot;&gt;&lt;a href=&quot;#在VSCode中安装对应的插件&quot; class=&quot;headerlink&quot; title=&quot;在VSCode中安装对应的插件&quot;&gt;&lt;/a&gt;在VSCode中安装对应的插件&lt;/h5&gt;&lt;p&gt;&lt;img src=&quot;/2018/11/05/VSCode配置Latex/plugin.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h5 id=&quot;更改配置文件&quot;&gt;&lt;a href=&quot;#更改配置文件&quot; class=&quot;headerlink&quot; title=&quot;更改配置文件&quot;&gt;&lt;/a&gt;更改配置文件&lt;/h5&gt;&lt;p&gt;在&lt;code&gt;file &amp;gt;&amp;gt; preferences &amp;gt;&amp;gt; setting &amp;gt;&amp;gt; User Setting &amp;gt;&amp;gt; Extensions &amp;gt;&amp;gt; LaTex Workshop configuration &amp;gt;&amp;gt; active&lt;/code&gt; 中，打开 &lt;code&gt;Edit in setting.json&lt;/code&gt; 文件。在文件中添加如下字段：&lt;/p&gt;
    
    </summary>
    
      <category term="笔记" scheme="https://wangjibao.com.cn/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="笔记" scheme="https://wangjibao.com.cn/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>数据科学导论作业</title>
    <link href="https://wangjibao.com.cn/2018/11/04/%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E5%AF%BC%E8%AE%BA%E4%BD%9C%E4%B8%9A/"/>
    <id>https://wangjibao.com.cn/2018/11/04/数据科学导论作业/</id>
    <published>2018-11-04T07:56:57.000Z</published>
    <updated>2018-11-19T13:24:18.626Z</updated>
    
    <content type="html"><![CDATA[<p>第一次作业：<a href="/download/数据科学导论第一次作业.rar">点击下载</a></p><p>怎么说，对这门课就是默默告诉自己，习惯就好。默默贴个 github 地址：</p><p><a href="https://github.com/justmarkham/DAT8" target="_blank" rel="noopener">https://github.com/justmarkham/DAT8</a></p><p>第二次作业：<a href="/download/数据科学导论第二次作业.rar">点击下载</a></p><p>同样，还是贴几个<code>github</code>链接地址：</p><p><a href="https://github.com/lamalor/ds100/blob/182feda62685b0988f4b4afb52c85256f4ac7d92/hw6/hw6.ipynb" target="_blank" rel="noopener">https://github.com/lamalor/ds100/blob/182feda62685b0988f4b4afb52c85256f4ac7d92/hw6/hw6.ipynb</a></p><p><a href="https://github.com/Dhanush123/data100/blob/master/hw6/hw6.ipynb" target="_blank" rel="noopener">https://github.com/Dhanush123/data100/blob/master/hw6/hw6.ipynb</a></p><p><a href="https://github.com/iewaij/introDataScience/blob/1eb96b44721ed6cc40761a7e3003f11a5c243cc3/legacy/material/homework/DS100%20SP17/hw5/hw5_solution.ipynb" target="_blank" rel="noopener">https://github.com/iewaij/introDataScience/blob/1eb96b44721ed6cc40761a7e3003f11a5c243cc3/legacy/material/homework/DS100%20SP17/hw5/hw5_solution.ipynb</a></p><p><a href="https://github.com/dovahcrow/ds100/blob/30d629246c87f2fafbf10c155545c30344be23e6/sp17/hw/hw5/hw5_solution.ipynb" target="_blank" rel="noopener">https://github.com/dovahcrow/ds100/blob/30d629246c87f2fafbf10c155545c30344be23e6/sp17/hw/hw5/hw5_solution.ipynb</a></p><h4 id="1、更改juypter默认工作路径"><a href="#1、更改juypter默认工作路径" class="headerlink" title="1、更改juypter默认工作路径"></a>1、更改juypter默认工作路径</h4><p>在 <code>anaconda prompt</code> 中执行命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jupyter notebook --generate-config</span><br></pre></td></tr></table></figure><p>即可查看 <code>jupyter_notebook_config.py</code> 配置文件的位置，打开配置文件 <code>jupyter_notebook_config.py</code>，搜索关键字 <code>notebook_dir</code> ，将值设置为自己想要的工作目录并取消注释即可（注意路径中不能有中文）；</p><p><img src="/2018/11/04/数据科学导论作业/juypter.png" alt=""></p><p>然后右击 <code>jupyter notebook</code> 快捷方式，将属性中的 “目标” 字段的值，去掉末尾的 <code>%USERPROFILE%</code> ，点击 <code>应用</code>，<code>确定</code>即可。</p><a id="more"></a><h4 id="2、jupyter使用anaconda虚拟python环境"><a href="#2、jupyter使用anaconda虚拟python环境" class="headerlink" title="2、jupyter使用anaconda虚拟python环境"></a>2、jupyter使用anaconda虚拟python环境</h4><p>打开 <code>anaconda prompt</code>，激活之前创建的某个python虚拟环境，在<strong>当前虚拟环境</strong>中执行 <code>conda install nb_conda</code>。重启 <code>juypter notebook</code> 服务器即可出现想要的虚拟环境 <code>kernal</code> 。</p><h4 id="3、jupyter两种工作模式及其快捷键"><a href="#3、jupyter两种工作模式及其快捷键" class="headerlink" title="3、jupyter两种工作模式及其快捷键"></a>3、jupyter两种工作模式及其快捷键</h4><ul><li>分为命令模式（边框蓝色) 和 编辑模式(边框绿色)</li><li>命令模式中， <code>M</code> 进入markdown编辑模式， <code>Y</code> 进入代码编辑模式</li></ul><h4 id="4、代码自动补全"><a href="#4、代码自动补全" class="headerlink" title="4、代码自动补全"></a>4、代码自动补全</h4><p>注意，下面的所有操作是在 <code>base</code> 环境中安装的，在其他虚拟环境中安装好像并不起作用。</p><p>安装<strong>nbextensions</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pip install jupyter_contrib_nbextensions</span><br><span class="line">jupyter contrib nbextension install --user</span><br></pre></td></tr></table></figure><p>安装<strong>nbextensions_configurator</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pip install jupyter_nbextensions_configurator</span><br><span class="line">jupyter nbextensions_configurator enable --user</span><br></pre></td></tr></table></figure><p>重启 jupyter，在弹出的主页面里，能看到增加了一个Nbextensions标签页，在这个页面里，勾选Hinterland即启用了代码自动补全。</p><h4 id="5、pandas教程-pan-el-da-ta-s"><a href="#5、pandas教程-pan-el-da-ta-s" class="headerlink" title="5、pandas教程[pan(el)-da(ta)-s]"></a>5、pandas教程[pan(el)-da(ta)-s]</h4><p>1、pandas中的数据分为三种： 一维数据 Series、二维数据 DataFrame、以及三维数据 Panel。</p><ul><li><p>Series相当于一个字典。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">data = np.random.randn(<span class="number">5</span>) <span class="comment"># 一维随机数</span></span><br><span class="line">index = [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>, <span class="string">'d'</span>, <span class="string">'e'</span>] <span class="comment"># 指定索引</span></span><br><span class="line">s = pd.Series(data, index)</span><br></pre></td></tr></table></figure></li><li><p>二维数据，1. 带Series的字典  2.列表构成的字典   3.带字典的列表</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">d = &#123;<span class="string">'one'</span> : pd.Series([<span class="number">1.</span>, <span class="number">2.</span>, <span class="number">3.</span>], index=[<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>]),<span class="string">'two'</span> : pd.Series([<span class="number">1.</span>, <span class="number">2.</span>, <span class="number">3.</span>, <span class="number">4.</span>], index=[<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>, <span class="string">'d'</span>])&#125;  <span class="comment">#one做列</span></span><br><span class="line">d = &#123;<span class="string">'one'</span> : [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>], <span class="string">'two'</span> : [<span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>]&#125;   <span class="comment">#one做列</span></span><br><span class="line">d = [&#123;<span class="string">'a'</span>: <span class="number">1</span>, <span class="string">'b'</span>: <span class="number">2</span>&#125;, &#123;<span class="string">'a'</span>: <span class="number">5</span>, <span class="string">'b'</span>: <span class="number">10</span>, <span class="string">'c'</span>: <span class="number">20</span>&#125;]  <span class="comment">#a,b,c做列</span></span><br><span class="line">df = pd.DataFrame(d)  <span class="comment"># 新建 DataFrame</span></span><br><span class="line">print(df）</span><br></pre></td></tr></table></figure></li></ul><p>列的选择，添加与删除</p><p>​    df[‘列名’]      df.pop(‘列名’)      df.insert(添加列位置索引序号, ‘添加列名’, 数值)</p><p>行的选取，列的选取，块的选取</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">df.index    df.columns   df.values   df.values    df.describes()   df.T    df.dtypes</span><br><span class="line">df.sort_index()    df.sort_values()</span><br><span class="line">df.head()   df.tail()</span><br><span class="line">df[行选取]   df[列名]   df.loc[[行选取],[列选取]]</span><br><span class="line">#df.iloc   df.iat</span><br><span class="line">df.drop(&apos;行名&apos;)</span><br><span class="line">df.append()</span><br><span class="line">df.shape   df.size   df.ndim    </span><br><span class="line">df.sum(axis=1 =0 =default)     df.mean()  df.std()</span><br><span class="line">表明智函数应用：pipe()   #对所有元素起作用</span><br><span class="line">行或列函数应用：apply()  #对行或者列起作用</span><br><span class="line">元素函数应用：applymap() #对某一个元素起作用</span><br></pre></td></tr></table></figure><p>python中使用  <code>type(var)</code> 查看变量的数据类型</p><h4 id="6、juypter显示行号"><a href="#6、juypter显示行号" class="headerlink" title="6、juypter显示行号"></a>6、juypter显示行号</h4><p><code>view &gt;&gt; toggle line numbers</code></p><h4 id="7、juypter中matplotlib画图中文显示乱码"><a href="#7、juypter中matplotlib画图中文显示乱码" class="headerlink" title="7、juypter中matplotlib画图中文显示乱码"></a>7、juypter中matplotlib画图中文显示乱码</h4><p><a href="https://blog.csdn.net/u014465934/article/details/80377470" target="_blank" rel="noopener">https://blog.csdn.net/u014465934/article/details/80377470</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;第一次作业：&lt;a href=&quot;/download/数据科学导论第一次作业.rar&quot;&gt;点击下载&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;怎么说，对这门课就是默默告诉自己，习惯就好。默默贴个 github 地址：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/justmarkham/DAT8&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/justmarkham/DAT8&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;第二次作业：&lt;a href=&quot;/download/数据科学导论第二次作业.rar&quot;&gt;点击下载&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;同样，还是贴几个&lt;code&gt;github&lt;/code&gt;链接地址：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/lamalor/ds100/blob/182feda62685b0988f4b4afb52c85256f4ac7d92/hw6/hw6.ipynb&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/lamalor/ds100/blob/182feda62685b0988f4b4afb52c85256f4ac7d92/hw6/hw6.ipynb&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/Dhanush123/data100/blob/master/hw6/hw6.ipynb&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/Dhanush123/data100/blob/master/hw6/hw6.ipynb&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/iewaij/introDataScience/blob/1eb96b44721ed6cc40761a7e3003f11a5c243cc3/legacy/material/homework/DS100%20SP17/hw5/hw5_solution.ipynb&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/iewaij/introDataScience/blob/1eb96b44721ed6cc40761a7e3003f11a5c243cc3/legacy/material/homework/DS100%20SP17/hw5/hw5_solution.ipynb&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/dovahcrow/ds100/blob/30d629246c87f2fafbf10c155545c30344be23e6/sp17/hw/hw5/hw5_solution.ipynb&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/dovahcrow/ds100/blob/30d629246c87f2fafbf10c155545c30344be23e6/sp17/hw/hw5/hw5_solution.ipynb&lt;/a&gt;&lt;/p&gt;
&lt;h4 id=&quot;1、更改juypter默认工作路径&quot;&gt;&lt;a href=&quot;#1、更改juypter默认工作路径&quot; class=&quot;headerlink&quot; title=&quot;1、更改juypter默认工作路径&quot;&gt;&lt;/a&gt;1、更改juypter默认工作路径&lt;/h4&gt;&lt;p&gt;在 &lt;code&gt;anaconda prompt&lt;/code&gt; 中执行命令：&lt;/p&gt;
&lt;figure class=&quot;highlight shell&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;jupyter notebook --generate-config&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;即可查看 &lt;code&gt;jupyter_notebook_config.py&lt;/code&gt; 配置文件的位置，打开配置文件 &lt;code&gt;jupyter_notebook_config.py&lt;/code&gt;，搜索关键字 &lt;code&gt;notebook_dir&lt;/code&gt; ，将值设置为自己想要的工作目录并取消注释即可（注意路径中不能有中文）；&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/2018/11/04/数据科学导论作业/juypter.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;然后右击 &lt;code&gt;jupyter notebook&lt;/code&gt; 快捷方式，将属性中的 “目标” 字段的值，去掉末尾的 &lt;code&gt;%USERPROFILE%&lt;/code&gt; ，点击 &lt;code&gt;应用&lt;/code&gt;，&lt;code&gt;确定&lt;/code&gt;即可。&lt;/p&gt;
    
    </summary>
    
      <category term="作业" scheme="https://wangjibao.com.cn/categories/%E4%BD%9C%E4%B8%9A/"/>
    
      <category term="数据科学导论大作业" scheme="https://wangjibao.com.cn/categories/%E4%BD%9C%E4%B8%9A/%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E5%AF%BC%E8%AE%BA%E5%A4%A7%E4%BD%9C%E4%B8%9A/"/>
    
    
      <category term="作业" scheme="https://wangjibao.com.cn/tags/%E4%BD%9C%E4%B8%9A/"/>
    
  </entry>
  
  <entry>
    <title>网络数据挖掘作业</title>
    <link href="https://wangjibao.com.cn/2018/10/31/%E7%BD%91%E7%BB%9C%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98%E4%BD%9C%E4%B8%9A/"/>
    <id>https://wangjibao.com.cn/2018/10/31/网络数据挖掘作业/</id>
    <published>2018-10-30T16:53:35.000Z</published>
    <updated>2018-11-04T17:02:33.423Z</updated>
    
    <content type="html"><![CDATA[<p>NMF(非负矩阵分解)，nature论文原文：</p><a id="more"></a><div class="row">    <embed src="1861-algorithms-for-non-negative-matrix-factorization.pdf" width="100%" height="550" type="application/pdf"></div><p>个人理解PPT：</p><div class="row">    <embed src="网络数据挖掘.pdf" width="100%" height="550" type="application/pdf"></div>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;NMF(非负矩阵分解)，nature论文原文：&lt;/p&gt;
    
    </summary>
    
      <category term="作业" scheme="https://wangjibao.com.cn/categories/%E4%BD%9C%E4%B8%9A/"/>
    
      <category term="网络数据挖掘作业" scheme="https://wangjibao.com.cn/categories/%E4%BD%9C%E4%B8%9A/%E7%BD%91%E7%BB%9C%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98%E4%BD%9C%E4%B8%9A/"/>
    
    
      <category term="作业" scheme="https://wangjibao.com.cn/tags/%E4%BD%9C%E4%B8%9A/"/>
    
  </entry>
  
  <entry>
    <title>算法课第二次作业</title>
    <link href="https://wangjibao.com.cn/2018/10/28/%E7%AE%97%E6%B3%95%E8%AF%BE%E7%AC%AC%E4%BA%8C%E6%AC%A1%E4%BD%9C%E4%B8%9A/"/>
    <id>https://wangjibao.com.cn/2018/10/28/算法课第二次作业/</id>
    <published>2018-10-27T16:22:15.000Z</published>
    <updated>2018-11-04T16:58:50.558Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一、Money-robbing"><a href="#一、Money-robbing" class="headerlink" title="一、Money robbing"></a>一、Money robbing</h3><h4 id="1、optimal-substructure-and-DP-equation"><a href="#1、optimal-substructure-and-DP-equation" class="headerlink" title="1、optimal substructure and DP equation"></a>1、optimal substructure and DP equation</h4><p>对于第 i 家，有两种选择，抢或者不抢。如果抢第 i 家，那么最大收益为：value[i] + 抢前 i-2 家的最优收益； 如果第 i 家不抢，那么最大收益为：抢前 i-1 家的最优收益。</p><p>状态转移方程可写为：<br>$$<br>dp[i] = max( dp[i-1], dp[i-2]+value[i] )<br>$$</p><h4 id="2、-pseudo-code"><a href="#2、-pseudo-code" class="headerlink" title="2、 pseudo-code"></a>2、 pseudo-code</h4><p><a href="https://leetcode-cn.com/problems/house-robber/description/" target="_blank" rel="noopener">LeetCode 198题</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">rob</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>( nums.size()==<span class="number">0</span> )</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>( nums.size()==<span class="number">1</span> )</span><br><span class="line">            <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; dp(nums.size(),<span class="number">0</span>);</span><br><span class="line">        dp[<span class="number">0</span>] = nums[<span class="number">0</span>];</span><br><span class="line">        dp[<span class="number">1</span>] = max( nums[<span class="number">0</span>], nums[<span class="number">1</span>] );</span><br><span class="line">        <span class="keyword">for</span>( <span class="keyword">int</span> i=<span class="number">2</span>; i&lt;nums.size(); i++ )&#123;</span><br><span class="line">            dp[i] = max( dp[i<span class="number">-1</span>], dp[i<span class="number">-2</span>]+nums[i] );</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[nums.size()<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><a id="more"></a><h4 id="3、-correctness-of-algorithm"><a href="#3、-correctness-of-algorithm" class="headerlink" title="3、 correctness of algorithm"></a>3、 correctness of algorithm</h4><p>如果暴力求解的话，每一家都有可能抢或者不抢，枚举每一种可能性，那么总的时间复杂度为 $O(2^n)$ ，且最后算出来的最优解一定是正确的。现在，我们采用动态规划思想中的 memory 数组，记录前 i-1 家的最优值，当计算第 i 家最优值时，其依赖的 <code>OPT[i-1]</code> 和 <code>OPT[i-2]</code> 已经求出，可直接计算当前最优值，故算法是正确的。</p><h4 id="4、-complexity-of-algorithm"><a href="#4、-complexity-of-algorithm" class="headerlink" title="4、 complexity of algorithm"></a>4、 complexity of algorithm</h4><p>代码中的 dp 数组，每个元素只计算了一遍，故算法的时间复杂度为 $ O(n) $。</p><p>注：</p><p>当房屋变成一个环的时候，也就是相当于在原有问题上添加了一个限制条件：第<code>1</code>家和第<code>n</code>家不能同时抢。那么，分别计算抢第二家到最后一家与抢第一家到倒数第二家的最大值，取两个值中更大的那个就是结果。</p><p><a href="https://leetcode-cn.com/problems/house-robber-ii/description/" target="_blank" rel="noopener">LeetCode 213题</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">rob</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>( nums.size()==<span class="number">0</span> )</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>( nums.size()==<span class="number">1</span> )</span><br><span class="line">            <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">return</span> max( func(nums, <span class="number">0</span>), func(nums, nums.size()<span class="number">-1</span> ));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">func</span><span class="params">( <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; nums, <span class="keyword">int</span> pos )</span></span>&#123;</span><br><span class="line">        nums.erase(nums.begin()+pos);</span><br><span class="line">        <span class="keyword">if</span>( nums.size()==<span class="number">0</span> )</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>( nums.size()==<span class="number">1</span> )</span><br><span class="line">            <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; dp(nums.size(),<span class="number">0</span>);</span><br><span class="line">        dp[<span class="number">0</span>] = nums[<span class="number">0</span>];</span><br><span class="line">        dp[<span class="number">1</span>] = max( nums[<span class="number">0</span>], nums[<span class="number">1</span>] );</span><br><span class="line">        <span class="keyword">for</span>( <span class="keyword">int</span> i=<span class="number">2</span>; i&lt;nums.size(); i++ )&#123;</span><br><span class="line">            dp[i] = max( dp[i<span class="number">-1</span>], dp[i<span class="number">-2</span>]+nums[i] );</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[nums.size()<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="二、Node-selection"><a href="#二、Node-selection" class="headerlink" title="二、Node selection"></a>二、Node selection</h3><h4 id="1、optimal-substructure-and-DP-equation-1"><a href="#1、optimal-substructure-and-DP-equation-1" class="headerlink" title="1、optimal substructure and DP equation"></a>1、optimal substructure and DP equation</h4><p>对于当前根节点，有两种可能性，选取或者不选取。如果选取了当前的根节点，那么其孩子节点就不能选取，即最优值变为：root-&gt;value + 4个孙子的最优值之和； 如果当前根节点没有选取，最优值变为：两个孩子节点最优值之和。</p><p>给定任意一个根，假设我们能够得到当前根选取与不选取的最优值，结果保存在一个长度为2的数组里，array[0]代表根节点不选取，array[1]代表根节点选取，那么最优解为：</p><p><img src="/2018/10/28/算法课第二次作业/form1.png" alt=""></p><h4 id="2、-pseudo-code-1"><a href="#2、-pseudo-code-1" class="headerlink" title="2、 pseudo-code"></a>2、 pseudo-code</h4><p><a href="https://leetcode-cn.com/problems/house-robber-iii/description/" target="_blank" rel="noopener">LeetCode 337题</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">rob</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ans = solve( root );</span><br><span class="line">        <span class="keyword">return</span> max( ans[<span class="number">0</span>], ans[<span class="number">1</span>] );</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; solve( TreeNode* root )&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ans(<span class="number">2</span>,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span>( !root )</span><br><span class="line">            <span class="keyword">return</span> ans;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; left_ans = solve( root-&gt;left);</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; right_ans = solve( root-&gt;right );</span><br><span class="line">        ans[<span class="number">0</span>] = max( left_ans[<span class="number">0</span>], left_ans[<span class="number">1</span>] ) + max( right_ans[<span class="number">0</span>], right_ans[<span class="number">1</span>] ); <span class="comment">//根节点不选</span></span><br><span class="line">        ans[<span class="number">1</span>] = root-&gt;val + left_ans[<span class="number">0</span>] + right_ans[<span class="number">0</span>]; <span class="comment">//选择根节点</span></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="3、correctness-of-algorithm"><a href="#3、correctness-of-algorithm" class="headerlink" title="3、correctness of algorithm"></a>3、correctness of algorithm</h4><p>当前节点的最优值，依赖于其儿子节点的最优值（当前节点没选，最优值等于选其左孩子节点最优值+选其右孩子节点最优值）或其孙子节点的最优值（选取了当前节点，最优值等于根节点值+其左孩子不选左根的最优值+右孩子不选右根的最优值），由此可知算法的正确性。</p><h4 id="4、complexity-of-algorithm"><a href="#4、complexity-of-algorithm" class="headerlink" title="4、complexity of algorithm"></a>4、complexity of algorithm</h4><p>整个算法相当于一个深度优先搜索（DFS），树中的每个节点都会遍历一次，故算法的时间复杂度为$O(n)$。</p><h3 id="三、Decoding"><a href="#三、Decoding" class="headerlink" title="三、Decoding"></a>三、Decoding</h3><h4 id="1、optimal-substructure-and-DP-equation-2"><a href="#1、optimal-substructure-and-DP-equation-2" class="headerlink" title="1、optimal substructure and DP equation"></a>1、optimal substructure and DP equation</h4><p><code>dp[i]</code>表示从字符<code>0~i</code>的字符串包含最多的编码种数。不考虑特殊情况，该题的递推式是$dp[i]=dp[i-1]+dp[i-2]$，因为一个数字可以表示一个编码，两个数字也有可能表示一个编码，所以<code>dp[i]</code>应该等于<code>0~i-1</code>的字符串包含的最多编码种数加上<code>0~i-2</code>的字符串包含的最多编码种数。但是考虑到一共只有26种基础编码加上特殊情况0，所以递推式可以表示为：</p><p><img src="/2018/10/28/算法课第二次作业/form2.png" alt=""></p><h4 id="2、-pseudo-code-2"><a href="#2、-pseudo-code-2" class="headerlink" title="2、 pseudo-code"></a>2、 pseudo-code</h4><p><a href="https://leetcode-cn.com/problems/decode-ways/description/" target="_blank" rel="noopener">LeetCode 91题</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numDecodings</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>( s.length()==<span class="number">0</span> || s[<span class="number">0</span>]==<span class="string">'0'</span> ) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; dp(s.length()+<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">        dp[<span class="number">0</span>] = dp[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>( <span class="keyword">int</span> i=<span class="number">1</span>; i&lt;s.length(); i++ )&#123;</span><br><span class="line">            <span class="keyword">if</span>( s[i]!=<span class="string">'0'</span> )</span><br><span class="line">                dp[i+<span class="number">1</span>] += dp[i];</span><br><span class="line">            <span class="keyword">if</span>( s[i<span class="number">-1</span>]!=<span class="string">'0'</span> &amp;&amp; (s[i<span class="number">-1</span>]-<span class="string">'0'</span>)*<span class="number">10</span>+(s[i]-<span class="string">'0'</span>)&lt;=<span class="number">26</span> )</span><br><span class="line">                dp[i+<span class="number">1</span>] += dp[i<span class="number">-1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[s.length()];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="3、correctness-of-algorithm-1"><a href="#3、correctness-of-algorithm-1" class="headerlink" title="3、correctness of algorithm"></a>3、correctness of algorithm</h4><p>首先该问题包含最优子结构的性质，求<code>0~n</code>的字符串包含最多的编码种数包含了求<code>0~n-1</code>的字符串包含最多的编码种数或<code>0~n-2</code>的字符串包含最多的编码种数。其次该问题包含重叠子性质，大量子问题会重复计算，如求dp[5]需要计算dp[4]或dp[3],求dp[4]需要求dp[3]或dp[2]，因此dp[3]被重复计算。综上该问题可以用动态规划方法解且求解方程正确。</p><h4 id="4、complexity-of-algorithm-1"><a href="#4、complexity-of-algorithm-1" class="headerlink" title="4、complexity of algorithm"></a>4、complexity of algorithm</h4><p>整个求解过程只遍历了一遍字符串，故算法时间复杂度为$O(n)$。</p><h3 id="六、OJ第一题"><a href="#六、OJ第一题" class="headerlink" title="六、OJ第一题"></a>六、OJ第一题</h3><p>LIS，DP入门第一题，没啥好说的，只要想清楚为啥每次将新来的数据往 <code>ans</code> 数组里插入，最后出来的就一定是最长的就可以了。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> num, T, N;</span><br><span class="line">    <span class="keyword">int</span> length, index;</span><br><span class="line">    <span class="keyword">int</span> ans[<span class="number">100005</span>];</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; T;</span><br><span class="line">    <span class="keyword">for</span>( <span class="keyword">int</span> t = <span class="number">0</span>; t&lt;T; t++ )&#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; N;</span><br><span class="line">        length = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">memset</span>(ans, <span class="number">-1</span>, <span class="keyword">sizeof</span>(ans));</span><br><span class="line">        <span class="keyword">for</span>( <span class="keyword">int</span> i=<span class="number">0</span>; i&lt;N; i++ )&#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;num);</span><br><span class="line">            index = lower_bound( ans, ans+length, num ) - ans;</span><br><span class="line">            ans[index] = num;</span><br><span class="line">            <span class="keyword">if</span>( index==length )</span><br><span class="line">                length++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; length &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="七、OJ第二题"><a href="#七、OJ第二题" class="headerlink" title="七、OJ第二题"></a>七、OJ第二题</h3><p>入门级题目外加了求 <code>K</code> 个最优值的条件，昨晚1点多打开题目，感觉随便码一码随便A掉，于是上床 睡觉，躺床上拍脑袋理论AC。仔细一想，K个最优值的状态转移，有点问题啊，带着疑问入睡不咋舒坦，大半夜将题目发到<code>315</code>群，杨老师帅气得给出了解决方案，顺带嘲笑了一波数据；炸老师看了数据量也嘲讽了一波；早上起来交了一发，发现 <code>0 ms</code>的时候，也疯狂鄙视一波，数据真的弱得不行。</p><p>想起来当年 <code>ycb</code> 的誓言：</p><p><img src="/2018/10/28/算法课第二次作业/ycb.jpeg" alt=""></p><p><img src="/2018/10/28/算法课第二次作业/dp1.png" alt=""></p><p><img src="/2018/10/28/算法课第二次作业/dp2.png" alt=""></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> m, n, k;</span><br><span class="line"><span class="keyword">int</span> num;</span><br><span class="line">priority_queue&lt;<span class="keyword">int</span>&gt; ans[<span class="number">105</span>], cur_ans, tmp_ans;<span class="comment">//默认大堆</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ans[<span class="number">1</span>].push(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; m &gt;&gt; n &gt;&gt; k;</span><br><span class="line">    <span class="keyword">for</span>( <span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=m; i++ )&#123;</span><br><span class="line">        <span class="keyword">for</span>( <span class="keyword">int</span> j=<span class="number">1</span>; j&lt;=n; j++ )&#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;num);</span><br><span class="line">            <span class="keyword">while</span>( !cur_ans.empty() )&#123;  <span class="comment">//清空cur_ans</span></span><br><span class="line">                cur_ans.pop();</span><br><span class="line">            &#125;</span><br><span class="line">            tmp_ans = ans[j<span class="number">-1</span>];</span><br><span class="line">            <span class="keyword">while</span>( !ans[j<span class="number">-1</span>].empty() )&#123;</span><br><span class="line">                cur_ans.push(ans[j<span class="number">-1</span>].top()+num);</span><br><span class="line">                ans[j<span class="number">-1</span>].pop();</span><br><span class="line">            &#125;</span><br><span class="line">            ans[j<span class="number">-1</span>] = tmp_ans;</span><br><span class="line">            <span class="keyword">while</span>( !ans[j].empty() )&#123;</span><br><span class="line">                cur_ans.push(ans[j].top()+num);</span><br><span class="line">                ans[j].pop();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span>( ans[j].size()&lt;k &amp;&amp; !cur_ans.empty() )&#123;</span><br><span class="line">                ans[j].push(cur_ans.top());</span><br><span class="line">                cur_ans.pop();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; ans[n].top();</span><br><span class="line">    ans[n].pop();</span><br><span class="line">    <span class="keyword">while</span>( !ans[n].empty() )&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">" "</span> &lt;&lt; ans[n].top();</span><br><span class="line">        ans[n].pop();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;一、Money-robbing&quot;&gt;&lt;a href=&quot;#一、Money-robbing&quot; class=&quot;headerlink&quot; title=&quot;一、Money robbing&quot;&gt;&lt;/a&gt;一、Money robbing&lt;/h3&gt;&lt;h4 id=&quot;1、optimal-substructure-and-DP-equation&quot;&gt;&lt;a href=&quot;#1、optimal-substructure-and-DP-equation&quot; class=&quot;headerlink&quot; title=&quot;1、optimal substructure and DP equation&quot;&gt;&lt;/a&gt;1、optimal substructure and DP equation&lt;/h4&gt;&lt;p&gt;对于第 i 家，有两种选择，抢或者不抢。如果抢第 i 家，那么最大收益为：value[i] + 抢前 i-2 家的最优收益； 如果第 i 家不抢，那么最大收益为：抢前 i-1 家的最优收益。&lt;/p&gt;
&lt;p&gt;状态转移方程可写为：&lt;br&gt;$$&lt;br&gt;dp[i] = max( dp[i-1], dp[i-2]+value[i] )&lt;br&gt;$$&lt;/p&gt;
&lt;h4 id=&quot;2、-pseudo-code&quot;&gt;&lt;a href=&quot;#2、-pseudo-code&quot; class=&quot;headerlink&quot; title=&quot;2、 pseudo-code&quot;&gt;&lt;/a&gt;2、 pseudo-code&lt;/h4&gt;&lt;p&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/house-robber/description/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;LeetCode 198题&lt;/a&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight c++&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Solution&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt;:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;rob&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;built_in&quot;&gt;vector&lt;/span&gt;&amp;lt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt;&amp;gt;&amp;amp; nums)&lt;/span&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;( nums.size()==&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt; )&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;( nums.size()==&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt; )&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; nums[&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;built_in&quot;&gt;vector&lt;/span&gt;&amp;lt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt;&amp;gt; dp(nums.size(),&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        dp[&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;] = nums[&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        dp[&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;] = max( nums[&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;], nums[&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;] );&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt;( &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; i=&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;; i&amp;lt;nums.size(); i++ )&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            dp[i] = max( dp[i&lt;span class=&quot;number&quot;&gt;-1&lt;/span&gt;], dp[i&lt;span class=&quot;number&quot;&gt;-2&lt;/span&gt;]+nums[i] );&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; dp[nums.size()&lt;span class=&quot;number&quot;&gt;-1&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="作业" scheme="https://wangjibao.com.cn/categories/%E4%BD%9C%E4%B8%9A/"/>
    
      <category term="算法课第二次作业" scheme="https://wangjibao.com.cn/categories/%E4%BD%9C%E4%B8%9A/%E7%AE%97%E6%B3%95%E8%AF%BE%E7%AC%AC%E4%BA%8C%E6%AC%A1%E4%BD%9C%E4%B8%9A/"/>
    
    
      <category term="作业" scheme="https://wangjibao.com.cn/tags/%E4%BD%9C%E4%B8%9A/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode21-30</title>
    <link href="https://wangjibao.com.cn/2018/10/20/LeetCode21-30/"/>
    <id>https://wangjibao.com.cn/2018/10/20/LeetCode21-30/</id>
    <published>2018-10-20T11:51:57.000Z</published>
    <updated>2019-05-08T16:19:34.492Z</updated>
    
    <content type="html"><![CDATA[<h2 id="21、合并两个有序链表"><a href="#21、合并两个有序链表" class="headerlink" title="21、合并两个有序链表"></a>21、<a href="https://leetcode-cn.com/problems/merge-two-sorted-lists" target="_blank" rel="noopener">合并两个有序链表</a></h2><p>两个有序链表的合并，本渣代码充分利用原有空间，没开辟新的内存存储新链。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">mergeTwoLists</span><span class="params">(ListNode* l1, ListNode* l2)</span> </span>&#123;</span><br><span class="line">        ListNode *ans = (ListNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(ListNode)), *tmp = ans;</span><br><span class="line">        ans-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">while</span>( l1&amp;&amp;l2 )&#123;</span><br><span class="line">            <span class="keyword">if</span>( l1-&gt;val &gt; l2-&gt;val )&#123;</span><br><span class="line">                tmp-&gt;next = l2;</span><br><span class="line">                l2 = l2-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                tmp-&gt;next = l1;</span><br><span class="line">                l1 = l1-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            tmp = tmp-&gt;next;</span><br><span class="line">            tmp-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>( l1 )</span><br><span class="line">            tmp-&gt;next = l1;</span><br><span class="line">        <span class="keyword">if</span>( l2 )</span><br><span class="line">            tmp-&gt;next = l2;</span><br><span class="line">        <span class="keyword">return</span> ans-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="22、括号生成"><a href="#22、括号生成" class="headerlink" title="22、括号生成"></a>22、<a href="https://leetcode-cn.com/problems/generate-parentheses" target="_blank" rel="noopener">括号生成</a></h2><p>生成的种类数是个卡特兰数，因此 n 的值不会太大。卡特兰数在计算机中是个特别重要的数串，像：三角剖分、n个叶节点树的种类、n个数字的进出栈、括号匹配、矩阵链乘等等都有卡特兰数的应用。</p><p>卡特兰数的通项公式：<br>$$<br>h(n) = C_{2n}^n - C_{2n}^{n-1}<br>$$<br>递推公式为：<br>$$<br>h(n) = h(n-1)*\frac{4n-2}{n+1}<br>$$<br>其实，求组合数时，当 n 很大的时候，计算也是个问题，好在有 <a href="https://blog.csdn.net/arrowlll/article/details/53064748" target="_blank" rel="noopener">Lucas定理</a> 可以解决这事，当然以上这些与解决本题没啥关系。</p><p>本题做法是直接递归一下即可，每次放左括号（第16行）或右括号（第17行），递归的退出条件是放了n个左括号和n个右括号（第9行），剪枝条件是放的右括号数量大于左括号数量了，明显会造成非法串，直接返回退出（第13行）。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; generateParenthesis(<span class="keyword">int</span> n) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; ans;</span><br><span class="line">        func(ans, <span class="string">""</span>, n, n);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; ans, <span class="built_in">string</span> tmp_ans, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>( left==<span class="number">0</span> &amp;&amp; right==<span class="number">0</span> )&#123;</span><br><span class="line">            ans.push_back(tmp_ans);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>( right&lt;left )  <span class="comment">//相当于剪枝，2^n剪到katalan(n)</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span>( left&gt;<span class="number">0</span> )</span><br><span class="line">            func( ans, tmp_ans+<span class="string">'('</span>, left<span class="number">-1</span>, right );</span><br><span class="line">        func( ans, tmp_ans+<span class="string">')'</span>, left, right<span class="number">-1</span> );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="23、合并K个排序链表"><a href="#23、合并K个排序链表" class="headerlink" title="23、合并K个排序链表"></a>23、<a href="https://leetcode-cn.com/problems/merge-k-sorted-lists" target="_blank" rel="noopener">合并K个排序链表</a></h2><p>合并的关键点在于如何快速找到当前最小值，最小堆可以帮我们快速实现这一点。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> <span class="class"><span class="keyword">struct</span> <span class="title">cmp</span>&#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(ListNode* a, ListNode* b)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a-&gt;val &gt; b-&gt;val;</span><br><span class="line">    &#125;</span><br><span class="line"> &#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">mergeKLists</span><span class="params">(<span class="built_in">vector</span>&lt;ListNode*&gt;&amp; lists)</span> </span>&#123;</span><br><span class="line">        ListNode *ans = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        ListNode *p = ans, *tmp;</span><br><span class="line">        priority_queue&lt;ListNode*, <span class="built_in">vector</span>&lt;ListNode*&gt;, cmp&gt; pq;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;lists.size(); i++)&#123;</span><br><span class="line">           <span class="keyword">if</span>(lists[i])</span><br><span class="line">                pq.push(lists[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(pq.size()&gt;<span class="number">1</span>)&#123;</span><br><span class="line">            tmp = pq.top();</span><br><span class="line">            pq.pop();</span><br><span class="line">            p-&gt;next = tmp;</span><br><span class="line">            <span class="keyword">if</span>(tmp-&gt;next)</span><br><span class="line">                pq.push(tmp-&gt;next);</span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">            p-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(pq.size()==<span class="number">1</span>)</span><br><span class="line">            p-&gt;next = pq.top();</span><br><span class="line">        <span class="keyword">return</span> ans-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="24、两两交换链表中的节点"><a href="#24、两两交换链表中的节点" class="headerlink" title="24、两两交换链表中的节点"></a>24、<a href="https://leetcode-cn.com/problems/swap-nodes-in-pairs" target="_blank" rel="noopener">两两交换链表中的节点</a></h2><p>处理好两个指针之间的关系即可。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">swapPairs</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>( head==<span class="literal">NULL</span> || head-&gt;next==<span class="literal">NULL</span> )</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        ListNode *p1=head, *p2=head-&gt;next, *tmp;</span><br><span class="line">        head = head-&gt;next;</span><br><span class="line">        <span class="keyword">while</span>( p1 &amp;&amp; p2)&#123;</span><br><span class="line">            tmp = p1;</span><br><span class="line">            p1-&gt;next = p2-&gt;next==<span class="literal">NULL</span>? <span class="literal">NULL</span>:p2-&gt;next-&gt;next==<span class="literal">NULL</span>? p2-&gt;next:p2-&gt;next-&gt;next;</span><br><span class="line">            p1 = p2-&gt;next;</span><br><span class="line">            p2-&gt;next = tmp;</span><br><span class="line">            p2 = p1==<span class="literal">NULL</span>? <span class="literal">NULL</span>:p1-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="25、k个一组翻转链表"><a href="#25、k个一组翻转链表" class="headerlink" title="25、k个一组翻转链表"></a>25、<a href="https://leetcode-cn.com/problems/reverse-nodes-in-k-group" target="_blank" rel="noopener">k个一组翻转链表</a></h2><p>采用一个大小为 <code>k</code> 的栈来实现翻转。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">reverseKGroup</span><span class="params">(ListNode* head, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">        ListNode *tmp_head = head, *ans, *cur_ans;</span><br><span class="line">        <span class="keyword">while</span>(tmp_head)&#123;</span><br><span class="line">            len++;</span><br><span class="line">            tmp_head = tmp_head-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> num_roll = len / k;</span><br><span class="line">        ans = <span class="keyword">new</span> ListNode(<span class="number">-1</span>);</span><br><span class="line">        cur_ans = ans;</span><br><span class="line">        <span class="built_in">stack</span>&lt;ListNode*&gt; s;</span><br><span class="line">        tmp_head = head;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;num_roll; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;k; j++)&#123;</span><br><span class="line">                s.push(tmp_head);</span><br><span class="line">                tmp_head = tmp_head-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;k; j++)&#123;</span><br><span class="line">                cur_ans-&gt;next = s.top();</span><br><span class="line">                s.pop();</span><br><span class="line">                cur_ans = cur_ans-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        cur_ans-&gt;next = tmp_head;</span><br><span class="line">        <span class="keyword">return</span> ans-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="26、删除排序数组中的重复项"><a href="#26、删除排序数组中的重复项" class="headerlink" title="26、删除排序数组中的重复项"></a>26、<a href="https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array" target="_blank" rel="noopener">删除排序数组中的重复项</a></h2><p>直接使用 <code>STL</code> 中的 <code>unique</code> 函数即可，<code>unique</code> 函数的具体说明如下：</p><p><code>iterator unique(iterator it_1,iterator it_2);</code></p><p>两个参数表示对容器中[it_1，it_2)范围的元素进行去重(<strong>注：区间是前闭后开，即不包含it_2所指的元素</strong>),返回值是一个迭代器，<strong>它指向的是去重后容器中不重复序列的最后一个元素的下一个元素</strong>。注意，<code>unique</code>函数的去重过程实际上就是<strong>不停的把后面不重复的元素移到前面来，也可以说是用不重复的元素占领重复元素的位置</strong>，而不是将重复的元素往后移动。</p><p><img src="/2018/10/20/LeetCode21-30/unique.png" alt=""></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">removeDuplicates</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> unique(nums.begin(), nums.end()) - nums.begin();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="27、移除元素"><a href="#27、移除元素" class="headerlink" title="27、移除元素"></a>27、<a href="https://leetcode-cn.com/problems/remove-element" target="_blank" rel="noopener">移除元素</a></h2><p>双指针，执行调换过程即可，注意，如果前后调换后，<code>nums[pFront]</code> 可能依然等于 <code>val</code>，通过第<code>11</code>行的 <code>continue</code>语句巧妙的解决该问题。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">removeElement</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.size()==<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> pFront=<span class="number">0</span>, pEnd = nums.size()<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(pEnd&gt;pFront)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[pFront]==val)&#123;</span><br><span class="line">                swap(nums[pFront], nums[pEnd]);</span><br><span class="line">                pEnd--;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            pFront++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums[pFront]==val? pFront:pFront+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="28、实现strStr"><a href="#28、实现strStr" class="headerlink" title="28、实现strStr()"></a>28、<a href="https://leetcode-cn.com/problems/implement-strstr" target="_blank" rel="noopener">实现strStr()</a></h2><p>可以直接暴力，时间复杂度为$O(n^2)$。线性时间复杂度算法为 <a href="https://www.cnblogs.com/ZuoAndFutureGirl/p/9028287.html" target="_blank" rel="noopener">KMP</a> 算法或  BM 算法。KMP 算法的关键是理解 <code>next</code> 数组的求解过程。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> next[<span class="number">100000</span>];</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">solve_next</span><span class="params">(<span class="built_in">string</span> needle)</span></span>&#123;</span><br><span class="line">        <span class="built_in">memset</span>(next, <span class="number">-1</span>, <span class="keyword">sizeof</span>(next));</span><br><span class="line">        <span class="keyword">int</span> len = needle.size();</span><br><span class="line">        <span class="keyword">int</span> k = <span class="number">-1</span>, j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(j&lt;len<span class="number">-1</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>( k==<span class="number">-1</span> || needle[j]==needle[k] )</span><br><span class="line">                next[++j] = ++k;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                k = next[k];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">strStr</span><span class="params">(<span class="built_in">string</span> haystack, <span class="built_in">string</span> needle)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(needle.size()==<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        solve_next(needle);</span><br><span class="line">        <span class="keyword">int</span> len_haystack = haystack.size();</span><br><span class="line">        <span class="keyword">int</span> len_needle = needle.size();</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>( i&lt;len_haystack &amp;&amp; j&lt;len_needle)&#123;</span><br><span class="line">            <span class="keyword">if</span>(j==<span class="number">-1</span> || haystack[i]==needle[j])&#123;</span><br><span class="line">                i++;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                j = next[j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(j==len_needle)</span><br><span class="line">            <span class="keyword">return</span> i-j;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="29、两数相除"><a href="#29、两数相除" class="headerlink" title="29、两数相除"></a>29、<a href="https://leetcode-cn.com/problems/divide-two-integers" target="_blank" rel="noopener">两数相除</a></h2><p>使用移位操作模拟乘法，用减法代替除法。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">divide</span><span class="params">(<span class="keyword">int</span> dividend, <span class="keyword">int</span> divisor)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>( dividend==INT_MIN &amp;&amp; divisor==<span class="number">-1</span> )</span><br><span class="line">            <span class="keyword">return</span> INT_MAX;</span><br><span class="line">        <span class="keyword">int</span> flag1 = dividend&gt;<span class="number">0</span>? <span class="number">1</span>:<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">int</span> flag2 = divisor&gt;<span class="number">0</span>? <span class="number">1</span>:<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> _dividend = <span class="built_in">abs</span>((<span class="keyword">long</span> <span class="keyword">long</span>)dividend);</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> _divisor = <span class="built_in">abs</span>((<span class="keyword">long</span> <span class="keyword">long</span>)divisor);</span><br><span class="line">        <span class="keyword">int</span> n = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(_divisor&lt;&lt;(n+<span class="number">1</span>) &lt;= _dividend &amp;&amp; _divisor&lt;&lt;(n+<span class="number">1</span>) &gt;= <span class="number">0</span>)</span><br><span class="line">            n++;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=n; i&gt;=<span class="number">0</span>; i--)&#123;</span><br><span class="line">            <span class="keyword">if</span>( _dividend &gt;= _divisor&lt;&lt;i )&#123;</span><br><span class="line">                ans += (<span class="keyword">long</span> <span class="keyword">long</span>)<span class="number">1</span>&lt;&lt;i;</span><br><span class="line">                _dividend -= _divisor&lt;&lt;i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(flag1+flag2==<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> -ans&gt;=INT_MAX? INT_MAX:<span class="keyword">int</span>(-ans);</span><br><span class="line">        <span class="keyword">return</span> ans&gt;=INT_MAX? INT_MAX:ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="30、串联所有单词的子串"><a href="#30、串联所有单词的子串" class="headerlink" title="30、串联所有单词的子串"></a>30、<a href="https://leetcode-cn.com/problems/substring-with-concatenation-of-all-words" target="_blank" rel="noopener">串联所有单词的子串</a></h2><p><code>words</code>中单词长度固定，将<code>s</code>串按照固定长度切分保存进<code>vector&lt;string&gt;</code>中，之后使用两个<code>map</code>和滑动窗口实现匹配过程，详见代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; findSubstring(<span class="built_in">string</span> s, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; words) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line">        <span class="keyword">if</span>(s.size()==<span class="number">0</span> || words.size()==<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> ans;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt; mp1;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> str : words)</span><br><span class="line">            mp1[str] = mp1.find(str)==mp1.end()? <span class="number">1</span>:mp1[str]+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> str_len = words[<span class="number">0</span>].length();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;str_len; i++)&#123;</span><br><span class="line">            <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; word_vec;</span><br><span class="line">            <span class="keyword">int</span> position = i;</span><br><span class="line">            <span class="keyword">while</span>( position + str_len &lt;= s.length() )&#123;</span><br><span class="line">                word_vec.push_back(s.substr(position, str_len));</span><br><span class="line">                position += str_len;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">unordered_map</span>&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt; mp2;</span><br><span class="line">            <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;word_vec.size(); j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(mp1.find(word_vec[j])==mp1.end())&#123;</span><br><span class="line">                    mp2.clear();</span><br><span class="line">                    left = j+<span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                mp2[word_vec[j]] = mp2.find(word_vec[j])==mp2.end()? <span class="number">1</span>:mp2[word_vec[j]]+<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">while</span>(mp2[word_vec[j]] &gt; mp1[word_vec[j]])</span><br><span class="line">                    mp2[word_vec[left++]] -= <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span>( j-left+<span class="number">1</span> == words.size() )&#123;</span><br><span class="line">                    ans.push_back(left*str_len+i);</span><br><span class="line">                    mp2[word_vec[left]] -= <span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">if</span>(mp2[word_vec[left]]==<span class="number">0</span>)</span><br><span class="line">                        mp2.erase(word_vec[left]);</span><br><span class="line">                    left++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;21、合并两个有序链表&quot;&gt;&lt;a href=&quot;#21、合并两个有序链表&quot; class=&quot;headerlink&quot; title=&quot;21、合并两个有序链表&quot;&gt;&lt;/a&gt;21、&lt;a href=&quot;https://leetcode-cn.com/problems/merge-two-sorted-lists&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;合并两个有序链表&lt;/a&gt;&lt;/h2&gt;&lt;p&gt;两个有序链表的合并，本渣代码充分利用原有空间，没开辟新的内存存储新链。&lt;/p&gt;
&lt;figure class=&quot;highlight c++&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;31&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;32&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;/**&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt; * Definition for singly-linked list.&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt; * struct ListNode &amp;#123;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt; *     int val;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt; *     ListNode *next;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt; *     ListNode(int x) : val(x), next(NULL) &amp;#123;&amp;#125;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt; * &amp;#125;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt; */&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Solution&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt;:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;ListNode* &lt;span class=&quot;title&quot;&gt;mergeTwoLists&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(ListNode* l1, ListNode* l2)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        ListNode *ans = (ListNode*)&lt;span class=&quot;built_in&quot;&gt;malloc&lt;/span&gt;(&lt;span class=&quot;keyword&quot;&gt;sizeof&lt;/span&gt;(ListNode)), *tmp = ans;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        ans-&amp;gt;next = &lt;span class=&quot;literal&quot;&gt;NULL&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;while&lt;/span&gt;( l1&amp;amp;&amp;amp;l2 )&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;( l1-&amp;gt;val &amp;gt; l2-&amp;gt;val )&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                tmp-&amp;gt;next = l2;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                l2 = l2-&amp;gt;next;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                tmp-&amp;gt;next = l1;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                l1 = l1-&amp;gt;next;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            tmp = tmp-&amp;gt;next;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            tmp-&amp;gt;next = &lt;span class=&quot;literal&quot;&gt;NULL&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;( l1 )&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            tmp-&amp;gt;next = l1;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;( l2 )&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            tmp-&amp;gt;next = l2;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; ans-&amp;gt;next;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="LeetCode" scheme="https://wangjibao.com.cn/categories/LeetCode/"/>
    
      <category term="LeetCode21-30" scheme="https://wangjibao.com.cn/categories/LeetCode/LeetCode21-30/"/>
    
    
      <category term="LeetCode" scheme="https://wangjibao.com.cn/tags/LeetCode/"/>
    
  </entry>
  
</feed>
