<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>来呀，不服抓个包~~</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://wangjibao.com.cn/"/>
  <updated>2019-12-30T09:08:24.938Z</updated>
  <id>https://wangjibao.com.cn/</id>
  
  <author>
    <name>大宝哥spring</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>cDCGAN生成指定手写数字--tensorflow2.0</title>
    <link href="https://wangjibao.com.cn/2019/12/27/cDCGAN%E7%94%9F%E6%88%90%E6%8C%87%E5%AE%9A%E6%89%8B%E5%86%99%E6%95%B0%E5%AD%97--tensorflow2.0/"/>
    <id>https://wangjibao.com.cn/2019/12/27/cDCGAN生成指定手写数字--tensorflow2.0/</id>
    <published>2019-12-27T06:16:42.000Z</published>
    <updated>2019-12-30T09:08:24.938Z</updated>
    
    <content type="html"><![CDATA[<p>接上一篇<code>DCGAN手写数字生成</code>，虽然它能够生成效果不错的手写数字图片，但它有一个缺点就是不能生成指定数值的数字，好在有一种 <code>GAN</code> 模型叫 <code>cGAN</code>，即 <code>Conditional Generative Adversarial Nets</code>， 出自 <a href="https://arxiv.org/abs/1411.1784" target="_blank" rel="noopener">此篇论文</a>。</p><p>模型结构如下图：</p><p><img src="/2019/12/27/cDCGAN生成指定手写数字--tensorflow2.0/cdcgan_model.png" alt=""></p><p>其损失函数定义：</p><p><img src="/2019/12/27/cDCGAN生成指定手写数字--tensorflow2.0/loss_function.png" alt=""></p><a id="more"></a><p><code>GAN</code> 所能接受的 <strong>条件 <code>y</code> </strong>种类很多，如<code>label</code>等等。 接下里，我们就使用 <code>MNIST</code> 数据集加入 <code>label</code> 条件，实现一个可以生成指定数值的数字图片模型。代码实现和上一篇几乎一样，只不过加入了<code>label</code>。废话少说，<code>show me your code</code>：</p><h5 id="1、定义生成器"><a href="#1、定义生成器" class="headerlink" title="1、定义生成器"></a>1、定义生成器</h5><p>和上一篇中的生成器定义一样，只不过这里的输入维度变成了 <code>110</code> ，随机噪声的 <code>100</code> 维 +  <code>one-hot</code> 编码的 <code>10</code> 维 <code>label</code> ，将两者级联起来送入生成器，生成一个 <code>28*28*1</code> 的黑白数字图像。</p><p>级联：<code>tf.concat((step_noise, labels), axis=1)</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">make_generator_model</span><span class="params">()</span>:</span></span><br><span class="line">    model = tf.keras.Sequential()</span><br><span class="line">    model.add(layers.Dense(<span class="number">7</span>*<span class="number">7</span>*<span class="number">256</span>, use_bias=<span class="keyword">False</span>, input_shape=(<span class="number">110</span>,)))  <span class="comment"># 输入数据的维度为 100 + 10 = 110</span></span><br><span class="line">    model.add(layers.BatchNormalization())</span><br><span class="line">    model.add(layers.LeakyReLU())</span><br><span class="line">    model.add(layers.Reshape((<span class="number">7</span>, <span class="number">7</span>, <span class="number">256</span>)))</span><br><span class="line">    <span class="keyword">assert</span> model.output_shape == (<span class="keyword">None</span>, <span class="number">7</span>, <span class="number">7</span>, <span class="number">256</span>)</span><br><span class="line"></span><br><span class="line">    model.add(layers.Conv2DTranspose(filters=<span class="number">128</span>, kernel_size=(<span class="number">5</span>, <span class="number">5</span>), strides=(<span class="number">1</span>, <span class="number">1</span>), padding=<span class="string">'same'</span>, use_bias=<span class="keyword">False</span>)) <span class="comment"># 反卷积层</span></span><br><span class="line">    <span class="keyword">assert</span> model.output_shape == (<span class="keyword">None</span>, <span class="number">7</span>, <span class="number">7</span>, <span class="number">128</span>)</span><br><span class="line">    model.add(layers.BatchNormalization())</span><br><span class="line">    model.add(layers.LeakyReLU())</span><br><span class="line"></span><br><span class="line">    model.add(layers.Conv2DTranspose(filters=<span class="number">64</span>, kernel_size=(<span class="number">5</span>, <span class="number">5</span>), strides=(<span class="number">2</span>, <span class="number">2</span>), padding=<span class="string">'same'</span>, use_bias=<span class="keyword">False</span>))</span><br><span class="line">    <span class="keyword">assert</span> model.output_shape == (<span class="keyword">None</span>, <span class="number">14</span>, <span class="number">14</span>, <span class="number">64</span>)</span><br><span class="line">    model.add(layers.BatchNormalization())</span><br><span class="line">    model.add(layers.LeakyReLU())</span><br><span class="line"></span><br><span class="line">    model.add(layers.Conv2DTranspose(filters=<span class="number">1</span>, kernel_size=(<span class="number">5</span>, <span class="number">5</span>), strides=(<span class="number">2</span>, <span class="number">2</span>), padding=<span class="string">'same'</span>, use_bias=<span class="keyword">False</span>, activation=<span class="string">'tanh'</span>))</span><br><span class="line">    <span class="keyword">assert</span> model.output_shape == (<span class="keyword">None</span>, <span class="number">28</span>, <span class="number">28</span>, <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span> model</span><br></pre></td></tr></table></figure><h5 id="2、定义判别器"><a href="#2、定义判别器" class="headerlink" title="2、定义判别器"></a>2、定义判别器</h5><p>判别器的结构也和上一篇的一模一样，不过这里的输入维度由 <code>28*28*1</code> 变成了 <code>28*28*11</code>，将 <code>one-hot</code> 编码的<code>label</code> 条件添加到图片中。具体级联操作：</p><p><code>labels = tf.reshape(labels, (256,1,1,10)) * tf.ones((256,28,28,10)) #[batch, 28, 28, 10]</code></p><p><code>tf.concat((images, labels), axis=3) #[batch, 28, 28, 11]</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">make_discriminator_model</span><span class="params">()</span>:</span></span><br><span class="line">    model = tf.keras.Sequential()</span><br><span class="line">    model.add(layers.Conv2D(filters=<span class="number">64</span>, kernel_size=(<span class="number">5</span>, <span class="number">5</span>), strides=(<span class="number">2</span>, <span class="number">2</span>), padding=<span class="string">'same'</span>, input_shape=[<span class="number">28</span>, <span class="number">28</span>, <span class="number">11</span>])) <span class="comment"># 维度为 1 + 10(label) = 11</span></span><br><span class="line">    model.add(layers.LeakyReLU())</span><br><span class="line">    model.add(layers.Dropout(rate=<span class="number">0.3</span>))</span><br><span class="line"></span><br><span class="line">    model.add(layers.Conv2D(filters=<span class="number">128</span>, kernel_size=(<span class="number">5</span>, <span class="number">5</span>), strides=(<span class="number">2</span>, <span class="number">2</span>), padding=<span class="string">'same'</span>))</span><br><span class="line">    model.add(layers.LeakyReLU())</span><br><span class="line">    model.add(layers.Dropout(rate=<span class="number">0.3</span>))</span><br><span class="line"></span><br><span class="line">    model.add(layers.Flatten())</span><br><span class="line">    model.add(layers.Dense(<span class="number">1</span>))   <span class="comment"># 真实图片输出 1，伪造的图片输出0</span></span><br><span class="line">    <span class="keyword">return</span> model</span><br></pre></td></tr></table></figure><h5 id="3、定义生成器和判别器的损失函数"><a href="#3、定义生成器和判别器的损失函数" class="headerlink" title="3、定义生成器和判别器的损失函数"></a>3、定义生成器和判别器的损失函数</h5><p>损失函数和上一篇的一模一样，不用改，具体如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">cross_entropy = tf.keras.losses.BinaryCrossentropy(from_logits=<span class="keyword">True</span>)</span><br><span class="line"><span class="comment"># 判别器损失</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">discriminator_loss</span><span class="params">(real_output, fake_output)</span>:</span></span><br><span class="line">    real_loss = cross_entropy(tf.ones_like(real_output), real_output)</span><br><span class="line">    fake_loss = cross_entropy(tf.zeros_like(fake_output), fake_output)</span><br><span class="line">    total_loss = real_loss + fake_loss</span><br><span class="line">    <span class="keyword">return</span> total_loss</span><br><span class="line"><span class="comment"># 生成器损失</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">generator_loss</span><span class="params">(fake_output)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> cross_entropy(tf.ones_like(fake_output), fake_output)</span><br></pre></td></tr></table></figure><h5 id="4、定义优化器及训练过程"><a href="#4、定义优化器及训练过程" class="headerlink" title="4、定义优化器及训练过程"></a>4、定义优化器及训练过程</h5><p>和上一篇 <code>DCGAN</code> 的一模一样，在训练过程中，每次生成一个维度为 <code>[256, 100]</code> 的随机噪声矩阵，级联 <code>labels</code> 条件后喂入 <code>generator</code> 生成 <code>generated_image</code>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 实例化模型</span></span><br><span class="line">generator = make_generator_model()</span><br><span class="line">discriminator = make_discriminator_model()</span><br><span class="line"><span class="comment"># 定义优化器</span></span><br><span class="line">generator_optimizer = tf.keras.optimizers.Adam(<span class="number">1e-4</span>)</span><br><span class="line">discriminator_optimizer = tf.keras.optimizers.Adam(<span class="number">1e-4</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">@tf.function</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">train_step</span><span class="params">(images, labels)</span>:</span></span><br><span class="line">    step_noise = tf.random.normal([<span class="number">256</span>, <span class="number">100</span>])  <span class="comment"># 256 代表 batch 的大小</span></span><br><span class="line">    <span class="keyword">with</span> tf.GradientTape() <span class="keyword">as</span> gen_tape, tf.GradientTape() <span class="keyword">as</span> disc_tape:</span><br><span class="line">        generated_images = generator(tf.concat((step_noise, labels), axis=<span class="number">1</span>), training=<span class="keyword">True</span>)  <span class="comment"># [batch, 28, 28, 1]</span></span><br><span class="line"></span><br><span class="line">        labels = tf.reshape(labels, (<span class="number">256</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">10</span>)) * tf.ones((<span class="number">256</span>, <span class="number">28</span>, <span class="number">28</span>, <span class="number">10</span>))  <span class="comment"># [256, 28, 28, 10]</span></span><br><span class="line"></span><br><span class="line">        real_output = discriminator(tf.concat((images, labels), axis=<span class="number">3</span>), training=<span class="keyword">True</span>)  <span class="comment"># [256, 28, 28, 11]</span></span><br><span class="line">        fake_output = discriminator(tf.concat((generated_images, labels), axis=<span class="number">3</span>), training=<span class="keyword">True</span>) <span class="comment"># [256, 28, 28, 11]</span></span><br><span class="line">        gen_loss = generator_loss(fake_output)</span><br><span class="line">        disc_loss = discriminator_loss(real_output, fake_output)</span><br><span class="line">    gradients_of_generator = gen_tape.gradient(gen_loss, generator.trainable_variables)</span><br><span class="line">    gradients_of_discriminator = disc_tape.gradient(disc_loss, discriminator.trainable_variables)</span><br><span class="line">    generator_optimizer.apply_gradients(zip(gradients_of_generator,generator.trainable_variables))</span><br><span class="line">    discriminator_optimizer.apply_gradients(zip(gradients_of_discriminator, discriminator.trainable_variables))</span><br></pre></td></tr></table></figure><h5 id="5、开始训练"><a href="#5、开始训练" class="headerlink" title="5、开始训练"></a>5、开始训练</h5><p>此部分还是和上一篇的一模一样，<code>checkpoint</code> 定义要保存的模型对象，这里保存了生成器，判别器及两者各自的优化器，每 20 轮保存一次。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 保存检查点</span></span><br><span class="line">checkpoint = tf.train.Checkpoint(generator_optimizer=generator_optimizer, discriminator_optimizer=discriminator_optimizer, generator=generator, discriminator=discriminator)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">train</span><span class="params">(train_images, train_labels, epochs)</span>:</span> <span class="comment"># [70000, 28, 28, 1]  [70000, 10]</span></span><br><span class="line">    <span class="keyword">for</span> epoch <span class="keyword">in</span> range(epochs):</span><br><span class="line">        start = time.time()</span><br><span class="line">        <span class="comment"># 打乱训练数据</span></span><br><span class="line">        index = random.sample(range(<span class="number">0</span>, train_images.shape[<span class="number">0</span>]), train_images.shape[<span class="number">0</span>])</span><br><span class="line">        <span class="keyword">for</span> step <span class="keyword">in</span> range(train_images.shape[<span class="number">0</span>] // <span class="number">256</span>):</span><br><span class="line">            train_step(train_images[index[step*<span class="number">256</span>:(step+<span class="number">1</span>)*<span class="number">256</span>]], train_labels[index[step*<span class="number">256</span>:(step+<span class="number">1</span>)*<span class="number">256</span>]])</span><br><span class="line">        generate_and_save_images(generator, epoch+<span class="number">1</span>, tf.concat((noise_image, noise_label), axis=<span class="number">1</span>))</span><br><span class="line">        <span class="keyword">if</span> (epoch+<span class="number">1</span>) % <span class="number">20</span> == <span class="number">0</span>:</span><br><span class="line">            checkpoint.save(file_prefix=<span class="string">"training_checkpoints/cDCGAN"</span>)</span><br><span class="line">        print(<span class="string">"Time for "</span>, epoch, <span class="string">" epoch is: "</span>, time.time() - start)</span><br></pre></td></tr></table></figure><p>其中，<code>generate_and_save_images</code> 函数和此前的还是一样，只不过这里喂入的数据，是固定的<code>noise_image</code> 和 <code>noise_label</code> 级联后的维度为 <code>110</code>，来查看生成器生成图片的效果。<code>0--9</code> 的 <code>label</code> 每样是 <code>10</code>个，一共<code>100</code> 个样例。具体实现如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">noise_image = tf.random.normal([<span class="number">10</span>, <span class="number">100</span>])</span><br><span class="line">noise_label = tf.zeros([<span class="number">10</span>])</span><br><span class="line"><span class="keyword">for</span> num <span class="keyword">in</span> range(<span class="number">1</span>, <span class="number">10</span>):</span><br><span class="line">    tmp_noise_image = tf.random.normal([<span class="number">10</span>, <span class="number">100</span>])</span><br><span class="line">    noise_image = tf.concat((noise_image, tmp_noise_image), axis=<span class="number">0</span>)</span><br><span class="line">    tmp_noise_label = tf.zeros([<span class="number">10</span>]) + num</span><br><span class="line">    noise_label = tf.concat((noise_label, tmp_noise_label), axis=<span class="number">0</span>)</span><br><span class="line">noise_label = np.eye(<span class="number">10</span>)[tf.cast(noise_label, tf.int32)].astype(<span class="string">"float32"</span>)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">generate_and_save_images</span><span class="params">(model, epoch, input)</span>:</span></span><br><span class="line">    predictions = model(input, training=<span class="keyword">False</span>)</span><br><span class="line">    fig = plt.figure(figsize=(<span class="number">10</span>, <span class="number">10</span>))</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(predictions.shape[<span class="number">0</span>]):</span><br><span class="line">        plt.subplot(<span class="number">10</span>, <span class="number">10</span>, i+<span class="number">1</span>)</span><br><span class="line">        plt.imshow(predictions[i,:,:,<span class="number">0</span>]*<span class="number">127.5</span>+<span class="number">127.5</span>, cmap=<span class="string">'gray'</span>)</span><br><span class="line">        plt.axis(<span class="string">'off'</span>)</span><br><span class="line">    plt.savefig(<span class="string">"epoch_image/image_at_epoch_"</span> + str(epoch) + <span class="string">".png"</span>)</span><br><span class="line">    plt.show()</span><br></pre></td></tr></table></figure><h5 id="6、效果展示"><a href="#6、效果展示" class="headerlink" title="6、效果展示"></a>6、效果展示</h5><p>每次训练生成的数字效果图如下:</p><p><img src="/2019/12/27/cDCGAN生成指定手写数字--tensorflow2.0/image_at_epoch_3.png" alt=""></p><p>为了有个动态的直观感受，我们使用如下函数，将每轮训练由固定的 <code>noise</code> 生成的效果图做成一个 <code>gif</code> 图片。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">gif_animation_generate</span><span class="params">()</span>:</span></span><br><span class="line">    gif_name = <span class="string">"cdcgan_gif.gif"</span></span><br><span class="line">    filenames = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, <span class="number">81</span>):</span><br><span class="line">        filenames.append(<span class="string">"epoch_image/image_at_epoch_"</span> + str(i) + <span class="string">".png"</span>)</span><br><span class="line">    frames = []</span><br><span class="line">    <span class="keyword">for</span> filename <span class="keyword">in</span> filenames:</span><br><span class="line">        im = imageio.imread(filename)</span><br><span class="line">        frames.append(im)</span><br><span class="line">    imageio.mimsave(gif_name, frames, <span class="string">"GIF"</span>, duration=<span class="number">0.1</span>)</span><br></pre></td></tr></table></figure><p>最后的效果图：</p><p><img src="/2019/12/27/cDCGAN生成指定手写数字--tensorflow2.0/cdcgan_gif.gif" style="zoom:50%;"></p><p>全部代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># _*_ coding: utf-8 _*_</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">@author: Jibao Wang</span></span><br><span class="line"><span class="string">@time: 2019/12/27 10:29</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</span><br><span class="line"><span class="keyword">import</span> glob, imageio, os, time, PIL, random</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">from</span> tensorflow.keras <span class="keyword">import</span> layers</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建用于展示的 noise 向量和对应的 label，固定不变用来查看生成器的效果，每个类别 10 个 sample</span></span><br><span class="line">noise_image = tf.random.normal([<span class="number">10</span>, <span class="number">100</span>])</span><br><span class="line">noise_label = tf.zeros([<span class="number">10</span>])</span><br><span class="line"><span class="keyword">for</span> num <span class="keyword">in</span> range(<span class="number">1</span>, <span class="number">10</span>):</span><br><span class="line">    tmp_noise_image = tf.random.normal([<span class="number">10</span>, <span class="number">100</span>])</span><br><span class="line">    noise_image = tf.concat((noise_image, tmp_noise_image), axis=<span class="number">0</span>)</span><br><span class="line">    tmp_noise_label = tf.zeros([<span class="number">10</span>]) + num</span><br><span class="line">    noise_label = tf.concat((noise_label, tmp_noise_label), axis=<span class="number">0</span>)</span><br><span class="line">noise_label = np.eye(<span class="number">10</span>)[tf.cast(noise_label, tf.int32)].astype(<span class="string">"float32"</span>)</span><br><span class="line"><span class="comment"># noise_image--&gt;tensor([100, 100]),  noise_label--&gt;tensor([100, 10])</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建模型</span></span><br><span class="line"><span class="comment"># 定义生成器</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">make_generator_model</span><span class="params">()</span>:</span></span><br><span class="line">    model = tf.keras.Sequential()</span><br><span class="line">    model.add(layers.Dense(<span class="number">7</span>*<span class="number">7</span>*<span class="number">256</span>, use_bias=<span class="keyword">False</span>, input_shape=(<span class="number">110</span>,)))  <span class="comment"># 输入数据的维度为 100 + 10 = 110</span></span><br><span class="line">    model.add(layers.BatchNormalization())</span><br><span class="line">    model.add(layers.LeakyReLU())</span><br><span class="line">    model.add(layers.Reshape((<span class="number">7</span>, <span class="number">7</span>, <span class="number">256</span>)))</span><br><span class="line">    <span class="keyword">assert</span> model.output_shape == (<span class="keyword">None</span>, <span class="number">7</span>, <span class="number">7</span>, <span class="number">256</span>)</span><br><span class="line"></span><br><span class="line">    model.add(layers.Conv2DTranspose(filters=<span class="number">128</span>, kernel_size=(<span class="number">5</span>, <span class="number">5</span>), strides=(<span class="number">1</span>, <span class="number">1</span>), padding=<span class="string">'same'</span>, use_bias=<span class="keyword">False</span>)) <span class="comment"># 反卷积层</span></span><br><span class="line">    <span class="keyword">assert</span> model.output_shape == (<span class="keyword">None</span>, <span class="number">7</span>, <span class="number">7</span>, <span class="number">128</span>)</span><br><span class="line">    model.add(layers.BatchNormalization())</span><br><span class="line">    model.add(layers.LeakyReLU())</span><br><span class="line"></span><br><span class="line">    model.add(layers.Conv2DTranspose(filters=<span class="number">64</span>, kernel_size=(<span class="number">5</span>, <span class="number">5</span>), strides=(<span class="number">2</span>, <span class="number">2</span>), padding=<span class="string">'same'</span>, use_bias=<span class="keyword">False</span>))</span><br><span class="line">    <span class="keyword">assert</span> model.output_shape == (<span class="keyword">None</span>, <span class="number">14</span>, <span class="number">14</span>, <span class="number">64</span>)</span><br><span class="line">    model.add(layers.BatchNormalization())</span><br><span class="line">    model.add(layers.LeakyReLU())</span><br><span class="line"></span><br><span class="line">    model.add(layers.Conv2DTranspose(filters=<span class="number">1</span>, kernel_size=(<span class="number">5</span>, <span class="number">5</span>), strides=(<span class="number">2</span>, <span class="number">2</span>), padding=<span class="string">'same'</span>, use_bias=<span class="keyword">False</span>, activation=<span class="string">'tanh'</span>))</span><br><span class="line">    <span class="keyword">assert</span> model.output_shape == (<span class="keyword">None</span>, <span class="number">28</span>, <span class="number">28</span>, <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span> model</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义判别器</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">make_discriminator_model</span><span class="params">()</span>:</span></span><br><span class="line">    model = tf.keras.Sequential()</span><br><span class="line">    model.add(layers.Conv2D(filters=<span class="number">64</span>, kernel_size=(<span class="number">5</span>, <span class="number">5</span>), strides=(<span class="number">2</span>, <span class="number">2</span>), padding=<span class="string">'same'</span>, input_shape=[<span class="number">28</span>, <span class="number">28</span>, <span class="number">11</span>])) <span class="comment"># 维度为 1 + 10(label) = 11</span></span><br><span class="line">    model.add(layers.LeakyReLU())</span><br><span class="line">    model.add(layers.Dropout(rate=<span class="number">0.3</span>))</span><br><span class="line"></span><br><span class="line">    model.add(layers.Conv2D(filters=<span class="number">128</span>, kernel_size=(<span class="number">5</span>, <span class="number">5</span>), strides=(<span class="number">2</span>, <span class="number">2</span>), padding=<span class="string">'same'</span>))</span><br><span class="line">    model.add(layers.LeakyReLU())</span><br><span class="line">    model.add(layers.Dropout(rate=<span class="number">0.3</span>))</span><br><span class="line"></span><br><span class="line">    model.add(layers.Flatten())</span><br><span class="line">    model.add(layers.Dense(<span class="number">1</span>))   <span class="comment"># 真实图片输出 1，伪造的图片输出0</span></span><br><span class="line">    <span class="keyword">return</span> model</span><br><span class="line"></span><br><span class="line">cross_entropy = tf.keras.losses.BinaryCrossentropy(from_logits=<span class="keyword">True</span>)</span><br><span class="line"><span class="comment"># 定义判别器损失</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">discriminator_loss</span><span class="params">(real_output, fake_output)</span>:</span></span><br><span class="line">    real_loss = cross_entropy(tf.ones_like(real_output), real_output)</span><br><span class="line">    fake_loss = cross_entropy(tf.zeros_like(fake_output), fake_output)</span><br><span class="line">    total_loss = real_loss + fake_loss</span><br><span class="line">    <span class="keyword">return</span> total_loss</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义生成器损失</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">generator_loss</span><span class="params">(fake_output)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> cross_entropy(tf.ones_like(fake_output), fake_output)</span><br><span class="line"></span><br><span class="line">generator = make_generator_model()</span><br><span class="line">discriminator = make_discriminator_model()</span><br><span class="line"><span class="comment"># 定义优化器</span></span><br><span class="line">generator_optimizer = tf.keras.optimizers.Adam(<span class="number">1e-4</span>)</span><br><span class="line">discriminator_optimizer = tf.keras.optimizers.Adam(<span class="number">1e-4</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">@tf.function</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">train_step</span><span class="params">(images, labels)</span>:</span></span><br><span class="line">    step_noise = tf.random.normal([<span class="number">256</span>, <span class="number">100</span>])  <span class="comment"># 256 代表 batch 的大小</span></span><br><span class="line">    <span class="keyword">with</span> tf.GradientTape() <span class="keyword">as</span> gen_tape, tf.GradientTape() <span class="keyword">as</span> disc_tape:</span><br><span class="line">        generated_images = generator(tf.concat((step_noise, labels), axis=<span class="number">1</span>), training=<span class="keyword">True</span>)  <span class="comment"># [batch, 28, 28, 1]</span></span><br><span class="line"></span><br><span class="line">        labels = tf.reshape(labels, (<span class="number">256</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">10</span>)) * tf.ones((<span class="number">256</span>, <span class="number">28</span>, <span class="number">28</span>, <span class="number">10</span>))  <span class="comment"># [256, 28, 28, 10]</span></span><br><span class="line"></span><br><span class="line">        real_output = discriminator(tf.concat((images, labels), axis=<span class="number">3</span>), training=<span class="keyword">True</span>)  <span class="comment"># [256, 28, 28, 11]</span></span><br><span class="line">        fake_output = discriminator(tf.concat((generated_images, labels), axis=<span class="number">3</span>), training=<span class="keyword">True</span>) <span class="comment"># [256, 28, 28, 11]</span></span><br><span class="line">        gen_loss = generator_loss(fake_output)</span><br><span class="line">        disc_loss = discriminator_loss(real_output, fake_output)</span><br><span class="line">    gradients_of_generator = gen_tape.gradient(gen_loss, generator.trainable_variables)</span><br><span class="line">    gradients_of_discriminator = disc_tape.gradient(disc_loss, discriminator.trainable_variables)</span><br><span class="line">    generator_optimizer.apply_gradients(zip(gradients_of_generator,generator.trainable_variables))</span><br><span class="line">    discriminator_optimizer.apply_gradients(zip(gradients_of_discriminator, discriminator.trainable_variables))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 保存检查点</span></span><br><span class="line">checkpoint = tf.train.Checkpoint(generator_optimizer=generator_optimizer, discriminator_optimizer=discriminator_optimizer,</span><br><span class="line">                                 generator=generator, discriminator=discriminator)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">generate_and_save_images</span><span class="params">(model, epoch, input)</span>:</span></span><br><span class="line">    predictions = model(input, training=<span class="keyword">False</span>)</span><br><span class="line">    fig = plt.figure(figsize=(<span class="number">10</span>, <span class="number">10</span>))</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(predictions.shape[<span class="number">0</span>]):</span><br><span class="line">        plt.subplot(<span class="number">10</span>, <span class="number">10</span>, i+<span class="number">1</span>)</span><br><span class="line">        plt.imshow(predictions[i,:,:,<span class="number">0</span>]*<span class="number">127.5</span>+<span class="number">127.5</span>, cmap=<span class="string">'gray'</span>)  <span class="comment"># 与之前正好相反</span></span><br><span class="line">        plt.axis(<span class="string">'off'</span>)</span><br><span class="line">    plt.savefig(<span class="string">"epoch_image/image_at_epoch_"</span> + str(epoch) + <span class="string">".png"</span>)</span><br><span class="line">    plt.show()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">train</span><span class="params">(train_images, train_labels, epochs)</span>:</span> <span class="comment"># [70000, 28, 28, 1]  [70000, 10]</span></span><br><span class="line">    <span class="keyword">for</span> epoch <span class="keyword">in</span> range(epochs):</span><br><span class="line">        start = time.time()</span><br><span class="line">        <span class="comment"># 打乱训练数据</span></span><br><span class="line">        index = random.sample(range(<span class="number">0</span>, train_images.shape[<span class="number">0</span>]), train_images.shape[<span class="number">0</span>])</span><br><span class="line">        <span class="keyword">for</span> step <span class="keyword">in</span> range(train_images.shape[<span class="number">0</span>] // <span class="number">256</span>):</span><br><span class="line">            train_step(train_images[index[step*<span class="number">256</span>:(step+<span class="number">1</span>)*<span class="number">256</span>]], train_labels[index[step*<span class="number">256</span>:(step+<span class="number">1</span>)*<span class="number">256</span>]])</span><br><span class="line">        generate_and_save_images(generator, epoch+<span class="number">1</span>, tf.concat((noise_image, noise_label), axis=<span class="number">1</span>))</span><br><span class="line">        <span class="keyword">if</span> (epoch+<span class="number">1</span>) % <span class="number">20</span> == <span class="number">0</span>:</span><br><span class="line">            checkpoint.save(file_prefix=<span class="string">"training_checkpoints/cDCGAN"</span>)</span><br><span class="line">        print(<span class="string">"Time for "</span>, epoch, <span class="string">" epoch is: "</span>, time.time() - start)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 通过 imageio 生成训练过程动画</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">gif_animation_generate</span><span class="params">()</span>:</span></span><br><span class="line">    gif_name = <span class="string">"cdcgan_gif.gif"</span></span><br><span class="line">    filenames = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, <span class="number">81</span>):</span><br><span class="line">        filenames.append(<span class="string">"epoch_image/image_at_epoch_"</span> + str(i) + <span class="string">".png"</span>)</span><br><span class="line">    frames = []</span><br><span class="line">    <span class="keyword">for</span> filename <span class="keyword">in</span> filenames:</span><br><span class="line">        im = imageio.imread(filename)</span><br><span class="line">        frames.append(im)</span><br><span class="line">    imageio.mimsave(gif_name, frames, <span class="string">"GIF"</span>, duration=<span class="number">0.1</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    <span class="comment"># 加载数据，获得训练数据集</span></span><br><span class="line">    data = np.load(<span class="string">"dataset/mnist.npz"</span>)</span><br><span class="line">    train_images = np.concatenate((data[<span class="string">"x_train"</span>], data[<span class="string">"x_test"</span>]), axis=<span class="number">0</span>)  <span class="comment"># [70000, 28, 28]</span></span><br><span class="line">    train_images = train_images.reshape(train_images.shape[<span class="number">0</span>], <span class="number">28</span>, <span class="number">28</span>, <span class="number">1</span>).astype(<span class="string">"float32"</span>)  <span class="comment"># 增加一维[70000, 28, 28, 1]</span></span><br><span class="line">    train_images = (train_images - <span class="number">127.5</span>) / <span class="number">127.5</span>  <span class="comment"># 像素值标准化到 [-1, 1] 之间</span></span><br><span class="line">    train_labels = np.concatenate((data[<span class="string">"y_train"</span>], data[<span class="string">"y_test"</span>]), axis=<span class="number">0</span>)  <span class="comment"># [70000, ]</span></span><br><span class="line">    train_labels = np.eye(<span class="number">10</span>)[tf.cast(train_labels, tf.int32)].astype(<span class="string">"float32"</span>)  <span class="comment"># [70000, 10]</span></span><br><span class="line">    train(train_images, train_labels, epochs=<span class="number">80</span>)</span><br><span class="line"></span><br><span class="line">    gif_animation_generate()</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;接上一篇&lt;code&gt;DCGAN手写数字生成&lt;/code&gt;，虽然它能够生成效果不错的手写数字图片，但它有一个缺点就是不能生成指定数值的数字，好在有一种 &lt;code&gt;GAN&lt;/code&gt; 模型叫 &lt;code&gt;cGAN&lt;/code&gt;，即 &lt;code&gt;Conditional Generative Adversarial Nets&lt;/code&gt;， 出自 &lt;a href=&quot;https://arxiv.org/abs/1411.1784&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;此篇论文&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;模型结构如下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/2019/12/27/cDCGAN生成指定手写数字--tensorflow2.0/cdcgan_model.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;其损失函数定义：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/2019/12/27/cDCGAN生成指定手写数字--tensorflow2.0/loss_function.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="笔记" scheme="https://wangjibao.com.cn/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="笔记" scheme="https://wangjibao.com.cn/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>DCGAN手写数字生成--tensorflow2.0</title>
    <link href="https://wangjibao.com.cn/2019/12/27/DCGAN%E6%89%8B%E5%86%99%E6%95%B0%E5%AD%97%E7%94%9F%E6%88%90--tensorflow2.0/"/>
    <id>https://wangjibao.com.cn/2019/12/27/DCGAN手写数字生成--tensorflow2.0/</id>
    <published>2019-12-27T06:16:12.000Z</published>
    <updated>2019-12-30T09:05:38.129Z</updated>
    
    <content type="html"><![CDATA[<p>最近忙里偷闲，补一发之前落下的关于一些<code>GAN</code>的<code>tensorflow2.0</code>实现代码。</p><p>首先，<code>GAN</code> ，即生成对抗网络<code>Generative Adversarial Network</code>，由一个生成器<code>Generator</code>和一个判别器<code>Discriminator</code>组成，两者属于 <strong>零和博弈</strong> 的双方，不是你死就是我亡的状态。</p><p>其损失函数一般定义如下：</p><p><img src="/2019/12/27/DCGAN手写数字生成--tensorflow2.0/gan_loss.png" alt=""></p><p>判别器 <code>D</code> 对来自真实数据集的样本 $x\sim p_{data}$ 要输出大概率，越接近 <code>1</code> 越好；对来自生成器生成的样本$z\sim p_z$ 要输出小概率，越接近 <code>0</code> 越好。当然，这是一个零和博弈，对于生成器<code>G</code>来说，其目标与<code>D</code>截然相反，他想使自己生成的样本不能被<code>D</code>识别出来。这么不断的你来我往，双方各自不断调优，最后达成一个平衡状态。</p><p>当然，这其中的损失函数也不只这一种，比如说，生成器的损失函数可以定义为：生成样本分布与真实样本分布的 <code>KL</code> 散度值等。</p><blockquote><p>KL 散度用来衡量两个分布之间的相似性。</p></blockquote><a id="more"></a><p>接下来，我们用很熟悉的 <code>MNIST</code> 的数据集，来实现一个简单的 <code>DCGAN</code> 模型<code>Deep Convolutional Generative Adversarial Networks</code>。该模型由此 <a href="https://arxiv.org/abs/1511.06434" target="_blank" rel="noopener">论文</a> 提出。其实就是生成器和判别器用深度卷积来实现的。话不多说，上代码：</p><h5 id="1、加载数据"><a href="#1、加载数据" class="headerlink" title="1、加载数据"></a>1、加载数据</h5><p><code>MNIST</code>数据集有很多种格式，这里我们使用的是 <code>npz</code> 格式，用 <code>numpy</code>直接解析就可以了。将训练集和测试集联合起来，一起喂入模型进行训练，<code>label</code>用不到，就直接舍弃掉得了。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">data = np.load(<span class="string">"dataset/mnist.npz"</span>)</span><br><span class="line">train_images = np.concatenate((data[<span class="string">"x_train"</span>], data[<span class="string">"x_test"</span>]), axis=<span class="number">0</span>)<span class="comment">#[70000,28,28]</span></span><br><span class="line"><span class="comment"># 增加一维[70000, 28, 28, 1]</span></span><br><span class="line">train_images = train_images.reshape(train_images.shape[<span class="number">0</span>], <span class="number">28</span>, <span class="number">28</span>,<span class="number">1</span>).astype(<span class="string">"float32"</span>) </span><br><span class="line">train_images = (train_images - <span class="number">127.5</span>) / <span class="number">127.5</span>  <span class="comment"># 像素值标准化到 [-1, 1] 之间</span></span><br></pre></td></tr></table></figure><h5 id="2、定义生成器"><a href="#2、定义生成器" class="headerlink" title="2、定义生成器"></a>2、定义生成器</h5><p>生成器要做的就是将一个 <code>100</code> 维的随机噪声向量，变换成一个 <code>28*28</code> 的黑白数字图片。用到的是一个全连接层 +  3个反卷积层。</p><p>反卷积的具体操作过程见 <a href="https://zhuanlan.zhihu.com/p/48501100" target="_blank" rel="noopener">知乎博文</a> ，其实就是根据 <code>stride</code> 的值先填充(包括矩阵的左侧和上侧)，然后再做步长为 <code>1</code> 的正向卷积。<strong>反卷积只能恢复尺寸，不能恢复数值。</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">make_generator_model</span><span class="params">()</span>:</span></span><br><span class="line">    model = tf.keras.Sequential()</span><br><span class="line">    model.add(layers.Dense(<span class="number">7</span>*<span class="number">7</span>*<span class="number">256</span>, use_bias=<span class="keyword">False</span>, input_shape=(<span class="number">100</span>,)))</span><br><span class="line">    model.add(layers.BatchNormalization())</span><br><span class="line">    model.add(layers.LeakyReLU())</span><br><span class="line">    model.add(layers.Reshape((<span class="number">7</span>, <span class="number">7</span>, <span class="number">256</span>)))</span><br><span class="line">    <span class="keyword">assert</span> model.output_shape == (<span class="keyword">None</span>, <span class="number">7</span>, <span class="number">7</span>, <span class="number">256</span>)</span><br><span class="line"></span><br><span class="line">    model.add(layers.Conv2DTranspose(filters=<span class="number">128</span>, kernel_size=(<span class="number">5</span>, <span class="number">5</span>), strides=(<span class="number">1</span>, <span class="number">1</span>), padding=<span class="string">'same'</span>, use_bias=<span class="keyword">False</span>)) <span class="comment"># 反卷积层</span></span><br><span class="line">    <span class="keyword">assert</span> model.output_shape == (<span class="keyword">None</span>, <span class="number">7</span>, <span class="number">7</span>, <span class="number">128</span>)</span><br><span class="line">    model.add(layers.BatchNormalization())</span><br><span class="line">    model.add(layers.LeakyReLU())</span><br><span class="line"></span><br><span class="line">    model.add(layers.Conv2DTranspose(filters=<span class="number">64</span>, kernel_size=(<span class="number">5</span>, <span class="number">5</span>), strides=(<span class="number">2</span>, <span class="number">2</span>), padding=<span class="string">'same'</span>, use_bias=<span class="keyword">False</span>))</span><br><span class="line">    <span class="keyword">assert</span> model.output_shape == (<span class="keyword">None</span>, <span class="number">14</span>, <span class="number">14</span>, <span class="number">64</span>)</span><br><span class="line">    model.add(layers.BatchNormalization())</span><br><span class="line">    model.add(layers.LeakyReLU())</span><br><span class="line"></span><br><span class="line">    model.add(layers.Conv2DTranspose(filters=<span class="number">1</span>, kernel_size=(<span class="number">5</span>, <span class="number">5</span>), strides=(<span class="number">2</span>, <span class="number">2</span>), padding=<span class="string">'same'</span>, use_bias=<span class="keyword">False</span>, activation=<span class="string">'tanh'</span>))</span><br><span class="line">    <span class="keyword">assert</span> model.output_shape == (<span class="keyword">None</span>, <span class="number">28</span>, <span class="number">28</span>, <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span> model</span><br></pre></td></tr></table></figure><h5 id="3、定义判别器"><a href="#3、定义判别器" class="headerlink" title="3、定义判别器"></a>3、定义判别器</h5><p>判别器要做的就是对来自真实数据集中的样本输出大概率，对来自生成器的样本输出小概率值。包含两个卷积层和1个全连接层。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">make_discriminator_model</span><span class="params">()</span>:</span></span><br><span class="line">    model = tf.keras.Sequential()</span><br><span class="line">    model.add(layers.Conv2D(filters=<span class="number">64</span>, kernel_size=(<span class="number">5</span>, <span class="number">5</span>), strides=(<span class="number">2</span>, <span class="number">2</span>), padding=<span class="string">'same'</span>, input_shape=[<span class="number">28</span>, <span class="number">28</span>, <span class="number">1</span>]))</span><br><span class="line">    model.add(layers.LeakyReLU())</span><br><span class="line">    model.add(layers.Dropout(rate=<span class="number">0.3</span>))</span><br><span class="line"></span><br><span class="line">    model.add(layers.Conv2D(filters=<span class="number">128</span>, kernel_size=(<span class="number">5</span>, <span class="number">5</span>), strides=(<span class="number">2</span>, <span class="number">2</span>), padding=<span class="string">'same'</span>))</span><br><span class="line">    model.add(layers.LeakyReLU())</span><br><span class="line">    model.add(layers.Dropout(rate=<span class="number">0.3</span>))</span><br><span class="line"></span><br><span class="line">    model.add(layers.Flatten())</span><br><span class="line">    model.add(layers.Dense(<span class="number">1</span>))   <span class="comment"># 真实图片输出 1，伪造的图片输出0</span></span><br><span class="line">    <span class="keyword">return</span> model</span><br></pre></td></tr></table></figure><h5 id="4、定义生成器和判别器的损失函数"><a href="#4、定义生成器和判别器的损失函数" class="headerlink" title="4、定义生成器和判别器的损失函数"></a>4、定义生成器和判别器的损失函数</h5><p>其中，生成器损失函数要对<code>fake_output</code>的判别输出与全 <code>1</code> 矩阵做交叉熵，与判别器要做的正好相反。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">cross_entropy = tf.keras.losses.BinaryCrossentropy(from_logits=<span class="keyword">True</span>)</span><br><span class="line"><span class="comment"># 判别器损失</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">discriminator_loss</span><span class="params">(real_output, fake_output)</span>:</span></span><br><span class="line">    real_loss = cross_entropy(tf.ones_like(real_output), real_output)</span><br><span class="line">    fake_loss = cross_entropy(tf.zeros_like(fake_output), fake_output)</span><br><span class="line">    total_loss = real_loss + fake_loss</span><br><span class="line">    <span class="keyword">return</span> total_loss</span><br><span class="line"><span class="comment"># 生成器损失</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">generator_loss</span><span class="params">(fake_output)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> cross_entropy(tf.ones_like(fake_output), fake_output)</span><br></pre></td></tr></table></figure><h5 id="5、定义优化器及训练过程"><a href="#5、定义优化器及训练过程" class="headerlink" title="5、定义优化器及训练过程"></a>5、定义优化器及训练过程</h5><p>在训练过程中，每次生成一个维度为 <code>[256, 100]</code> 的随机噪声矩阵，喂入 <code>generator</code> 生成 <code>fake_image</code>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 实例化 generator 和 discriminator</span></span><br><span class="line">generator = make_generator_model()</span><br><span class="line">discriminator = make_discriminator_model()</span><br><span class="line"><span class="comment"># 定义判别器和生成器的优化器</span></span><br><span class="line">generator_optimizer = tf.keras.optimizers.Adam(<span class="number">1e-4</span>)</span><br><span class="line">discriminator_optimizer = tf.keras.optimizers.Adam(<span class="number">1e-4</span>)</span><br><span class="line"><span class="comment"># @tf.functio 在这里是为了加速训练，具体作用及用法，google一下</span></span><br><span class="line"><span class="meta">@tf.function</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">train_step</span><span class="params">(images)</span>:</span></span><br><span class="line">    noise = tf.random.normal([<span class="number">256</span>, <span class="number">100</span>])</span><br><span class="line">    <span class="keyword">with</span> tf.GradientTape() <span class="keyword">as</span> gen_tape, tf.GradientTape() <span class="keyword">as</span> disc_tape:</span><br><span class="line">        generated_images = generator(noise, training=<span class="keyword">True</span>)</span><br><span class="line">        </span><br><span class="line">        real_output = discriminator(images, training=<span class="keyword">True</span>)</span><br><span class="line">        fake_output = discriminator(generated_images, training=<span class="keyword">True</span>)</span><br><span class="line">        </span><br><span class="line">        gen_loss = generator_loss(fake_output)</span><br><span class="line">        disc_loss = discriminator_loss(real_output, fake_output)</span><br><span class="line">        </span><br><span class="line">    gradients_of_generator = gen_tape.gradient(gen_loss, generator.trainable_variables)</span><br><span class="line">    gradients_of_discriminator = disc_tape.gradient(disc_loss, discriminator.trainable_variables)</span><br><span class="line">    generator_optimizer.apply_gradients(zip(gradients_of_generator,generator.trainable_variables))</span><br><span class="line">    discriminator_optimizer.apply_gradients(zip(gradients_of_discriminator, discriminator.trainable_variables))</span><br></pre></td></tr></table></figure><h5 id="6、开始训练"><a href="#6、开始训练" class="headerlink" title="6、开始训练"></a>6、开始训练</h5><p><code>checkpoint</code> 定义要保存的模型对象，这里保存了生成器，判别器及两者各自的优化器，每 15 轮保存一次。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">seed = tf.random.normal([<span class="number">16</span>, <span class="number">100</span>])  <span class="comment"># 查看生成器效果用的</span></span><br><span class="line"><span class="comment"># 定义训练过程汇总要保存的对象</span></span><br><span class="line">checkpoint = tf.train.Checkpoint(generator_optimizer=generator_optimizer, discriminator_optimizer=discriminator_optimizer, generator=generator, discriminator=discriminator)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">train</span><span class="params">(dataset, epochs)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> epoch <span class="keyword">in</span> range(epochs):</span><br><span class="line">        start = time.time()</span><br><span class="line">        <span class="keyword">for</span> image_batch <span class="keyword">in</span> dataset:</span><br><span class="line">            train_step(image_batch)</span><br><span class="line">        generate_and_save_images(generator, epoch+<span class="number">1</span>, seed)</span><br><span class="line">        <span class="keyword">if</span> (epoch+<span class="number">1</span>) % <span class="number">15</span> == <span class="number">0</span>:</span><br><span class="line">            checkpoint.save(file_prefix=<span class="string">"training_checkpoints/dcgan"</span>)</span><br><span class="line">        print(<span class="string">"Time for"</span>, epoch, <span class="string">"epoch is: "</span>, time.time() - start)</span><br></pre></td></tr></table></figure><p>每个 <code>epoch</code> 训练结束，我们使用一个固定的 <code>seed(256*100)</code>来查看生成器的生成数字的效果，其查看效果函数定义如下，就是将<code>seed</code>喂入生成器，将生成的数字图片画出来：</p> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">generate_and_save_images</span><span class="params">(model, epoch, input)</span>:</span></span><br><span class="line">    predictions = model(input, training=<span class="keyword">False</span>)</span><br><span class="line">    fig = plt.figure(figsize=(<span class="number">4</span>, <span class="number">4</span>))</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(predictions.shape[<span class="number">0</span>]):</span><br><span class="line">        plt.subplot(<span class="number">4</span>, <span class="number">4</span>, i+<span class="number">1</span>)</span><br><span class="line">        plt.imshow(predictions[i,:,:,<span class="number">0</span>]*<span class="number">127.5</span>+<span class="number">127.5</span>, cmap=<span class="string">'gray'</span>)</span><br><span class="line">        plt.axis(<span class="string">'off'</span>)</span><br><span class="line">    plt.savefig(<span class="string">"dcgan_image_save/epoch_"</span> + str(epoch) + <span class="string">".png"</span>)</span><br><span class="line">    plt.show()</span><br></pre></td></tr></table></figure><h5 id="5、效果展示"><a href="#5、效果展示" class="headerlink" title="5、效果展示"></a>5、效果展示</h5><p>每次训练生成的数字效果图如下:</p><p><img src="/2019/12/27/DCGAN手写数字生成--tensorflow2.0/epoch_1.png" alt=""></p><p>为了有个动态的直观感受，我们使用如下函数，将每轮训练保存的效果图片生成一个 <code>gif</code> 图片。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">gif_animation_generate</span><span class="params">()</span>:</span></span><br><span class="line">    gif_name = <span class="string">"dcgan_gif.gif"</span></span><br><span class="line">    filenames = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, <span class="number">61</span>):</span><br><span class="line">        filenames.append(<span class="string">"dcgan_image_save/epoch_"</span> + str(i) + <span class="string">".png"</span>)</span><br><span class="line">    frames = []</span><br><span class="line">    <span class="keyword">for</span> filename <span class="keyword">in</span> filenames:</span><br><span class="line">        im = imageio.imread(filename)</span><br><span class="line">        frames.append(im)</span><br><span class="line">    imageio.mimsave(gif_name, frames, <span class="string">"GIF"</span>, duration=<span class="number">0.1</span>)</span><br></pre></td></tr></table></figure><p>最后的效果图：</p><p><img src="/2019/12/27/DCGAN手写数字生成--tensorflow2.0/dcgan_gif.gif" alt=""></p><p>全部代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># _*_ coding: utf-8 _*_</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">@author: Jibao Wang</span></span><br><span class="line"><span class="string">@time: 2019/12/23 19:23</span></span><br><span class="line"><span class="string">使用 深度卷积生成对抗网络 生成手写数字 MNIST</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</span><br><span class="line"><span class="keyword">import</span> glob, imageio, os, time, PIL</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">from</span> tensorflow.keras <span class="keyword">import</span> layers</span><br><span class="line"></span><br><span class="line"><span class="comment"># 加载数据，获得训练数据集</span></span><br><span class="line">(train_images, train_labels), (_, _) = tf.keras.datasets.mnist.load_data() <span class="comment"># 返回 numpy,[60000,28,28]  [60000]</span></span><br><span class="line">train_images = train_images.reshape(train_images.shape[<span class="number">0</span>], <span class="number">28</span>, <span class="number">28</span>, <span class="number">1</span>).astype(<span class="string">"float32"</span>)  <span class="comment"># 增加一维</span></span><br><span class="line">train_images = (train_images - <span class="number">127.5</span>) / <span class="number">127.5</span>  <span class="comment"># 像素值标准化到 [-1, 1] 之间</span></span><br><span class="line"><span class="comment"># 批量化和打乱数据, 每个 batch 的维度是 [256, 28, 28, 1], 最后一个 batch 的维度是 [96, 28, 28, 1]</span></span><br><span class="line">train_dataset = tf.data.Dataset.from_tensor_slices(train_images).shuffle(train_images.shape[<span class="number">0</span>]).batch(batch_size=<span class="number">256</span>, drop_remainder=<span class="keyword">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建模型</span></span><br><span class="line"><span class="comment"># 定义生成器</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">make_generator_model</span><span class="params">()</span>:</span></span><br><span class="line">    model = tf.keras.Sequential()</span><br><span class="line">    model.add(layers.Dense(<span class="number">7</span>*<span class="number">7</span>*<span class="number">256</span>, use_bias=<span class="keyword">False</span>, input_shape=(<span class="number">100</span>,)))</span><br><span class="line">    model.add(layers.BatchNormalization())</span><br><span class="line">    model.add(layers.LeakyReLU())</span><br><span class="line">    model.add(layers.Reshape((<span class="number">7</span>, <span class="number">7</span>, <span class="number">256</span>)))</span><br><span class="line">    <span class="keyword">assert</span> model.output_shape == (<span class="keyword">None</span>, <span class="number">7</span>, <span class="number">7</span>, <span class="number">256</span>)</span><br><span class="line"></span><br><span class="line">    model.add(layers.Conv2DTranspose(filters=<span class="number">128</span>, kernel_size=(<span class="number">5</span>, <span class="number">5</span>), strides=(<span class="number">1</span>, <span class="number">1</span>), padding=<span class="string">'same'</span>, use_bias=<span class="keyword">False</span>)) <span class="comment"># 反卷积层</span></span><br><span class="line">    <span class="keyword">assert</span> model.output_shape == (<span class="keyword">None</span>, <span class="number">7</span>, <span class="number">7</span>, <span class="number">128</span>)</span><br><span class="line">    model.add(layers.BatchNormalization())</span><br><span class="line">    model.add(layers.LeakyReLU())</span><br><span class="line"></span><br><span class="line">    model.add(layers.Conv2DTranspose(filters=<span class="number">64</span>, kernel_size=(<span class="number">5</span>, <span class="number">5</span>), strides=(<span class="number">2</span>, <span class="number">2</span>), padding=<span class="string">'same'</span>, use_bias=<span class="keyword">False</span>))</span><br><span class="line">    <span class="keyword">assert</span> model.output_shape == (<span class="keyword">None</span>, <span class="number">14</span>, <span class="number">14</span>, <span class="number">64</span>)</span><br><span class="line">    model.add(layers.BatchNormalization())</span><br><span class="line">    model.add(layers.LeakyReLU())</span><br><span class="line"></span><br><span class="line">    model.add(layers.Conv2DTranspose(filters=<span class="number">1</span>, kernel_size=(<span class="number">5</span>, <span class="number">5</span>), strides=(<span class="number">2</span>, <span class="number">2</span>), padding=<span class="string">'same'</span>, use_bias=<span class="keyword">False</span>, activation=<span class="string">'tanh'</span>))</span><br><span class="line">    <span class="keyword">assert</span> model.output_shape == (<span class="keyword">None</span>, <span class="number">28</span>, <span class="number">28</span>, <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span> model</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义判别器</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">make_discriminator_model</span><span class="params">()</span>:</span></span><br><span class="line">    model = tf.keras.Sequential()</span><br><span class="line">    model.add(layers.Conv2D(filters=<span class="number">64</span>, kernel_size=(<span class="number">5</span>, <span class="number">5</span>), strides=(<span class="number">2</span>, <span class="number">2</span>), padding=<span class="string">'same'</span>, input_shape=[<span class="number">28</span>, <span class="number">28</span>, <span class="number">1</span>]))</span><br><span class="line">    model.add(layers.LeakyReLU())</span><br><span class="line">    model.add(layers.Dropout(rate=<span class="number">0.3</span>))</span><br><span class="line"></span><br><span class="line">    model.add(layers.Conv2D(filters=<span class="number">128</span>, kernel_size=(<span class="number">5</span>, <span class="number">5</span>), strides=(<span class="number">2</span>, <span class="number">2</span>), padding=<span class="string">'same'</span>))</span><br><span class="line">    model.add(layers.LeakyReLU())</span><br><span class="line">    model.add(layers.Dropout(rate=<span class="number">0.3</span>))</span><br><span class="line"></span><br><span class="line">    model.add(layers.Flatten())</span><br><span class="line">    model.add(layers.Dense(<span class="number">1</span>))   <span class="comment"># 真实图片输出 1，伪造的图片输出0</span></span><br><span class="line">    <span class="keyword">return</span> model</span><br><span class="line"></span><br><span class="line">cross_entropy = tf.keras.losses.BinaryCrossentropy(from_logits=<span class="keyword">True</span>)  <span class="comment"># 类的对象</span></span><br><span class="line"><span class="comment"># 定义判别器损失</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">discriminator_loss</span><span class="params">(real_output, fake_output)</span>:</span></span><br><span class="line">    real_loss = cross_entropy(tf.ones_like(real_output), real_output)</span><br><span class="line">    fake_loss = cross_entropy(tf.zeros_like(fake_output), fake_output)</span><br><span class="line">    total_loss = real_loss + fake_loss</span><br><span class="line">    <span class="keyword">return</span> total_loss</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义生成器损失</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">generator_loss</span><span class="params">(fake_output)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> cross_entropy(tf.ones_like(fake_output), fake_output)</span><br><span class="line"></span><br><span class="line">generator = make_generator_model()</span><br><span class="line">discriminator = make_discriminator_model()</span><br><span class="line"><span class="comment"># 定义优化器</span></span><br><span class="line">generator_optimizer = tf.keras.optimizers.Adam(<span class="number">1e-4</span>)</span><br><span class="line">discriminator_optimizer = tf.keras.optimizers.Adam(<span class="number">1e-4</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">@tf.function</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">train_step</span><span class="params">(images)</span>:</span></span><br><span class="line">    noise = tf.random.normal([<span class="number">256</span>, <span class="number">100</span>])</span><br><span class="line">    <span class="keyword">with</span> tf.GradientTape() <span class="keyword">as</span> gen_tape, tf.GradientTape() <span class="keyword">as</span> disc_tape:</span><br><span class="line">        generated_images = generator(noise, training=<span class="keyword">True</span>)</span><br><span class="line"></span><br><span class="line">        real_output = discriminator(images, training=<span class="keyword">True</span>)</span><br><span class="line">        fake_output = discriminator(generated_images, training=<span class="keyword">True</span>)</span><br><span class="line">        gen_loss = generator_loss(fake_output)</span><br><span class="line">        disc_loss = discriminator_loss(real_output, fake_output)</span><br><span class="line">    gradients_of_generator = gen_tape.gradient(gen_loss, generator.trainable_variables)</span><br><span class="line">    gradients_of_discriminator = disc_tape.gradient(disc_loss, discriminator.trainable_variables)</span><br><span class="line">    generator_optimizer.apply_gradients(zip(gradients_of_generator,generator.trainable_variables))</span><br><span class="line">    discriminator_optimizer.apply_gradients(zip(gradients_of_discriminator, discriminator.trainable_variables))</span><br><span class="line"></span><br><span class="line">seed = tf.random.normal([<span class="number">16</span>, <span class="number">100</span>])  <span class="comment"># 查看生成器效果用的</span></span><br><span class="line"><span class="comment"># 保存检查点</span></span><br><span class="line">checkpoint = tf.train.Checkpoint(generator_optimizer=generator_optimizer, discriminator_optimizer=discriminator_optimizer, generator=generator, discriminator=discriminator)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">generate_and_save_images</span><span class="params">(model, epoch, input)</span>:</span></span><br><span class="line">    predictions = model(input, training=<span class="keyword">False</span>)</span><br><span class="line">    fig = plt.figure(figsize=(<span class="number">4</span>, <span class="number">4</span>))</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(predictions.shape[<span class="number">0</span>]):</span><br><span class="line">        plt.subplot(<span class="number">4</span>, <span class="number">4</span>, i+<span class="number">1</span>)</span><br><span class="line">        plt.imshow(predictions[i,:,:,<span class="number">0</span>]*<span class="number">127.5</span>+<span class="number">127.5</span>, cmap=<span class="string">'gray'</span>)</span><br><span class="line">        plt.axis(<span class="string">'off'</span>)</span><br><span class="line">    plt.savefig(<span class="string">"dcgan_image_save/epoch_"</span> + str(epoch) + <span class="string">".png"</span>)</span><br><span class="line">    plt.show()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">train</span><span class="params">(dataset, epochs)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> epoch <span class="keyword">in</span> range(epochs):</span><br><span class="line">        start = time.time()</span><br><span class="line">        <span class="keyword">for</span> image_batch <span class="keyword">in</span> dataset:</span><br><span class="line">            train_step(image_batch)</span><br><span class="line">        generate_and_save_images(generator, epoch+<span class="number">1</span>, seed)</span><br><span class="line">        <span class="keyword">if</span> (epoch+<span class="number">1</span>) % <span class="number">15</span> == <span class="number">0</span>:</span><br><span class="line">            checkpoint.save(file_prefix=<span class="string">"training_checkpoints/dcgan"</span>)</span><br><span class="line">        print(<span class="string">"Time for"</span>, epoch, <span class="string">"epoch is: "</span>, time.time() - start)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 通过 imageio 生成训练过程动画</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">gif_animation_generate</span><span class="params">()</span>:</span></span><br><span class="line">    gif_name = <span class="string">"dcgan_gif.gif"</span></span><br><span class="line">    filenames = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, <span class="number">61</span>):</span><br><span class="line">        filenames.append(<span class="string">"dcgan_image_save/epoch_"</span> + str(i) + <span class="string">".png"</span>)</span><br><span class="line">    frames = []</span><br><span class="line">    <span class="keyword">for</span> filename <span class="keyword">in</span> filenames:</span><br><span class="line">        im = imageio.imread(filename)</span><br><span class="line">        frames.append(im)</span><br><span class="line">    imageio.mimsave(gif_name, frames, <span class="string">"GIF"</span>, duration=<span class="number">0.1</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    train(dataset=train_dataset, epochs=<span class="number">60</span>)</span><br><span class="line">    gif_animation_generate()</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近忙里偷闲，补一发之前落下的关于一些&lt;code&gt;GAN&lt;/code&gt;的&lt;code&gt;tensorflow2.0&lt;/code&gt;实现代码。&lt;/p&gt;
&lt;p&gt;首先，&lt;code&gt;GAN&lt;/code&gt; ，即生成对抗网络&lt;code&gt;Generative Adversarial Network&lt;/code&gt;，由一个生成器&lt;code&gt;Generator&lt;/code&gt;和一个判别器&lt;code&gt;Discriminator&lt;/code&gt;组成，两者属于 &lt;strong&gt;零和博弈&lt;/strong&gt; 的双方，不是你死就是我亡的状态。&lt;/p&gt;
&lt;p&gt;其损失函数一般定义如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/2019/12/27/DCGAN手写数字生成--tensorflow2.0/gan_loss.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;判别器 &lt;code&gt;D&lt;/code&gt; 对来自真实数据集的样本 $x\sim p_{data}$ 要输出大概率，越接近 &lt;code&gt;1&lt;/code&gt; 越好；对来自生成器生成的样本$z\sim p_z$ 要输出小概率，越接近 &lt;code&gt;0&lt;/code&gt; 越好。当然，这是一个零和博弈，对于生成器&lt;code&gt;G&lt;/code&gt;来说，其目标与&lt;code&gt;D&lt;/code&gt;截然相反，他想使自己生成的样本不能被&lt;code&gt;D&lt;/code&gt;识别出来。这么不断的你来我往，双方各自不断调优，最后达成一个平衡状态。&lt;/p&gt;
&lt;p&gt;当然，这其中的损失函数也不只这一种，比如说，生成器的损失函数可以定义为：生成样本分布与真实样本分布的 &lt;code&gt;KL&lt;/code&gt; 散度值等。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;KL 散度用来衡量两个分布之间的相似性。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="笔记" scheme="https://wangjibao.com.cn/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="笔记" scheme="https://wangjibao.com.cn/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>v2ray+websocket+TLS通过cloudflare转发防IP被ban</title>
    <link href="https://wangjibao.com.cn/2019/12/17/v2ray-websocket-TLS%E9%80%9A%E8%BF%87cloudflare%E8%BD%AC%E5%8F%91%E9%98%B2IP%E8%A2%ABban/"/>
    <id>https://wangjibao.com.cn/2019/12/17/v2ray-websocket-TLS通过cloudflare转发防IP被ban/</id>
    <published>2019-12-17T01:56:26.000Z</published>
    <updated>2019-12-30T08:44:09.075Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h3><p>天朝 <code>qiang</code> 越垒越高，买的境外的服务器用时间长了经常会出现 <code>IP</code> 被 <code>ban</code> 的情况，本教程通过 <code>v2ray+websocket(ws)+TLS</code> 将流量伪装成 <code>TLS</code> 流量，即将自己的境外转发服务器伪装成一个网站，并通过 <code>cloudflare</code> 中转，网络流量流经图如下：</p><p><img src="/2019/12/17/v2ray-websocket-TLS通过cloudflare转发防IP被ban/cdn_cloudflare.png" alt=""></p><p>这样的话，防火墙就只知道你和 <code>CDN</code> 之间建立了连接，不知道你的 <code>vps</code> 实际的 <code>IP</code> 地址，这样就可以有效的防止你的 <code>IP</code> 被 <code>ban</code>，并且  <code>CDN</code> 会有很多 <code>IP</code> 地址，防火墙也不会随意去 <code>ban</code> 他们的 <code>IP</code>，毕竟也有很多正规的网站在使用，所以基本上可以确保你的 <code>IP</code> 的安全。</p><a id="more"></a><h3 id="二、步骤"><a href="#二、步骤" class="headerlink" title="二、步骤"></a>二、步骤</h3><h4 id="1、购买域名并使用cloudflare进行域名解析"><a href="#1、购买域名并使用cloudflare进行域名解析" class="headerlink" title="1、购买域名并使用cloudflare进行域名解析"></a>1、购买域名并使用<code>cloudflare</code>进行域名解析</h4><p>首先，购买一个域名，我购买的是阿里云的域名，当然也有很多可以免费使用的域名，登录阿里云官网，可以对域名解析进行设置。</p><p>之后，注册一个<code>cloudflare</code>账号，在首页输入自己购买的域名，它会给你分配两个 <code>cloudflare</code> 的 <code>authoritative DNS servers</code> ，具体如下图：</p><p><img src="/2019/12/17/v2ray-websocket-TLS通过cloudflare转发防IP被ban/cloudflare_index.png" alt=""></p><p><img src="/2019/12/17/v2ray-websocket-TLS通过cloudflare转发防IP被ban/nameservers.png" alt=""></p><p>一切注册搞好之后，现在要做的就是将阿里云上买的域名的权威解析<code>DNS</code>服务器改成<code>cloudflare</code> 的权威域名解析服务器。一开始是：<code>dns19.hichina.com</code> 和 <code>dns20.hichina.com</code>，改好之后，如下图：</p><p><img src="/2019/12/17/v2ray-websocket-TLS通过cloudflare转发防IP被ban/aliyun_dns.png" alt=""></p><p>现在，回到 <code>cloudflare</code> 的域名管理界面，添加域名解析。比如说，添加<code>A</code> 记录，将三级域名<code>v2ray</code> (即<code>v2ray.wangjibao.com.cn</code>) 解析到自己的 <code>VPS</code> 的 <code>IP</code> 上，如下图：</p><p><img src="/2019/12/17/v2ray-websocket-TLS通过cloudflare转发防IP被ban/dns_reslover.png" alt=""></p><p>注意，先不要点亮红色框里的云朵，保持灰色，代表该域名先不走<code>cloudflare</code> 的代理，暂时只用其进行<code>域名--&gt;IP</code>的解析。</p><h4 id="2、VPS搭建v2ray-服务"><a href="#2、VPS搭建v2ray-服务" class="headerlink" title="2、VPS搭建v2ray 服务"></a>2、<code>VPS</code>搭建<code>v2ray</code> 服务</h4><p>已经有大神写好了安装脚本，只需要进行傻瓜安装即可，具体的原理知识请移步<code>v2ray</code> 的<a href="https://www.v2ray.com/" target="_blank" rel="noopener">官网</a>学习，包括支持的协议，配置文件的编写等等。</p><p>执行如下命令进行安装：<code>bash &lt;(curl -s -L https://git.io/v2ray.sh)</code></p><p>这里传输协议选择 <code>websocket+TLS (4)</code>，然后根据提示信息一路输入并默认即可，输 <code>v2ray</code>端口、输入域名<code>v2ray.wangjibao.com.cn</code>，如下图：</p><p><img src="/2019/12/17/v2ray-websocket-TLS通过cloudflare转发防IP被ban/v2ray_install.png" alt=""></p><p>接下来的全部选择默认，一路回车即可，安装好之后，输入 <code>v2ray status</code> 可查看安装状态，<code>v2ray info</code> 查看安装信息，<code>v2ray url</code> 可生成配置链接。</p><p><img src="/2019/12/17/v2ray-websocket-TLS通过cloudflare转发防IP被ban/v2ray_info.png" alt=""></p><p>此时，环境已经搭建完毕，记得回到 <code>cloudflare</code> 的<code>DNS</code>管理界面将 <code>v2ray</code> 的解析云朵点亮成橙色。</p><p>使用<code>nslookup v2ray.wangjibao.com.cn 8.8.8.8</code>查询域名解析，发现，此时返回的<code>ip</code>地址已经不是自己的<code>VPS</code>地址（是<code>cloudflare</code>的<code>CDN</code>地址），代表已经代理成功。 </p><p><img src="/2019/12/17/v2ray-websocket-TLS通过cloudflare转发防IP被ban/nslookup.png" alt=""></p><p>将 <code>v2ay url</code> 生成配置信息导入到客户端，即可快乐上网。</p><h3 id="三、抓包分析"><a href="#三、抓包分析" class="headerlink" title="三、抓包分析"></a>三、抓包分析</h3><p>搭建成功了，抓个数据包瞧一瞧。下图是某条数据流的信息，可以看到，与客户端进行通信的是 <code>cloudflare</code> 的<code>CDN(104.28.14.115)</code>, 而不是我们的 <code>VPS IP</code>。</p><p><img src="/2019/12/17/v2ray-websocket-TLS通过cloudflare转发防IP被ban/stream.png" alt=""></p><p>其中的 <code>client hello</code> 包更能反映真实的信息。</p><p><img src="/2019/12/17/v2ray-websocket-TLS通过cloudflare转发防IP被ban/client_hello.png" alt=""></p><p>伪装成功，完美防<code>ban</code>！</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;一、前言&quot;&gt;&lt;a href=&quot;#一、前言&quot; class=&quot;headerlink&quot; title=&quot;一、前言&quot;&gt;&lt;/a&gt;一、前言&lt;/h3&gt;&lt;p&gt;天朝 &lt;code&gt;qiang&lt;/code&gt; 越垒越高，买的境外的服务器用时间长了经常会出现 &lt;code&gt;IP&lt;/code&gt; 被 &lt;code&gt;ban&lt;/code&gt; 的情况，本教程通过 &lt;code&gt;v2ray+websocket(ws)+TLS&lt;/code&gt; 将流量伪装成 &lt;code&gt;TLS&lt;/code&gt; 流量，即将自己的境外转发服务器伪装成一个网站，并通过 &lt;code&gt;cloudflare&lt;/code&gt; 中转，网络流量流经图如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/2019/12/17/v2ray-websocket-TLS通过cloudflare转发防IP被ban/cdn_cloudflare.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;这样的话，防火墙就只知道你和 &lt;code&gt;CDN&lt;/code&gt; 之间建立了连接，不知道你的 &lt;code&gt;vps&lt;/code&gt; 实际的 &lt;code&gt;IP&lt;/code&gt; 地址，这样就可以有效的防止你的 &lt;code&gt;IP&lt;/code&gt; 被 &lt;code&gt;ban&lt;/code&gt;，并且  &lt;code&gt;CDN&lt;/code&gt; 会有很多 &lt;code&gt;IP&lt;/code&gt; 地址，防火墙也不会随意去 &lt;code&gt;ban&lt;/code&gt; 他们的 &lt;code&gt;IP&lt;/code&gt;，毕竟也有很多正规的网站在使用，所以基本上可以确保你的 &lt;code&gt;IP&lt;/code&gt; 的安全。&lt;/p&gt;
    
    </summary>
    
      <category term="笔记" scheme="https://wangjibao.com.cn/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="笔记" scheme="https://wangjibao.com.cn/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>Linux环境变量配置</title>
    <link href="https://wangjibao.com.cn/2019/11/22/Linux%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E9%85%8D%E7%BD%AE/"/>
    <id>https://wangjibao.com.cn/2019/11/22/Linux环境变量配置/</id>
    <published>2019-11-22T01:31:37.000Z</published>
    <updated>2019-11-22T03:38:52.567Z</updated>
    
    <content type="html"><![CDATA[<p>1、<code>source</code> 命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">source filename</span><br></pre></td></tr></table></figure><p>在当前 <code>bash</code> 环境下读取并执行 <code>filename</code> 中的命令。</p><p>2、环境变量分为 <strong><code>永久环境变量</code></strong> 和 <strong><code>临时环境变量</code></strong></p><p>永久环境变量：修改配置文件，<code>/etc/profile, /etc/.bashrc, ~/.profile, ~/.bashrc</code> 等，</p><p>临时环境变量：使用 <code>export</code> 命令声明即可，变量在关闭<code>shell</code>时失效。</p><a id="more"></a><p>3、<code>/etc/profile, /etc/.bashrc, ~/.profile, ~/.bashrc</code></p><p>这四个文件都是存储环境配置的，其中 <code>/etc/profile, /etc/.bashrc</code> 对全部用户有效，<code>~/.profile, ~/.bashrc</code> 对当前用户有效，执行的顺序为：</p><ul><li><code>/etc/profile</code> 先执行，设置全部用户的环境配置。它会调用 <code>/etc/.bashrc</code> 和 <code>/etc/profile.d</code> 中的 <code>*.sh</code> 文件，其内容如下：</li></ul><p><img src="/2019/11/22/Linux环境变量配置/profile.png" alt=""></p><p>由代码可见，第 <code>9</code> 行，<code>-f</code> 判断文件存在则执行 <code>/etc/bash.bashrc</code> 文件（和<code>/etc/.bashrc</code>一样，不同的发行版命名略微有差异），接着，<code>-d</code> 判断 <code>/etc/profile.d</code> 目录存在，则在第<code>21--24</code> 行使用 <code>for</code> 循环依次执行每一个 <code>*.sh</code> 文件。（其中第 <code>23</code> 行 <code>. $i</code> 和 <code>source $i</code> 的作用是一样的）</p><ul><li><code>~/.profile</code> 在每个用户登录时调用，它会调用 <code>~/.bashrc</code> 文件，其内容如下： </li></ul><p><img src="/2019/11/22/Linux环境变量配置/user_profile.png" alt=""></p><p>也就是说，我开机以 <code>xxx</code> 的身份登录系统时，先是会运行 <code>/etc/profile</code> 文件，然后根据我的身份运行对应的 <code>~/.profile</code> 文件（只在登录时运行一次，更改后需要重启或者<code>source **</code>生效），它调用 <code>~/.bashrc</code> 文件（每打开一个新的 <code>shell</code> 终端都会运行一次，更改后自动生效）。</p><p>4、有了 <code>profile</code> 为什么需要 <code>bashrc</code> 文件呢？</p><p><code>profile</code>文件只有在登录的时候执行一次，<code>bashrc</code>是每打开一个<code>shell</code>都会执行一次，时效性很好。也就是所谓的 <code>login shell</code> 和 <code>non-login shell</code> 的区别。</p><p><img src="/2019/11/22/Linux环境变量配置/shell.png" alt=""></p><p><code>login shell</code> ： 取得<code>bash</code> 时需要完整的登入流程，就称为<code>login shell</code>。举例来说，同<code>tty1~tty6</code>登入时，  需要输入用户名和密码，此时取得的<code>bash</code>就称为<code>login shell</code>。</p><p><code>non-login shell</code>： 取得<code>bash</code> 界面的方法不需要重复登入的动作。举例来说，以图形界面登录<code>linux</code>系统时，按 <code>ctrl + alt + T</code> 组合键打开的 <code>shell</code> 终端，就是 <code>non-login shell</code>。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;1、&lt;code&gt;source&lt;/code&gt; 命令&lt;/p&gt;
&lt;figure class=&quot;highlight shell&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;source filename&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;在当前 &lt;code&gt;bash&lt;/code&gt; 环境下读取并执行 &lt;code&gt;filename&lt;/code&gt; 中的命令。&lt;/p&gt;
&lt;p&gt;2、环境变量分为 &lt;strong&gt;&lt;code&gt;永久环境变量&lt;/code&gt;&lt;/strong&gt; 和 &lt;strong&gt;&lt;code&gt;临时环境变量&lt;/code&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;永久环境变量：修改配置文件，&lt;code&gt;/etc/profile, /etc/.bashrc, ~/.profile, ~/.bashrc&lt;/code&gt; 等，&lt;/p&gt;
&lt;p&gt;临时环境变量：使用 &lt;code&gt;export&lt;/code&gt; 命令声明即可，变量在关闭&lt;code&gt;shell&lt;/code&gt;时失效。&lt;/p&gt;
    
    </summary>
    
      <category term="笔记" scheme="https://wangjibao.com.cn/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="笔记" scheme="https://wangjibao.com.cn/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>Go语言实战阅读笔记</title>
    <link href="https://wangjibao.com.cn/2019/11/06/Go%E8%AF%AD%E8%A8%80%E5%AE%9E%E6%88%98%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/"/>
    <id>https://wangjibao.com.cn/2019/11/06/Go语言实战阅读笔记/</id>
    <published>2019-11-06T09:01:04.000Z</published>
    <updated>2019-11-06T09:03:04.654Z</updated>
    
    <content type="html"><![CDATA[<p>1、<code>Go</code> 语言更高效的利用计算机<code>CPU</code>上的所有核心，更高效的复用代码。</p><p>2、<code>Go</code> 语言自带垃圾回收器，不需要用户自己管理内存。</p><p>3、使用 <code>goroutine</code> 并发，使用 <code>通道</code> 避免其他语言中的<code>共享内存访问</code>的问题，减少了<code>锁</code> 或者 <code>同步机制</code>。</p><p>4、<code>Go</code> 语言的每个代码文件都属于一个包，一个包定义一组编译过的代码，包的名字类似于命名空间。处在同一个文件夹里的代码文件，必须使用同一个包名，按照惯例，包和文件夹同名。</p><p>5、<code>Go</code> 编译器为了让程序的可读性更强，不允许声名导入某个包却不使用。解决方法： 在导入的路径前加一个 <code>下划线</code> ，这样它会调用对应包内的<strong>所有</strong>代码文件里定义的 <code>init</code> 函数，进行初始化操作。</p><a id="more"></a><p>6、每个代码文件里的 <code>init</code> 函数都会在 <code>main</code> 函数执行前调用。</p><p>7、<code>Go</code> 中，标识符（变量 or 函数等）要么从包里公开，要么不从包里公开。当代码导入了一个包时，程序可以直接访问这个包中任意一个公开的标识符。公开的标识符用 <strong>大写字母</strong>  开头，以 <strong>小写字母</strong> 开头的标识符是不公开的。</p><p>8、 在 <code>Go</code> 中，所有变量都会被初始化为其零值，如 <code>指针</code> 类型的零值为 <code>nil</code> ，引用类型的话，所引用的底层数据结构会被初始化为对应的零值，整个引用类型的变量会返回 <code>nil</code> 作为其值。</p><p>9、<code>:=</code> 运算符，用于声明一个变量并给这个变量赋予初始值。</p><p>10、如果需要声明初始值为零值的变量，应该使用 <code>var</code> 关键字声明变量；如果提供确切的非零值初始化变量或者使用函数返回值创建变量，应该使用简化变量声明运算符 <code>:=</code> 。</p><p>11、<code>Go</code> 中声明常量的时候不需要指定类型。</p><p>12、关键字 <code>defer</code> 会将其后面的函数调用在函数返回时才执行。关键字 <code>defer</code> 可以保证这个函数一定会被调用，哪怕函数意外崩溃终止，还可以缩短打开文件和关闭文件之间间隔的代码行数，提高代码可读性。</p><p>13、如果声明函数的时候带有接收者，则意味着声明了一个方法，这个方法会和指定的接收者类型绑定在一起。<strong>接口实现多态</strong></p><p>14、使用  <strong>指针</strong> 可以在 <strong>函数</strong> 间或者 <strong><code>goroutine</code></strong> 间共享数据。</p><p>15、<code>Go</code> 程序编译时，会使用声明 <code>main</code> 包的代码所在的目录的目录名作为二进制可执行文件的文件名。</p><p>16、创建并初始化 <code>切片</code>、<code>映射</code> 等，可以使用内置的 <code>make</code> 函数 或者 <code>字面量</code> 。<code>[]</code> 中指定长度的是 <code>数组</code>，不指定长度的是 <code>切片</code>。</p><p>17、在<code>Go</code>语言中，<code>数组、切片、映射</code> 在作为参数传入函数时，只有 <code>数组</code> 是将全部的值复制一份拷贝，<code>切片、映射</code> 仅拷贝元数据，其底层的存储用的是同一份。</p><p>18、切片、函数以及包含切片的结构类型这些类型由于具有引用语义，不能作为映射的键。</p><p>19、<code>Go</code> 语言是<code>静态类型</code> 的编程语言，也就是说，编译器需要在编译的时候就知道程序里每个变量的类型。</p><p>20、<code>Go</code> 编译器不会对不同类型的值做<code>隐式转换</code>。</p><p>21、关键字 <code>func</code> 和函数名之间的参数被称作 <code>接收者</code>, 将函数与接收者的类型绑在一起。如果一个函数有接收者，这个函数就被称为 <code>方法</code> 。<code>Go</code> 语言里有两种类型的接收者：<code>值接收者</code> 和 <code>指针接收者</code> 。如果使用值接收者声明方法，调用时会使用这个值的副本来执行，而指针接收者使用实际值来调用方法。</p><p><code>Go</code> 语言既允许使用值，也允许使用指针来调用方法，不必严格符合接收者的类型。</p><p>22、<strong>方法，接口与方法集</strong></p><ul><li><p>在将数据类型与方法绑定时，值可以调用绑定值或者值指针的方法，值指针也可以调用绑定值或者值指针的方法，没什么影响，只取决于是否要更改变量的某些东西。</p></li><li><p>在数据类型实现接口中声明的函数（方法）时，如果将值与方法绑定，那么只能通过值调用该方法（将值传递给接口参数，<code>接口.函数（）</code>）；如果将值指针与方法绑定，可以通过值或者值指针来调用该方法。原因是：不是总能获得一个值的地址，所以值的方法集只能包括使用值接收者实现的方法。</p></li></ul><p>23、<strong>嵌入类型</strong></p><p>嵌入类型是将已有的类型直接声明在新的结构类型里，被嵌入的类型被称为新的外部类型的内部类型。</p><p>要嵌入一个类型，只需要声明这个类型的名字就可以了。</p><p>通过嵌入类型，与内部类型相关的标识符会提升到外部类型上。这样被提升的标识符就像直接声明在外部类型里的标识符一样，也是外部类型的一部分。</p><p>外部类型可以通过声明与内部类型标识符同名的标识符来覆盖内部标识符的字段或者方法。</p><p>注意 <strong>自动提升</strong>， 如果外部类型实现了 某方法 , 内部类型的实现就不会被提升。不过内部类型的值一直存在，因此还可以通过直接访问内部类型的值，来调用没有被提升的内部类型实现的方法。</p><p>24、当一个标识符的名字以小写字母开头时，这个标识符就是未公开的，即包外的代码不可见。结构类型是公开的，里面的某个字段是未公开的，那么也不能在包外访问这个未公开的字段。</p><p>25、 <code>Go</code> 语言调度器在任何给定的时间，都会全面控制哪个 <code>goroutine</code> 要在哪个逻辑处理器上运行。用于在 <code>goroutine</code> 之间同步和传递数据的关键数据类型叫做 <code>通道</code>。</p><p>26、<code>Go</code> 语言在运行时，默认会为每个可用的物理处理器分配一个逻辑处理器。</p><p>27、<code>goroutine</code> 终止时无法获取函数的返回值。</p><p>28、<code>Go</code> 语言中一种消除竞争状态的办法是：使用<code>Go</code> 语言提供的 <code>锁机制</code>， 来锁住 <code>共享资源</code> ，从而保证 <code>goroutine</code> 的同步状态。</p><ul><li>原子函数 。   在 <code>sync/atomic</code> 库， <code>atomic.AddInt()、atomic.LoadInt()、atomic.StoreInt()</code></li><li>互斥锁。       在 <code>sync.Mutex</code> 中， <code>mutex.Lock()、mutex.Unlock()</code></li></ul><p>29、有缓冲通道和无缓冲通道</p><ul><li>无缓冲通道保证进行发送和接收的<code>goroutine</code> 会在同一时间进行数据交换。</li><li>有缓冲的通道， 只有在缓冲区满的时候，发送动作才会堵塞，只有在缓冲区空的时候，接收动作才会阻塞。</li></ul><p>30、当通道关闭后，<code>goroutine</code> 依旧可以从通道接收数据，但是不能再向通道里发送数据。这允许通道关闭后依旧能取出其中缓冲的全部值，而不会有数据丢失。从一个已经关闭且没有数据的通道里获取数据，总会立刻返回，并返回一个通道类型的零值。如果在获取通道时还加入了可选的标志，就能得到通道的状态信息。</p><p>31、<code>select</code> 语句只能处理通道类型的数据，当有 <code>default</code> 语句时，前面的条件都不满足的时候执行 <code>default</code> 语句，当没有 <code>default</code> 语句的时候，程序进入阻塞状态。当有多个语句满足条件时，<code>select</code> 随机挑选一条执行，其他的忽略。 <code>switch</code> 语句可以处理各种类型的数据。</p><p>32、<code>Go</code> 语言中的通道类型分为 双向通道 和 单向通道。  <code>双向：chan</code>、<code>只发送数据：&lt;-chan</code>、<code>只接收数据：chan&lt;-</code>。</p><p>33、<code>Go</code> 语言中的断言</p><p> 类型断言的本质，跟类型转换类似，都是类型之间进行转换 。 不同之处在于，<strong>类型断言是在接口之间进行 。</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;目标类型的值&gt;，&lt;布尔参数&gt; := &lt;表达式&gt;.( 目标类型 ) // 安全类型断言</span><br><span class="line">&lt;目标类型的值&gt; := &lt;表达式&gt;.( 目标类型 )　　//非安全类型断言</span><br></pre></td></tr></table></figure><p>34、定制 <code>日志记录器</code> ，可以将不同层次的日志记录到不同的路径中去。 方法：创建 <code>log.Logger</code> 指针，并使用 <code>log.New()</code> 初始化。</p><p>35、<code>反序列化</code> :  将字符串转换成数据变量值，</p><p><code>序列化</code>:  将数据变量值转换成字符串。</p><p>36、任何类型都实现了一个空接口 <code>interface{}</code>，声明一个 <code>map</code> 类型，其键是 <code>string</code> 类型，其值是 <code>interface{}</code> 类型，这意味着这个 <code>map</code> 类型可以使用任意类型的值作为给定键的值。</p><p>37、<code>Go</code> 语言的测试工具只会认为以 <code>_test.go</code> 结尾的文件是测试文件。一但测试工具找到了测试文件，就会查找里面的测试函数并执行。包的名字以 <code>_test</code> 结尾，那么测试代码只能访问包里的公开的标识符，即便测试代码文件和被测试代码文件的代码放在同一个文件夹中，也只能访问公开的标识符。</p><p>38、一个测试函数必须是公开的函数，并且以 <code>Test</code> 开头，并且函数的参数要接收一个指向 <code>testing.T</code> 类型的指针，并且不返回任何值。</p><p>39、<code>Println</code> 、<code>Fatalln</code> 、<code>Panicln</code></p><p>这三个函数都有格式化的版本，值需要用 <code>f</code> 替换结尾的 <code>ln</code>。</p><p><code>Fatal</code> 系列函数用来写日志消息，然后使用 <code>os.Exit(1)</code> 终止程序。</p><p><code>Panic</code> 系列函数用来写日志消息，然后出发一个 <code>panic</code> ，除非程序执行 <code>recover</code> 函数，否则会导致程序打印<strong>调用栈</strong>后终止。</p><p><code>Print</code> 系列函数是写日志消息的标准方法。</p><p>40、如果测试函数执行时没有调用过 <code>t.Fatal</code> 或者 <code>t.Error</code> 方法，就认为测试通过了。</p><p>41、<code>基础单元测试</code>、 <code>表组测试</code> ： 测试可以接受一组不同的输入并产生不同的输出的代码。</p><p>42、结构类型 <code>(struct)</code> 在初始化时，如果是在同一行赋值的话，行尾不需要加逗号。如果每一行初始化一个字段，那么每一行末尾都需要加一个逗号。</p><p>43、基准测试</p><p>和单元测试文件一样，基准测试的文件名也必须以 <code>_test.go</code> 结尾，同时也必须导入 <code>testing</code> 包。基准测试函数必须以 <code>Benchmark</code> 开头，接受一个指向 <code>testing.B</code> 类型的指针作为唯一参数。</p><p>44、包中的示例代码，既能用于测试，也能用于文档。函数名以 <code>Example</code> 开头。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;1、&lt;code&gt;Go&lt;/code&gt; 语言更高效的利用计算机&lt;code&gt;CPU&lt;/code&gt;上的所有核心，更高效的复用代码。&lt;/p&gt;
&lt;p&gt;2、&lt;code&gt;Go&lt;/code&gt; 语言自带垃圾回收器，不需要用户自己管理内存。&lt;/p&gt;
&lt;p&gt;3、使用 &lt;code&gt;goroutine&lt;/code&gt; 并发，使用 &lt;code&gt;通道&lt;/code&gt; 避免其他语言中的&lt;code&gt;共享内存访问&lt;/code&gt;的问题，减少了&lt;code&gt;锁&lt;/code&gt; 或者 &lt;code&gt;同步机制&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;4、&lt;code&gt;Go&lt;/code&gt; 语言的每个代码文件都属于一个包，一个包定义一组编译过的代码，包的名字类似于命名空间。处在同一个文件夹里的代码文件，必须使用同一个包名，按照惯例，包和文件夹同名。&lt;/p&gt;
&lt;p&gt;5、&lt;code&gt;Go&lt;/code&gt; 编译器为了让程序的可读性更强，不允许声名导入某个包却不使用。解决方法： 在导入的路径前加一个 &lt;code&gt;下划线&lt;/code&gt; ，这样它会调用对应包内的&lt;strong&gt;所有&lt;/strong&gt;代码文件里定义的 &lt;code&gt;init&lt;/code&gt; 函数，进行初始化操作。&lt;/p&gt;
    
    </summary>
    
      <category term="笔记" scheme="https://wangjibao.com.cn/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="笔记" scheme="https://wangjibao.com.cn/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode81-90</title>
    <link href="https://wangjibao.com.cn/2019/10/24/LeetCode81-90/"/>
    <id>https://wangjibao.com.cn/2019/10/24/LeetCode81-90/</id>
    <published>2019-10-24T01:33:41.000Z</published>
    <updated>2019-11-08T02:19:00.123Z</updated>
    
    <content type="html"><![CDATA[<h2 id="81、搜索旋转排序数组-II"><a href="#81、搜索旋转排序数组-II" class="headerlink" title="81、搜索旋转排序数组 II"></a>81、<a href="https://leetcode-cn.com/problems/search-in-rotated-sorted-array-ii/" target="_blank" rel="noopener">搜索旋转排序数组 II</a></h2><p>二分搜索，注意第 <code>34</code> 行的 <code>L = L + 1</code> 的条件判断，在最坏情况下，会使得该二分搜索退化为 <code>O(N)</code> 的时间复杂度。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">search</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.size()==<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">int</span> L = <span class="number">0</span>, R = nums.size()<span class="number">-1</span>, mid;</span><br><span class="line">        <span class="keyword">while</span>(L &lt;= R)&#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">"L: "</span> &lt;&lt; L &lt;&lt; <span class="string">",  R: "</span> &lt;&lt; R &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">            mid = (L + R) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid]&gt;nums[L])&#123;</span><br><span class="line">                <span class="keyword">if</span>(target==nums[mid])</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(target&gt;nums[mid])</span><br><span class="line">                    L = mid + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(target&gt;=nums[L])</span><br><span class="line">                    R = mid - <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    L = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(nums[mid]&lt;nums[L])&#123;</span><br><span class="line">                <span class="keyword">if</span>(target==nums[mid])</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(target&lt;nums[mid])</span><br><span class="line">                    R = mid - <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(target&lt;=nums[R])</span><br><span class="line">                    L = mid + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    R = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123; <span class="comment">// nums[mid] == nums[L]</span></span><br><span class="line">                <span class="keyword">if</span>(target==nums[mid])</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    L = L + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="82、删除排序链表中的重复元素-II"><a href="#82、删除排序链表中的重复元素-II" class="headerlink" title="82、删除排序链表中的重复元素 II"></a>82、<a href="https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list-ii/" target="_blank" rel="noopener">删除排序链表中的重复元素 II</a></h2><p>模拟题</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">deleteDuplicates</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!head)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        ListNode *new_head = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        ListNode *new_p = new_head, *ptr=head;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> num = <span class="number">1e10</span>;</span><br><span class="line">        <span class="keyword">while</span>(ptr!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(ptr-&gt;next!=<span class="literal">NULL</span> &amp;&amp; ptr-&gt;val==ptr-&gt;next-&gt;val)&#123;</span><br><span class="line">                num = ptr-&gt;val;</span><br><span class="line">                ptr = ptr-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>((<span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span>)(ptr-&gt;val)==num)&#123;</span><br><span class="line">                ptr = ptr-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                new_p-&gt;next = ptr;</span><br><span class="line">                ptr = ptr-&gt;next;</span><br><span class="line">                new_p = new_p-&gt;next;</span><br><span class="line">                new_p-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> new_head-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="83、删除排序链表中的重复元素"><a href="#83、删除排序链表中的重复元素" class="headerlink" title="83、删除排序链表中的重复元素"></a>83、<a href="https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list/" target="_blank" rel="noopener">删除排序链表中的重复元素</a></h2><p>模拟题，线上代码铁定不能这么写，内存泄露有木有！</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">deleteDuplicates</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        ListNode *new_head = head, *p = head;</span><br><span class="line">        <span class="keyword">while</span>(p!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(p-&gt;next!=<span class="literal">NULL</span> &amp;&amp; p-&gt;val==p-&gt;next-&gt;val)&#123;</span><br><span class="line">                p-&gt;next = p-&gt;next-&gt;next;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> new_head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="84、柱状图中最大的矩形"><a href="#84、柱状图中最大的矩形" class="headerlink" title="84、柱状图中最大的矩形"></a>84、<a href="https://leetcode-cn.com/problems/largest-rectangle-in-histogram/" target="_blank" rel="noopener">柱状图中最大的矩形</a></h2><p>一个很自然的想法是，以当前柱子为高，向两边遍历，时间复杂度为 $O(n^2)$。降低复杂度的关键是，如何快速找到以当前柱子为高的左右边界<code>left_index 和 right_index</code>，维护一个单调的递增栈 <code>&gt;=</code>，即可快速找到 <code>left_index 和 right_index</code>。具体如代码第 14 行所示，整体时间复杂度为  $O(n)$ 。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">largestRectangleArea</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; heights)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(heights.size()==<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; index;</span><br><span class="line">        index.push(<span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">int</span> max_area = <span class="number">0</span>, N = heights.size(), h;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;N; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(index.size()&gt;<span class="number">1</span> &amp;&amp; heights[i]&lt;heights[index.top()])&#123;</span><br><span class="line">                <span class="keyword">while</span>(index.size()&gt;<span class="number">1</span> &amp;&amp; heights[i]&lt;heights[index.top()])&#123;</span><br><span class="line">                    h = heights[index.top()];</span><br><span class="line">                    index.pop();</span><br><span class="line">                    max_area = max(max_area, h*(i-index.top()<span class="number">-1</span>));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            index.push(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(index.size()&gt;<span class="number">1</span>)&#123;</span><br><span class="line">            h = heights[index.top()];</span><br><span class="line">            index.pop();</span><br><span class="line">            max_area = max(max_area, h*(N-index.top()<span class="number">-1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max_area;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="85、"><a href="#85、" class="headerlink" title="85、"></a>85、</h2><h2 id="86、分隔链表"><a href="#86、分隔链表" class="headerlink" title="86、分隔链表"></a>86、<a href="https://leetcode-cn.com/problems/partition-list/" target="_blank" rel="noopener">分隔链表</a></h2><p>使用两个指针即可。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">partition</span><span class="params">(ListNode* head, <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        ListNode *big_head = <span class="keyword">new</span> ListNode(<span class="number">0</span>), *small_head = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        ListNode *big_p = big_head, *small_p = small_head, *p = head;</span><br><span class="line">        <span class="keyword">while</span>(p)&#123;</span><br><span class="line">            <span class="keyword">if</span>(p-&gt;val &lt; x)&#123;</span><br><span class="line">                small_p-&gt;next = p;</span><br><span class="line">                p = p-&gt;next;</span><br><span class="line">                small_p = small_p-&gt;next;</span><br><span class="line">                small_p-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                big_p-&gt;next = p;</span><br><span class="line">                p = p-&gt;next;</span><br><span class="line">                big_p = big_p-&gt;next;</span><br><span class="line">                big_p-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        small_p-&gt;next = big_head-&gt;next;</span><br><span class="line">        <span class="keyword">return</span> small_head-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="88、合并两个有序数组"><a href="#88、合并两个有序数组" class="headerlink" title="88、合并两个有序数组"></a>88、<a href="https://leetcode-cn.com/problems/merge-sorted-array/" target="_blank" rel="noopener">合并两个有序数组</a></h2><p>一个小的 <code>trick</code> 是从后往前遍历，时间复杂度 $O(n+m)$, 空间复杂度 $O(1)$ 。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums1, <span class="keyword">int</span> m, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums2, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> p1 = m<span class="number">-1</span>, p2 = n<span class="number">-1</span>, index = m+n<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(p1&gt;=<span class="number">0</span> &amp;&amp; p2&gt;=<span class="number">0</span>)</span><br><span class="line">            nums1[index--] = nums1[p1]&gt;=nums2[p2]? nums1[p1--] : nums2[p2--];</span><br><span class="line">        <span class="keyword">while</span>(p1+p2&gt;=<span class="number">-1</span>)</span><br><span class="line">            nums1[index--] = p1&gt;=<span class="number">0</span>? nums1[p1--] : nums2[p2--];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;81、搜索旋转排序数组-II&quot;&gt;&lt;a href=&quot;#81、搜索旋转排序数组-II&quot; class=&quot;headerlink&quot; title=&quot;81、搜索旋转排序数组 II&quot;&gt;&lt;/a&gt;81、&lt;a href=&quot;https://leetcode-cn.com/problems
      
    
    </summary>
    
      <category term="LeetCode" scheme="https://wangjibao.com.cn/categories/LeetCode/"/>
    
      <category term="LeetCode81-90" scheme="https://wangjibao.com.cn/categories/LeetCode/LeetCode81-90/"/>
    
    
      <category term="LeetCode" scheme="https://wangjibao.com.cn/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>Docker实战笔记</title>
    <link href="https://wangjibao.com.cn/2019/10/22/Docker%E5%AE%9E%E6%88%98%E7%AC%94%E8%AE%B0/"/>
    <id>https://wangjibao.com.cn/2019/10/22/Docker实战笔记/</id>
    <published>2019-10-22T05:31:23.000Z</published>
    <updated>2019-10-22T06:20:39.454Z</updated>
    
    <content type="html"><![CDATA[<p>闲来没事苟着，顺手读读之前买的已经落灰的书《Docker实战》。</p><p>1、<code>daemon</code>（守护进程），运行中的 <code>docker</code> 由守护进程（服务端）和客户端组成(通过unix域间套接字通信），比如说，执行：<code>docker ps -a</code> 命令，是客户端将命令传送给守护进程，由守护进程发送对应的响应给前端，前端解析并显示。可以通过如下操作查看<code>docker</code>守护进程和客户端的通信过程:<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sudo socat -v UNIX-LISTEN:/tmp/dockerapi.sock UNIX-CONNECT:/var/run/docker.sock</span><br><span class="line"><span class="meta">#</span># 其中 socat 是 netcat(nc) 命令的升级版，-v 参数有助于人阅读 address1 address2 可以是 tcp、udp或 socket等</span><br><span class="line">docker -H unix:///tmp/dockerapi.sock ps -a</span><br><span class="line"><span class="meta">#</span>#  -H 参数指定 docker daemon socket(s) to connect to.</span><br></pre></td></tr></table></figure></p><a id="more"></a><p>两者直接通过 <code>HTTP</code> 通信，客户端解析返回的 <code>json</code> 并显示，运行结果如下：<br><img src="/2019/10/22/Docker实战笔记/daemon.png" alt=""></p><p>2、以服务方式在后台运行一个 <code>docker</code> 容器（docker最主要的功能之一），使用 <code>docker run -p ***</code>  命令。不然的话，需要使用类似 <code>nohup docker run *** &amp;</code> 的方式来实现此功能。</p><p>3、<code>docker</code> 中的端口映射—将容器的某端口暴露给宿主机的某端口，便于外界访问容器中的功能：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -p 宿主机端口：容器端口 --name 容器名 使用的镜像名</span><br></pre></td></tr></table></figure></p><p>4、给<code>Docker</code>打标签<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker tag IMAGE_ID（镜像id) REPOSITY:TAG（仓库：标签）</span><br><span class="line">docker commit CONTAINER [REPOSITY:TAG]</span><br></pre></td></tr></table></figure></p><p>5、<code>Docker</code>挂载外部卷<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -v 宿主机目录：容器内目录 -it ubuntu /bin/bash</span><br></pre></td></tr></table></figure></p><p>注意一点：镜像中即使存在需要映射的目录，容器的目录也会被建立映射，这意味着容器里映射的目录的原内容将会消失。当然，也可以通过网络映射其他机器上的卷。在容器里运行如下命令即可：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sshfs user@host_ip:remote_path local_path</span><br><span class="line"><span class="meta">#</span> 卸载</span><br><span class="line">fusermount -u local_path</span><br></pre></td></tr></table></figure></p><p>6、想要在 <code>Dockerfile</code> 构建中从一个指定的点开始失效 <code>Docker</code> 构建缓存，可以：在某条<code>Dockerfile</code>命令后面加个注释，这样，该条命令及其后的指定的缓存就失效了。原理在于 <code>Docker</code> 将非空的更改均当做一行新的命令来对待。</p><p>7、<code>bash</code> 里的 <code>“&lt; (命令）”</code> 语法被称为进程替换，它允许把一个命令的输出结果作为一个文件，传给其他命令。</p><p>8、解绑容器的同时不停掉它，解决：按下 <code>ctrl + p</code> 然后再按 <code>ctrl + q</code>。<br>原因：在使用 <code>docker</code> 时，会发现，打开一个交互式 <code>shell</code>，然后因为它是容器的主进程，所以一旦退出会话，容器便会被终止（可以使用 <code>docker attach</code> 再连接到容器）。</p><p>9、想要从镜像的分层历史中移除私密信息，解决：基于该镜像创建一个容器，将它导出再导入并打上标签。<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker export (容器ID) | docker import - (标签)</span><br></pre></td></tr></table></figure></p><p><code>docker import</code> 会输出一个 文件系统的内容的一个<code>TAR</code>文件， <code>“-”</code>参数指明从标准输入读取 <code>TAR</code> 文件内容。</p><p>10、<code>Dockerfile</code> 指令<br><code>Dockerfile</code>中包括<code>FROM、MAINTAINER、RUN、CMD、EXPOSE、ENV、ADD、COPY、ENTRYPOINT、VOLUME、USER、WORKDIR、ONBUILD</code>等13个指令。<br><code>VOLUME</code>: 作用是创建在本地主机或其他容器可以挂载的数据卷，用来存放数据。<br><code>ONBUILD</code> : 该配置指定当所创建的镜像作为其他新建镜像的基础镜像时所执行的指令。<br><code>ENTRYPOINT</code> : 用于配置容器启动后执行的命令，这些命令不能被<code>docker run</code>提供的参数覆盖。和<code>CMD</code>一样，每个<code>Dockerfile</code>中只能有一个<code>ENTRYPOINT</code>，当有多个时最后一个生效。</p><p>11、<code>Dockerfile</code> 的逆向：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">docker history reverseme | \</span><br><span class="line">awk '&#123;print $1&#125;' | \</span><br><span class="line">grep -v IMAGE | \</span><br><span class="line">tac | \</span><br><span class="line">sed "s/\(.*\)/docker inspect \1 | \</span><br><span class="line">jq -r \'.[0].ContainerConfig.Cmd[2] | tostring\'/" | \</span><br><span class="line">sh | \</span><br><span class="line">sed 's/^#(nop) //'</span><br></pre></td></tr></table></figure></p><p>12、<code>export</code> 和 <code>import</code> 与 <code>save</code> 和 <code>load</code> 的对比<br><img src="/2019/10/22/Docker实战笔记/table.png" alt=""><br>如果要保留镜像的历史，可以使用 <code>load</code> 而不是 <code>import</code>， 这样其历史将在另一边的 <code>Docker</code> 守护进程上得到保留。 </p><p>13、<code>Docker compose</code> 的使用，可节省大量的命令行操作。</p><p>14、使用 <code>Blockade</code> 及 <code>Comcast</code> 对容器网络状况进行控制。</p><p>15、多宿主机<code>Docker</code>的部署和编排 </p><ul><li>使用 <code>Helios</code> 手动管理多宿主机 <code>Docker</code>，涉及 <code>Zookeeper</code> 技术（一个分布式数据库，用来存储数据，用于 <code>Helios</code> 主机 和 <code>Helios</code> 代理之间的通信）。</li><li><code>docker</code> + <code>Swarm</code></li><li>想要跨宿主机管理 <code>Docker</code> 服务，使用 <code>Kubernetes</code>。</li><li><code>Mesos</code> + <code>Docker</code></li><li>使用 <code>Marathon</code> 细粒度管理 <code>Mesos</code></li></ul><p>16、<code>OpenShift</code>, 应用程序平台即服务<code>（aPaaS）</code>。使用<code>Docker</code> 作为容器技术，并用 <code>Kubernetes</code> 和 <code>etcd</code> 进行编排。一种安全管理的方式，<strong>去除用户直接运行docker的能力，同时又保持使用Docker的好处。</strong></p><p>17、使用 <code>cAdvisor</code> 监控容器的性能。</p><p>18、限制容器 <code>cpu</code> 和 内存 的使用，使用 <code>docker run -c -m</code> 等参数。</p><p>19、在 <code>bash</code> 中，<code>$?</code> 给出最后一条执行命令的退出码。</p><p>20、<code>strace</code> 是一个工具，它允许嗅探一个进程对 <code>Linux API</code> 所做的调用。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;闲来没事苟着，顺手读读之前买的已经落灰的书《Docker实战》。&lt;/p&gt;
&lt;p&gt;1、&lt;code&gt;daemon&lt;/code&gt;（守护进程），运行中的 &lt;code&gt;docker&lt;/code&gt; 由守护进程（服务端）和客户端组成(通过unix域间套接字通信），比如说，执行：&lt;code&gt;docker ps -a&lt;/code&gt; 命令，是客户端将命令传送给守护进程，由守护进程发送对应的响应给前端，前端解析并显示。可以通过如下操作查看&lt;code&gt;docker&lt;/code&gt;守护进程和客户端的通信过程:&lt;br&gt;&lt;figure class=&quot;highlight shell&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;sudo socat -v UNIX-LISTEN:/tmp/dockerapi.sock UNIX-CONNECT:/var/run/docker.sock&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;/span&gt;# 其中 socat 是 netcat(nc) 命令的升级版，-v 参数有助于人阅读 address1 address2 可以是 tcp、udp或 socket等&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;docker -H unix:///tmp/dockerapi.sock ps -a&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;/span&gt;#  -H 参数指定 docker daemon socket(s) to connect to.&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="笔记" scheme="https://wangjibao.com.cn/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="笔记" scheme="https://wangjibao.com.cn/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode71-80</title>
    <link href="https://wangjibao.com.cn/2019/08/28/LeetCode71-80/"/>
    <id>https://wangjibao.com.cn/2019/08/28/LeetCode71-80/</id>
    <published>2019-08-28T07:41:59.000Z</published>
    <updated>2019-11-07T06:45:03.721Z</updated>
    
    <content type="html"><![CDATA[<h2 id="71、简化路径"><a href="#71、简化路径" class="headerlink" title="71、简化路径"></a>71、<a href="https://leetcode-cn.com/problems/simplify-path/" target="_blank" rel="noopener">简化路径</a></h2><p>模拟题<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">simplifyPath</span><span class="params">(<span class="built_in">string</span> path)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;path.length(); i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(path[i<span class="number">-1</span>]==<span class="string">'/'</span> &amp;&amp; path[i]==<span class="string">'/'</span>)</span><br><span class="line">                path.erase(i--,<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(path[path.length()<span class="number">-1</span>]==<span class="string">'/'</span>)</span><br><span class="line">            path.erase(path.length()<span class="number">-1</span>);</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; fenduan;</span><br><span class="line">        <span class="keyword">int</span> pos = <span class="number">0</span>, index;</span><br><span class="line">        <span class="keyword">while</span>(pos&gt;=<span class="number">0</span> &amp;&amp; pos&lt;path.length())&#123;</span><br><span class="line">            index = path.find(<span class="string">'/'</span>, pos+<span class="number">1</span>);</span><br><span class="line">            fenduan.push_back(path.substr(pos, index-pos));</span><br><span class="line">            pos = index;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">string</span> ans = <span class="string">""</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> i : fenduan)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i==<span class="string">"/."</span>)</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(i==<span class="string">"/.."</span>)&#123;</span><br><span class="line">                index = ans.find_last_of(<span class="string">'/'</span>);</span><br><span class="line">                <span class="keyword">if</span>(index&gt;=<span class="number">0</span> &amp;&amp; index&lt;ans.size())</span><br><span class="line">                    ans.erase(index);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                ans += i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(ans.size()==<span class="number">0</span>)</span><br><span class="line">            ans = <span class="string">"/"</span>;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><a id="more"></a><h2 id="72、编辑距离"><a href="#72、编辑距离" class="headerlink" title="72、编辑距离"></a>72、<a href="https://leetcode-cn.com/problems/edit-distance" target="_blank" rel="noopener">编辑距离</a></h2><p>DP 题，状态转移方程如下:<br><img src="/2019/08/28/LeetCode71-80/dp.png" alt=""></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minDistance</span><span class="params">(<span class="built_in">string</span> word1, <span class="built_in">string</span> word2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len1 = word1.length(), len2 = word2.length();</span><br><span class="line">        <span class="keyword">int</span> ans[len1+<span class="number">1</span>][len2+<span class="number">1</span>];</span><br><span class="line">        <span class="built_in">memset</span>(ans, <span class="number">0</span>, <span class="keyword">sizeof</span>(ans));</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;=len1; i++)</span><br><span class="line">            ans[i][<span class="number">0</span>] = i;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;=len2; i++)</span><br><span class="line">            ans[<span class="number">0</span>][i] = i;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=word1.length(); i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>; j&lt;=word2.length(); j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(word1[i<span class="number">-1</span>]==word2[j<span class="number">-1</span>])</span><br><span class="line">                    ans[i][j] = ans[i<span class="number">-1</span>][j<span class="number">-1</span>];</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    ans[i][j] = <span class="number">1</span>+min(ans[i<span class="number">-1</span>][j<span class="number">-1</span>], min(ans[i<span class="number">-1</span>][j], ans[i][j<span class="number">-1</span>]));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans[len1][len2];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="73、-矩阵置零"><a href="#73、-矩阵置零" class="headerlink" title="73、 矩阵置零"></a>73、 <a href="https://leetcode-cn.com/problems/set-matrix-zeroes" target="_blank" rel="noopener">矩阵置零</a></h2><p>模拟题，<code>O(1)</code> 的空间的 <code>trick</code> ，使用矩阵的第一行和第一列记录该行/列中有无 0 元素，同时注意使用 <code>col1_has_zero</code> 和 <code>row1_has_zero</code> 两个变量记录第一行/列有无 0 元素。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setZeroes</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; matrix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">bool</span> row1_has_zero = <span class="literal">false</span>, col1_has_zero = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;matrix.size(); i++)</span><br><span class="line">            <span class="keyword">if</span>(matrix[i][<span class="number">0</span>]==<span class="number">0</span>)&#123;</span><br><span class="line">                col1_has_zero = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;matrix[<span class="number">0</span>].size(); i++)</span><br><span class="line">            <span class="keyword">if</span>(matrix[<span class="number">0</span>][i]==<span class="number">0</span>)&#123;</span><br><span class="line">                row1_has_zero = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;matrix.size(); i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>; j&lt;matrix[<span class="number">0</span>].size(); j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(matrix[i][j]==<span class="number">0</span>)&#123;</span><br><span class="line">                    matrix[<span class="number">0</span>][j] = matrix[i][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;matrix.size(); i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>; j&lt;matrix[<span class="number">0</span>].size(); j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(!matrix[<span class="number">0</span>][j] || !matrix[i][<span class="number">0</span>])&#123;</span><br><span class="line">                    matrix[i][j] = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(row1_has_zero)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;matrix[<span class="number">0</span>].size(); i++)</span><br><span class="line">                matrix[<span class="number">0</span>][i] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(col1_has_zero)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;matrix.size(); i++)</span><br><span class="line">                matrix[i][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h2 id="74、搜索二维矩阵"><a href="#74、搜索二维矩阵" class="headerlink" title="74、搜索二维矩阵"></a>74、<a href="https://leetcode-cn.com/problems/search-a-2d-matrix/" target="_blank" rel="noopener">搜索二维矩阵</a></h2><p>二分查找，先按照行查找，再按照列查找。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">searchMatrix</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; matrix, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(matrix.size()==<span class="number">0</span> || matrix[<span class="number">0</span>].size()==<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">int</span> L = <span class="number">0</span>, R = matrix.size()<span class="number">-1</span>, Middle = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 二分查找</span></span><br><span class="line">        <span class="keyword">while</span>(L&lt;R)&#123;</span><br><span class="line">            Middle = (L+R) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(target&lt;matrix[Middle][<span class="number">0</span>])</span><br><span class="line">                R = Middle - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(target&gt;matrix[Middle][<span class="number">0</span>])&#123;</span><br><span class="line">                <span class="keyword">if</span>(target&lt;=matrix[Middle][matrix[<span class="number">0</span>].size()<span class="number">-1</span>])&#123;</span><br><span class="line">                    L = Middle;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                L = Middle + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> binary_search(&amp;matrix[L][<span class="number">0</span>], &amp;matrix[L][<span class="number">0</span>]+matrix[<span class="number">0</span>].size(), target);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h2 id="75、颜色分类"><a href="#75、颜色分类" class="headerlink" title="75、颜色分类"></a>75、<a href="https://leetcode-cn.com/problems/sort-colors/" target="_blank" rel="noopener">颜色分类</a></h2><p><strong>三路快排</strong>原理:<br><img src="/2019/08/28/LeetCode71-80/75.png" alt=""></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">sortColors</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 三路快排原理</span></span><br><span class="line">        <span class="keyword">int</span> p0 = <span class="number">0</span>, p1 = <span class="number">0</span>, p2 = nums.size()<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(p1&lt;=p2)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[p1]==<span class="number">0</span>)&#123;</span><br><span class="line">                swap(nums[p0], nums[p1]);</span><br><span class="line">                p0++;</span><br><span class="line">                p1++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(nums[p1]==<span class="number">1</span>)&#123;</span><br><span class="line">                p1++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                swap(nums[p1], nums[p2]);</span><br><span class="line">                p2--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="76、最小覆盖子串"><a href="#76、最小覆盖子串" class="headerlink" title="76、最小覆盖子串"></a>76、<a href="https://leetcode-cn.com/problems/minimum-window-substring/" target="_blank" rel="noopener">最小覆盖子串</a></h2><p>双指针 + 滑动窗口<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">minWindow</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">string</span> t)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">string</span> ans = <span class="string">""</span>;</span><br><span class="line">        <span class="keyword">if</span>(s.size()==<span class="number">0</span> || t.size()==<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> ans;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>, right = <span class="number">0</span>, matchs = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> minLen = INT_MAX;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt; window, need;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;t.size(); i++)</span><br><span class="line">            need[t[i]]++;</span><br><span class="line">        <span class="keyword">int</span> kinds = need.size();</span><br><span class="line">        <span class="keyword">while</span>(right&lt;s.size())&#123;</span><br><span class="line">            <span class="keyword">if</span>( ++window[s[right]] == need[s[right++]] )</span><br><span class="line">                matchs++;</span><br><span class="line">            <span class="keyword">if</span>(matchs==kinds)&#123;</span><br><span class="line">                <span class="keyword">while</span>(left&lt;right)&#123;</span><br><span class="line">                    <span class="keyword">if</span>( --window[s[left]] &lt; need[s[left++]] )&#123;</span><br><span class="line">                        matchs--;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(minLen&gt;right-(left<span class="number">-1</span>))&#123;</span><br><span class="line">                    minLen = right - (left<span class="number">-1</span>);</span><br><span class="line">                    ans = s.substr(left<span class="number">-1</span>, minLen);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> minLen==INT_MAX? <span class="string">""</span> : ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h2 id="77、组合"><a href="#77、组合" class="headerlink" title="77、组合"></a>77、<a href="https://leetcode-cn.com/problems/combinations/" target="_blank" rel="noopener">组合</a></h2><p>简单深搜<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">DFS</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; ans, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; tmp_ans, <span class="keyword">int</span> position, <span class="keyword">int</span> n, <span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n-position+<span class="number">1</span>+tmp_ans.size() &lt; k)</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        <span class="keyword">if</span>(tmp_ans.size()==k)&#123;</span><br><span class="line">            ans.push_back(tmp_ans);</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=position; i&lt;=n; i++)&#123;</span><br><span class="line">            tmp_ans.push_back(i);</span><br><span class="line">            DFS(ans, tmp_ans, i+<span class="number">1</span>, n, k);</span><br><span class="line">            tmp_ans.pop_back();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; combine(<span class="keyword">int</span> n, <span class="keyword">int</span> k) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; ans;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; tmp_ans;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++)&#123;</span><br><span class="line">            tmp_ans.push_back(i);</span><br><span class="line">            DFS(ans, tmp_ans, i+<span class="number">1</span>, n, k);</span><br><span class="line">            tmp_ans.pop_back();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h2 id="78、子集"><a href="#78、子集" class="headerlink" title="78、子集"></a>78、<a href="https://leetcode-cn.com/problems/subsets/" target="_blank" rel="noopener">子集</a></h2><p>深搜，水题一道<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">DFS</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; ans, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; tmp_ans, <span class="keyword">int</span> position, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span></span>&#123;</span><br><span class="line">        ans.push_back(tmp_ans);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=position; i&lt;nums.size(); i++)&#123;</span><br><span class="line">            tmp_ans.push_back(nums[i]);</span><br><span class="line">            DFS(ans, tmp_ans, i+<span class="number">1</span>, nums);</span><br><span class="line">            tmp_ans.pop_back();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; subsets(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; ans;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; tmp_ans;</span><br><span class="line">        DFS(ans, tmp_ans, <span class="number">0</span>, nums);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h2 id="79、单词搜索"><a href="#79、单词搜索" class="headerlink" title="79、单词搜索"></a>79、<a href="https://leetcode-cn.com/problems/word-search/" target="_blank" rel="noopener">单词搜索</a></h2><p>基础深搜题，注意剪枝即可。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> direct[<span class="number">4</span>][<span class="number">2</span>] = &#123;&#123;<span class="number">0</span>,<span class="number">1</span>&#125;, &#123;<span class="number">0</span>,<span class="number">-1</span>&#125;, &#123;<span class="number">1</span>,<span class="number">0</span>&#125;, &#123;<span class="number">-1</span>,<span class="number">0</span>&#125;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">judge</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> m, <span class="keyword">int</span> row, <span class="keyword">int</span> col)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> row&gt;=<span class="number">0</span> &amp;&amp; row&lt;n &amp;&amp; col&gt;=<span class="number">0</span> &amp;&amp; col&lt;m;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">DFS</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; board, <span class="built_in">string</span> word, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;&gt;&amp; used, <span class="keyword">int</span> row, <span class="keyword">int</span> col, <span class="keyword">int</span> pos)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(pos==word.size()<span class="number">-1</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        used[row][col] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">4</span>; i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> tmp_row = row + direct[i][<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">int</span> tmp_col = col + direct[i][<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span>(judge(board.size(), board[<span class="number">0</span>].size(), tmp_row, tmp_col) &amp;&amp; used[tmp_row][tmp_col]==<span class="literal">false</span> &amp;&amp; board[tmp_row][tmp_col]==word[pos+<span class="number">1</span>])&#123;</span><br><span class="line">                <span class="keyword">if</span>(DFS(board, word, used, tmp_row, tmp_col, pos+<span class="number">1</span>))</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        used[row][col] = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">exist</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; board, <span class="built_in">string</span> word)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = board.size(), m = board[<span class="number">0</span>].size();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;&gt; used(n, <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;(m, <span class="literal">false</span>));</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;m; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>( board[i][j]==word[<span class="number">0</span>] &amp;&amp; DFS(board, word, used, i, j, <span class="number">0</span>) )</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h2 id="80、删除排序数组中的重复项-II"><a href="#80、删除排序数组中的重复项-II" class="headerlink" title="80、删除排序数组中的重复项 II"></a>80、<a href="https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array-ii/" target="_blank" rel="noopener">删除排序数组中的重复项 II</a></h2><p>双指针的使用<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">removeDuplicates</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.size()&lt;=<span class="number">2</span>)</span><br><span class="line">            <span class="keyword">return</span> nums.size();</span><br><span class="line">        <span class="keyword">int</span> p_front=<span class="number">2</span>, p_back=<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">while</span>(p_back&lt;nums.size())&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[p_back]==nums[p_front<span class="number">-2</span>])</span><br><span class="line">                p_back++;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                nums[p_front++] = nums[p_back++];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> p_front;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;71、简化路径&quot;&gt;&lt;a href=&quot;#71、简化路径&quot; class=&quot;headerlink&quot; title=&quot;71、简化路径&quot;&gt;&lt;/a&gt;71、&lt;a href=&quot;https://leetcode-cn.com/problems/simplify-path/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;简化路径&lt;/a&gt;&lt;/h2&gt;&lt;p&gt;模拟题&lt;br&gt;&lt;figure class=&quot;highlight c++&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;31&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;32&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;33&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Solution&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt;:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;string&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;simplifyPath&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;built_in&quot;&gt;string&lt;/span&gt; path)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt;(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; i=&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;; i&amp;lt;path.length(); i++)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;(path[i&lt;span class=&quot;number&quot;&gt;-1&lt;/span&gt;]==&lt;span class=&quot;string&quot;&gt;&#39;/&#39;&lt;/span&gt; &amp;amp;&amp;amp; path[i]==&lt;span class=&quot;string&quot;&gt;&#39;/&#39;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                path.erase(i--,&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;(path[path.length()&lt;span class=&quot;number&quot;&gt;-1&lt;/span&gt;]==&lt;span class=&quot;string&quot;&gt;&#39;/&#39;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            path.erase(path.length()&lt;span class=&quot;number&quot;&gt;-1&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;built_in&quot;&gt;vector&lt;/span&gt;&amp;lt;&lt;span class=&quot;built_in&quot;&gt;string&lt;/span&gt;&amp;gt; fenduan;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; pos = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;, index;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;while&lt;/span&gt;(pos&amp;gt;=&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt; &amp;amp;&amp;amp; pos&amp;lt;path.length())&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            index = path.find(&lt;span class=&quot;string&quot;&gt;&#39;/&#39;&lt;/span&gt;, pos+&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            fenduan.push_back(path.substr(pos, index-pos));&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            pos = index;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;built_in&quot;&gt;string&lt;/span&gt; ans = &lt;span class=&quot;string&quot;&gt;&quot;&quot;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt;(&lt;span class=&quot;keyword&quot;&gt;auto&lt;/span&gt; i : fenduan)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;(i==&lt;span class=&quot;string&quot;&gt;&quot;/.&quot;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &lt;span class=&quot;keyword&quot;&gt;continue&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;(i==&lt;span class=&quot;string&quot;&gt;&quot;/..&quot;&lt;/span&gt;)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                index = ans.find_last_of(&lt;span class=&quot;string&quot;&gt;&#39;/&#39;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;(index&amp;gt;=&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt; &amp;amp;&amp;amp; index&amp;lt;ans.size())&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                    ans.erase(index);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                ans += i;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;(ans.size()==&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            ans = &lt;span class=&quot;string&quot;&gt;&quot;/&quot;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; ans;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="LeetCode" scheme="https://wangjibao.com.cn/categories/LeetCode/"/>
    
      <category term="LeetCode71-80" scheme="https://wangjibao.com.cn/categories/LeetCode/LeetCode71-80/"/>
    
    
      <category term="LeetCode" scheme="https://wangjibao.com.cn/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode61-70</title>
    <link href="https://wangjibao.com.cn/2019/08/28/LeetCode61-70/"/>
    <id>https://wangjibao.com.cn/2019/08/28/LeetCode61-70/</id>
    <published>2019-08-28T03:40:37.000Z</published>
    <updated>2019-08-28T05:28:36.687Z</updated>
    
    <content type="html"><![CDATA[<h2 id="61、旋转链表"><a href="#61、旋转链表" class="headerlink" title="61、旋转链表"></a>61、<a href="https://leetcode-cn.com/problems/rotate-list/" target="_blank" rel="noopener">旋转链表</a></h2><p>模拟题</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">rotateRight</span><span class="params">(ListNode* head, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(struct ListNode *ptr = head; ptr; ptr=ptr-&gt;next)&#123;</span><br><span class="line">            len++;</span><br><span class="line">            <span class="keyword">if</span>(ptr-&gt;next==<span class="literal">NULL</span>)&#123;</span><br><span class="line">                ptr-&gt;next = head;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(len==<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        k %= len;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=len-k; i++)</span><br><span class="line">            head = head-&gt;next;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">ans</span> = <span class="title">head</span>;</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;len; i++)</span><br><span class="line">            head = head-&gt;next;</span><br><span class="line">        head-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="62、不同路径"><a href="#62、不同路径" class="headerlink" title="62、不同路径"></a>62、<a href="https://leetcode-cn.com/problems/unique-paths/" target="_blank" rel="noopener">不同路径</a></h2><p>排列组合，当 <code>m</code> 和 <code>n</code> 较大时，应该使用 <code>Lucas</code> 定理。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">uniquePaths</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> total = m+n<span class="number">-2</span>;</span><br><span class="line">        <span class="keyword">int</span> frac = min(m<span class="number">-1</span>, n<span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> fenzi = <span class="number">1</span>, fenmu = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=frac; i++)&#123;</span><br><span class="line">            fenzi *= total-i+<span class="number">1</span>;</span><br><span class="line">            fenmu *= i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> fenzi/fenmu;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="63、不同路径-II"><a href="#63、不同路径-II" class="headerlink" title="63、不同路径 II"></a>63、<a href="https://leetcode-cn.com/problems/unique-paths-ii/" target="_blank" rel="noopener">不同路径 II</a></h2><p>同上一题，只不过加了障碍，判断一下即可。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">uniquePathsWithObstacles</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; obstacleGrid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = obstacleGrid.size(), m = obstacleGrid[<span class="number">0</span>].size();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt; ans(m, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; i++)&#123;</span><br><span class="line">            ans[<span class="number">0</span>] = i==<span class="number">0</span>? (obstacleGrid[i][<span class="number">0</span>]+<span class="number">1</span>)%<span class="number">2</span> : ((obstacleGrid[i][<span class="number">0</span>]+<span class="number">1</span>)%<span class="number">2</span> &amp;&amp; ans[<span class="number">0</span>]);</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>; j&lt;m; j++)</span><br><span class="line">                ans[j] = obstacleGrid[i][j]==<span class="number">1</span>?<span class="number">0</span>:ans[j<span class="number">-1</span>]+ans[j];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans[m<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="64、最小路径和"><a href="#64、最小路径和" class="headerlink" title="64、最小路径和"></a>64、<a href="https://leetcode-cn.com/problems/minimum-path-sum/" target="_blank" rel="noopener">最小路径和</a></h2><p>水 <code>dp</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minPathSum</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i, j;</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">1</span>; i&lt;grid.size(); i++)</span><br><span class="line">            grid[i][<span class="number">0</span>] += grid[i<span class="number">-1</span>][<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(j=<span class="number">1</span>; j&lt;grid[<span class="number">0</span>].size(); j++)</span><br><span class="line">            grid[<span class="number">0</span>][j] += grid[<span class="number">0</span>][j<span class="number">-1</span>];</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">1</span>; i&lt;grid.size(); i++)</span><br><span class="line">            <span class="keyword">for</span>(j=<span class="number">1</span>; j&lt;grid[<span class="number">0</span>].size(); j++)</span><br><span class="line">                grid[i][j] += min(grid[i<span class="number">-1</span>][j], grid[i][j<span class="number">-1</span>]);</span><br><span class="line">        <span class="keyword">return</span> grid[grid.size()<span class="number">-1</span>][grid[<span class="number">0</span>].size()<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="65、-有效数字"><a href="#65、-有效数字" class="headerlink" title="65、 有效数字"></a>65、<a href="https://leetcode-cn.com/problems/valid-number/" target="_blank" rel="noopener"> 有效数字</a></h2><p>见过的最恶心的题目</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isNumber</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; num(<span class="number">10</span>,<span class="number">0</span>);</span><br><span class="line">        s.erase(<span class="number">0</span>,s.find_first_not_of(<span class="string">" "</span>));</span><br><span class="line">        s.erase(s.find_last_not_of(<span class="string">" "</span>) + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span>(s[s.length()<span class="number">-1</span>]==<span class="string">'e'</span> || s[s.length()<span class="number">-1</span>]==<span class="string">'+'</span> || s[s.length()<span class="number">-1</span>]==<span class="string">'-'</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;s.length(); i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i]==<span class="string">'-'</span> || s[i]==<span class="string">'+'</span>)&#123;</span><br><span class="line">                num[<span class="number">0</span>]++;</span><br><span class="line">                <span class="keyword">if</span>(i&gt;<span class="number">0</span> &amp;&amp; (s[i<span class="number">-1</span>]==<span class="string">'-'</span> || s[i<span class="number">-1</span>]==<span class="string">'+'</span>))</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(s[i]==<span class="string">'e'</span>)</span><br><span class="line">                num[<span class="number">1</span>]++;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(s[i]&gt;=<span class="string">'0'</span> &amp;&amp; s[i]&lt;=<span class="string">'9'</span>)</span><br><span class="line">                num[<span class="number">3</span>]++;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(s[i]==<span class="string">'.'</span> &amp;&amp; num[<span class="number">1</span>]==<span class="number">0</span>)&#123;</span><br><span class="line">                num[<span class="number">2</span>]++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(num[<span class="number">0</span>]&gt;<span class="number">2</span> || num[<span class="number">1</span>]&gt;<span class="number">1</span> || num[<span class="number">2</span>]&gt;<span class="number">1</span> || s[<span class="number">0</span>]==<span class="string">'e'</span> || num[<span class="number">3</span>]==<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(num[<span class="number">1</span>]==<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">int</span> index = s.find(<span class="string">'e'</span>);</span><br><span class="line">            <span class="keyword">if</span>(index==s.length()<span class="number">-1</span> || (index==<span class="number">1</span> &amp;&amp; s[<span class="number">0</span>]==<span class="string">'.'</span>) || (index&gt;<span class="number">0</span> &amp;&amp; (s[index<span class="number">-1</span>]==<span class="string">'-'</span> || s[index<span class="number">-1</span>]==<span class="string">'+'</span>)))</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(num[<span class="number">0</span>])&#123;</span><br><span class="line">            <span class="keyword">int</span> index = s.find(<span class="string">'-'</span>);</span><br><span class="line">            <span class="keyword">if</span>(index&lt;<span class="number">0</span> || index&gt;=s.length())</span><br><span class="line">                index = s.find(<span class="string">'+'</span>);</span><br><span class="line">            <span class="keyword">if</span>(index==s.length()<span class="number">-1</span> || (index&gt;<span class="number">0</span> &amp;&amp; ((<span class="built_in">isdigit</span>(s[index<span class="number">-1</span>]) &amp;&amp; <span class="built_in">isdigit</span>(s[index+<span class="number">1</span>])) || s[index<span class="number">-1</span>]==<span class="string">'.'</span>)))</span><br><span class="line">               <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=index+<span class="number">1</span>; i&lt;s.length(); i++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(s[i]&gt;=<span class="string">'0'</span> &amp;&amp; s[i]&lt;=<span class="string">'9'</span>)</span><br><span class="line">                    sum++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(sum==<span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="66、-加一"><a href="#66、-加一" class="headerlink" title="66、 加一"></a>66、<a href="https://leetcode-cn.com/problems/plus-one/" target="_blank" rel="noopener"> 加一</a></h2><p>模拟题，考虑下进位即可。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; plusOne(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; digits) &#123;</span><br><span class="line">        <span class="keyword">int</span> num = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=digits.size()<span class="number">-1</span>; i&gt;=<span class="number">0.</span>; i--)&#123;</span><br><span class="line">            num += digits[i];</span><br><span class="line">            digits[i] = num % <span class="number">10</span>;</span><br><span class="line">            num /= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(num)</span><br><span class="line">            digits.insert(digits.begin(), <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> digits;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="67、二进制求和"><a href="#67、二进制求和" class="headerlink" title="67、二进制求和"></a>67、<a href="https://leetcode-cn.com/problems/add-binary/" target="_blank" rel="noopener">二进制求和</a></h2><p>模拟题，考虑二进制进位即可。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">addBinary</span><span class="params">(<span class="built_in">string</span> a, <span class="built_in">string</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">string</span> ans = <span class="string">""</span>;</span><br><span class="line">        <span class="keyword">int</span> flag = <span class="number">0</span>, sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> len_a = a.size(), len_b = b.size();</span><br><span class="line">        <span class="keyword">while</span>(len_a&gt;<span class="number">0</span> || len_b&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            sum = flag;</span><br><span class="line">            <span class="keyword">if</span>(len_a&gt;<span class="number">0</span>)</span><br><span class="line">                sum += a[--len_a]-<span class="string">'0'</span>;</span><br><span class="line">            <span class="keyword">if</span>(len_b&gt;<span class="number">0</span>)</span><br><span class="line">                sum += b[--len_b]-<span class="string">'0'</span>;</span><br><span class="line">            flag = sum/<span class="number">2</span>;            ans.insert(ans.begin(), <span class="string">'0'</span>+sum%<span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(flag)</span><br><span class="line">            ans = <span class="string">'1'</span> + ans;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="68、文本左右对齐"><a href="#68、文本左右对齐" class="headerlink" title="68、文本左右对齐"></a>68、<a href="https://leetcode-cn.com/problems/text-justification/" target="_blank" rel="noopener">文本左右对齐</a></h2><p>模拟题，对空格数做判断。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; fullJustify(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; words, <span class="keyword">int</span> maxWidth) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; ans;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; tmp;</span><br><span class="line">        <span class="keyword">int</span> len = <span class="number">0</span>, pos = <span class="number">0</span>, i;</span><br><span class="line">        <span class="keyword">while</span>(pos&lt;words.size())&#123;</span><br><span class="line">            ans.clear();</span><br><span class="line">            i = pos;</span><br><span class="line">            ans.push_back(words[i]);</span><br><span class="line">            len = words[i++].length()+<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span>(i&lt;words.size() &amp;&amp; len+words[i].length()&lt;=maxWidth)&#123;</span><br><span class="line">                ans.push_back(words[i]);</span><br><span class="line">                len += words[i++].length() + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            tmp.push_back(ans);</span><br><span class="line">            pos = i;</span><br><span class="line">        &#125;</span><br><span class="line">        ans.clear();</span><br><span class="line">        <span class="built_in">string</span> tmp_ans;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>; k&lt;tmp.size()<span class="number">-1</span>; k++)&#123;</span><br><span class="line">            len = <span class="number">0</span>;</span><br><span class="line">            tmp_ans = <span class="string">""</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;tmp[k].size(); j++)</span><br><span class="line">                len += tmp[k][j].length();</span><br><span class="line">            <span class="keyword">int</span> konggeshu, yushu;</span><br><span class="line">            <span class="keyword">if</span>(tmp[k].size()==<span class="number">1</span>)&#123;</span><br><span class="line">                tmp_ans = tmp[k][<span class="number">0</span>] + <span class="built_in">string</span>(maxWidth-tmp[k][<span class="number">0</span>].length(), <span class="string">' '</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                konggeshu = (maxWidth-len)/(tmp[k].size()<span class="number">-1</span>);</span><br><span class="line">                yushu = (maxWidth-len)%(tmp[k].size()<span class="number">-1</span>);</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;tmp[k].size()<span class="number">-1</span>; i++)&#123;</span><br><span class="line">                    tmp_ans += tmp[k][i]+<span class="built_in">string</span>(konggeshu, <span class="string">' '</span>);</span><br><span class="line">                    <span class="keyword">if</span>(yushu&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                        tmp_ans += <span class="string">" "</span>;</span><br><span class="line">                        yushu--;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                tmp_ans += tmp[k][tmp[k].size()<span class="number">-1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            ans.push_back(tmp_ans);</span><br><span class="line">        &#125;</span><br><span class="line">        tmp_ans = tmp[tmp.size()<span class="number">-1</span>][<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;tmp[tmp.size()<span class="number">-1</span>].size(); i++)</span><br><span class="line">            tmp_ans += <span class="string">" "</span> + tmp[tmp.size()<span class="number">-1</span>][i];</span><br><span class="line">        tmp_ans += <span class="built_in">string</span>(maxWidth-tmp_ans.length(), <span class="string">' '</span>);</span><br><span class="line">        ans.push_back(tmp_ans);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="69、x-的平方根"><a href="#69、x-的平方根" class="headerlink" title="69、x 的平方根"></a>69、<a href="https://leetcode-cn.com/problems/sqrtx/" target="_blank" rel="noopener">x 的平方根</a></h2><p>直接用库函数，思考如何自己手动计算一个数的平方根。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">mySqrt</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">int</span>(<span class="built_in">sqrt</span>(x));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="70、爬楼梯"><a href="#70、爬楼梯" class="headerlink" title="70、爬楼梯"></a>70、<a href="https://leetcode-cn.com/problems/climbing-stairs/" target="_blank" rel="noopener">爬楼梯</a></h2><p>斐波那契数列，这里使用矩阵快速幂加速。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">transferMatrix</span>&#123;</span></span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> matrix[<span class="number">2</span>][<span class="number">2</span>];</span><br><span class="line">    transferMatrix <span class="keyword">operator</span>*(<span class="keyword">const</span> transferMatrix&amp; matrix_tmp)&#123;</span><br><span class="line">        transferMatrix matrix_ans;</span><br><span class="line">        <span class="built_in">memset</span>(matrix_ans.matrix, <span class="number">0</span>, <span class="keyword">sizeof</span>(matrix_ans.matrix));</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">2</span>; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;<span class="number">2</span>; j++)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>; k&lt;<span class="number">2</span>; k++)&#123;</span><br><span class="line">                    matrix_ans.matrix[i][j] += matrix[i][k] * matrix_tmp.matrix[k][j];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> matrix_ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">transferMatrix <span class="title">quick_pow</span><span class="params">(transferMatrix a, <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">        transferMatrix ans;</span><br><span class="line">        ans.matrix[<span class="number">0</span>][<span class="number">0</span>] = ans.matrix[<span class="number">1</span>][<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        ans.matrix[<span class="number">0</span>][<span class="number">1</span>] = ans.matrix[<span class="number">1</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(n)&#123;</span><br><span class="line">            <span class="keyword">if</span>(n%<span class="number">2</span>)</span><br><span class="line">                ans = ans*a;</span><br><span class="line">            a = a*a;</span><br><span class="line">            n /= <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">climbStairs</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        transferMatrix ans;</span><br><span class="line">        ans.matrix[<span class="number">0</span>][<span class="number">0</span>] = ans.matrix[<span class="number">0</span>][<span class="number">1</span>] = ans.matrix[<span class="number">1</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        ans.matrix[<span class="number">1</span>][<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">        ans = quick_pow(ans, n);</span><br><span class="line">        <span class="keyword">return</span> ans.matrix[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;61、旋转链表&quot;&gt;&lt;a href=&quot;#61、旋转链表&quot; class=&quot;headerlink&quot; title=&quot;61、旋转链表&quot;&gt;&lt;/a&gt;61、&lt;a href=&quot;https://leetcode-cn.com/problems/rotate-list/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;旋转链表&lt;/a&gt;&lt;/h2&gt;&lt;p&gt;模拟题&lt;/p&gt;
&lt;figure class=&quot;highlight c++&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;31&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;/**&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt; * Definition for singly-linked list.&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt; * struct ListNode &amp;#123;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt; *     int val;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt; *     ListNode *next;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt; *     ListNode(int x) : val(x), next(NULL) &amp;#123;&amp;#125;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt; * &amp;#125;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt; */&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Solution&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt;:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;ListNode* &lt;span class=&quot;title&quot;&gt;rotateRight&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(ListNode* head, &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; k)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; len = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt;(struct ListNode *ptr = head; ptr; ptr=ptr-&amp;gt;next)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            len++;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;(ptr-&amp;gt;next==&lt;span class=&quot;literal&quot;&gt;NULL&lt;/span&gt;)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                ptr-&amp;gt;next = head;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &lt;span class=&quot;keyword&quot;&gt;break&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;(len==&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;literal&quot;&gt;NULL&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        k %= len;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt;(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; i=&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;; i&amp;lt;=len-k; i++)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            head = head-&amp;gt;next;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;ListNode&lt;/span&gt; *&lt;span class=&quot;title&quot;&gt;ans&lt;/span&gt; = &lt;span class=&quot;title&quot;&gt;head&lt;/span&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt;(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; i=&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;; i&amp;lt;len; i++)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            head = head-&amp;gt;next;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        head-&amp;gt;next = &lt;span class=&quot;literal&quot;&gt;NULL&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; ans;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="LeetCode" scheme="https://wangjibao.com.cn/categories/LeetCode/"/>
    
      <category term="LeetCode61-70" scheme="https://wangjibao.com.cn/categories/LeetCode/LeetCode61-70/"/>
    
    
      <category term="LeetCode" scheme="https://wangjibao.com.cn/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode51-60</title>
    <link href="https://wangjibao.com.cn/2019/08/28/LeetCode51-60/"/>
    <id>https://wangjibao.com.cn/2019/08/28/LeetCode51-60/</id>
    <published>2019-08-28T03:39:40.000Z</published>
    <updated>2019-08-28T06:25:27.914Z</updated>
    
    <content type="html"><![CDATA[<h2 id="51、N皇后"><a href="#51、N皇后" class="headerlink" title="51、N皇后"></a>51、<a href="https://leetcode-cn.com/problems/n-queens/" target="_blank" rel="noopener">N皇后</a></h2><p>回溯法</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> record[<span class="number">100</span>];</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> step)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;step; i++)</span><br><span class="line">            <span class="keyword">if</span>(record[i]==record[step] || <span class="built_in">fabs</span>(i-step)==<span class="built_in">fabs</span>(record[i]-record[step]))</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">DFS</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; &amp;ans, <span class="keyword">int</span> n, <span class="keyword">int</span> step)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(step&gt;n)&#123;</span><br><span class="line">            <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; cur_ans(n,<span class="built_in">string</span>(n,<span class="string">'.'</span>));</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++)</span><br><span class="line">                cur_ans[i<span class="number">-1</span>][record[i]<span class="number">-1</span>] = <span class="string">'Q'</span>;</span><br><span class="line">            ans.push_back(cur_ans);</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++)&#123;</span><br><span class="line">            record[step] = i;</span><br><span class="line">            <span class="keyword">if</span>(check(n, step))</span><br><span class="line">                DFS(ans, n, step+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; solveNQueens(<span class="keyword">int</span> n) &#123;</span><br><span class="line">        <span class="built_in">memset</span>(record, <span class="number">0</span>, <span class="keyword">sizeof</span>(record));</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; ans;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++)&#123;</span><br><span class="line">            record[<span class="number">1</span>] = i;</span><br><span class="line">            DFS(ans, n, <span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="52、N皇后-II"><a href="#52、N皇后-II" class="headerlink" title="52、N皇后 II"></a>52、<a href="https://leetcode-cn.com/problems/n-queens-ii/" target="_blank" rel="noopener">N皇后 II</a></h2><p>同上一题</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> record[<span class="number">100</span>];</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> step)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;step; i++)</span><br><span class="line">            <span class="keyword">if</span>(record[i]==record[step] || <span class="built_in">fabs</span>(i-step)==<span class="built_in">fabs</span>(record[i]-record[step]))</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">DFS</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> step)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(step&gt;n)&#123;</span><br><span class="line">            ans++;</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++)&#123;</span><br><span class="line">            record[step] = i;</span><br><span class="line">            <span class="keyword">if</span>(check(n, step))</span><br><span class="line">                DFS(n, step+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">totalNQueens</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">memset</span>(record, <span class="number">0</span>, <span class="keyword">sizeof</span>(record));</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++)&#123;</span><br><span class="line">            record[<span class="number">1</span>] = i;</span><br><span class="line">            DFS(n, <span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="53、最大子序和"><a href="#53、最大子序和" class="headerlink" title="53、最大子序和"></a>53、<a href="https://leetcode-cn.com/problems/maximum-subarray/" target="_blank" rel="noopener">最大子序和</a></h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxSubArray</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> max_sum = <span class="number">-9999999999999</span>, sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> i : nums)&#123;</span><br><span class="line">            sum += i;</span><br><span class="line">            max_sum = max(max_sum, sum);</span><br><span class="line">            <span class="keyword">if</span>( sum&lt;=<span class="number">0</span> )</span><br><span class="line">                sum = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">int</span>(max_sum);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="54、螺旋矩阵"><a href="#54、螺旋矩阵" class="headerlink" title="54、螺旋矩阵"></a>54、<a href="https://leetcode-cn.com/problems/spiral-matrix/" target="_blank" rel="noopener">螺旋矩阵</a></h2><p>模拟题</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; spiralOrder(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; matrix) &#123;</span><br><span class="line">        <span class="keyword">int</span> direct[<span class="number">4</span>][<span class="number">2</span>] = &#123;&#123;<span class="number">0</span>,<span class="number">1</span>&#125;, &#123;<span class="number">1</span>,<span class="number">0</span>&#125;, &#123;<span class="number">0</span>,<span class="number">-1</span>&#125;, &#123;<span class="number">-1</span>,<span class="number">0</span>&#125;&#125;;</span><br><span class="line">        <span class="keyword">int</span> direction = <span class="number">0</span>, row = <span class="number">0</span>, col = <span class="number">0</span>, iter;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line">        <span class="keyword">if</span>(matrix.size()==<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> ans;</span><br><span class="line">        <span class="keyword">int</span> total_nums = <span class="number">0</span>, rotal = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(total_nums &lt; matrix.size() * matrix[<span class="number">0</span>].size())&#123;</span><br><span class="line">            <span class="keyword">if</span>(direction%<span class="number">2</span>)</span><br><span class="line">                iter = matrix.size() - (<span class="number">2</span>*(rotal/<span class="number">4</span>) + <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                iter = matrix[<span class="number">0</span>].size() - (<span class="number">2</span>*(rotal/<span class="number">4</span>) + <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span>(direction==<span class="number">0</span> &amp;&amp; rotal&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                row += <span class="number">1</span>;</span><br><span class="line">                col += <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(matrix.size()*matrix[<span class="number">0</span>].size()-total_nums==<span class="number">1</span>)&#123;</span><br><span class="line">                ans.push_back(matrix[row][col]);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=iter; i++)&#123;</span><br><span class="line">                ans.push_back(matrix[row][col]);</span><br><span class="line">                total_nums++;</span><br><span class="line">                row += direct[direction][<span class="number">0</span>];</span><br><span class="line">                col += direct[direction][<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            rotal += <span class="number">1</span>;</span><br><span class="line">            direction = (direction+<span class="number">1</span>)%<span class="number">4</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="55、跳跃游戏"><a href="#55、跳跃游戏" class="headerlink" title="55、跳跃游戏"></a>55、<a href="https://leetcode-cn.com/problems/jump-game/" target="_blank" rel="noopener">跳跃游戏</a></h2><p>判断能否到达最后一个位置，倒序遍历判断即可。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">canJump</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = nums.size();</span><br><span class="line">        <span class="keyword">int</span> pos = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=len<span class="number">-2</span>; i&gt;=<span class="number">0</span>; i--)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i]==<span class="number">0</span> &amp;&amp; pos==<span class="number">-1</span>)</span><br><span class="line">                pos = i;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(pos-i &lt; nums[i])</span><br><span class="line">                pos = <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pos==<span class="number">-1</span>? <span class="literal">true</span> : <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="56、合并区间"><a href="#56、合并区间" class="headerlink" title="56、合并区间"></a>56、<a href="https://leetcode-cn.com/problems/merge-intervals/" target="_blank" rel="noopener">合并区间</a></h2><p>模拟题</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; vec1, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; vec2)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(vec1[<span class="number">0</span>]!=vec2[<span class="number">0</span>])</span><br><span class="line">            <span class="keyword">return</span> vec1[<span class="number">0</span>] &lt; vec2[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">return</span> vec1[<span class="number">1</span>] &lt; vec2[<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; merge(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; intervals) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt; <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; ans;</span><br><span class="line">        <span class="keyword">if</span>(intervals.size()==<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> ans;</span><br><span class="line">        sort(intervals.begin(), intervals.end(), cmp);</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; tmp_ans = intervals[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;intervals.size(); i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(tmp_ans[<span class="number">1</span>] &gt;= intervals[i][<span class="number">0</span>])</span><br><span class="line">                tmp_ans[<span class="number">1</span>] = max(intervals[i][<span class="number">1</span>], tmp_ans[<span class="number">1</span>]);</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                ans.push_back(tmp_ans);</span><br><span class="line">                tmp_ans = intervals[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ans.push_back(tmp_ans);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="57、插入区间"><a href="#57、插入区间" class="headerlink" title="57、插入区间"></a>57、<a href="https://leetcode-cn.com/problems/insert-interval/" target="_blank" rel="noopener">插入区间</a></h2><p>模拟题</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; insert(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; intervals, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; newInterval) &#123;</span><br><span class="line">        <span class="keyword">if</span>(intervals.size()==<span class="number">0</span>)&#123;</span><br><span class="line">            intervals.push_back(newInterval);</span><br><span class="line">            <span class="keyword">return</span> intervals;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> pos = <span class="number">-1</span>, i = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;intervals.size(); i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(newInterval[<span class="number">0</span>]&gt;intervals[i][<span class="number">0</span>])&#123; <span class="comment">//²åÔÚ i+1 µÄÎ»ÖÃ</span></span><br><span class="line">                pos = i;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        pos++;</span><br><span class="line">        <span class="keyword">for</span>(i=pos<span class="number">-1</span>; i&gt;=<span class="number">0</span>; i--)&#123;</span><br><span class="line">            <span class="keyword">if</span>(intervals[i][<span class="number">1</span>]&gt;=newInterval[<span class="number">0</span>])&#123;</span><br><span class="line">                newInterval[<span class="number">0</span>] = min(intervals[i][<span class="number">0</span>], newInterval[<span class="number">0</span>]);</span><br><span class="line">                newInterval[<span class="number">1</span>] = max(newInterval[<span class="number">1</span>], intervals[i][<span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(j=pos; j&lt;intervals.size(); j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(newInterval[<span class="number">1</span>]&gt;=intervals[j][<span class="number">0</span>])&#123;</span><br><span class="line">                newInterval[<span class="number">0</span>] = min(intervals[j][<span class="number">0</span>], newInterval[<span class="number">0</span>]);</span><br><span class="line">                newInterval[<span class="number">1</span>] = max(newInterval[<span class="number">1</span>], intervals[j][<span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        intervals.erase(intervals.begin()+(i+<span class="number">1</span>), intervals.begin()+j);</span><br><span class="line">        intervals.insert(intervals.begin()+(i+<span class="number">1</span>),newInterval);</span><br><span class="line">        <span class="keyword">return</span> intervals;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="58、最后一个单词的长度"><a href="#58、最后一个单词的长度" class="headerlink" title="58、最后一个单词的长度"></a>58、<a href="https://leetcode-cn.com/problems/length-of-last-word/" target="_blank" rel="noopener">最后一个单词的长度</a></h2><p>水题</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">lengthOfLastWord</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        s.erase(<span class="number">0</span>, s.find_first_not_of(<span class="string">" "</span>));  <span class="comment">//find_ 返回下标</span></span><br><span class="line">        s.erase(s.find_last_not_of(<span class="string">" "</span>)+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span>(s.size()==<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> index = s.find_last_of(<span class="string">" "</span>);</span><br><span class="line">        <span class="keyword">if</span>(index==s.size())</span><br><span class="line">            <span class="keyword">return</span> s.size();</span><br><span class="line">        <span class="keyword">return</span> s.size()-index<span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="59、螺旋矩阵-II"><a href="#59、螺旋矩阵-II" class="headerlink" title="59、螺旋矩阵 II"></a>59、<a href="https://leetcode-cn.com/problems/spiral-matrix-ii/" target="_blank" rel="noopener">螺旋矩阵 II</a></h2><p>模拟题</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; generateMatrix(<span class="keyword">int</span> n) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt; <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; ans(n, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(n));</span><br><span class="line">        <span class="keyword">int</span> direct[<span class="number">4</span>][<span class="number">2</span>] = &#123;&#123;<span class="number">0</span>,<span class="number">1</span>&#125;, &#123;<span class="number">1</span>,<span class="number">0</span>&#125;, &#123;<span class="number">0</span>,<span class="number">-1</span>&#125;, &#123;<span class="number">-1</span>,<span class="number">0</span>&#125;&#125;;</span><br><span class="line">        <span class="keyword">int</span> direction = <span class="number">0</span>, row = <span class="number">0</span>, col = <span class="number">0</span>, iter;</span><br><span class="line">        <span class="keyword">int</span> total_nums = <span class="number">1</span>, rotal = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(total_nums&lt;=n*n)&#123;</span><br><span class="line">            iter = n - (<span class="number">2</span>*(rotal/<span class="number">4</span>) + <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span>(direction==<span class="number">0</span> &amp;&amp; rotal&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                row += <span class="number">1</span>;</span><br><span class="line">                col += <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(n*n==total_nums)&#123;</span><br><span class="line">                ans[row][col] = total_nums++;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=iter; i++)&#123;</span><br><span class="line">                ans[row][col] = total_nums++;</span><br><span class="line">                row += direct[direction][<span class="number">0</span>];</span><br><span class="line">                col += direct[direction][<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            rotal += <span class="number">1</span>;</span><br><span class="line">            direction = (direction+<span class="number">1</span>)%<span class="number">4</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="60、第k个排列"><a href="#60、第k个排列" class="headerlink" title="60、第k个排列"></a>60、<a href="https://leetcode-cn.com/problems/permutation-sequence/" target="_blank" rel="noopener">第k个排列</a></h2><p>逆康拓展开的应用, 康拓展开公式为：<br>$$<br>X=a[n]\times(n-1)!+a[n-1]\times(n-2)!+…+a[i]\times(i-1)!+…+a[1]\times0!<br>$$<br>其中 <code>a[n]</code> 代表当前位置之前比自己小的未出现过的数字的个数。例如：</p><p>计算<code>34152</code> 的康托展开值为：<br>$$<br>X = 2 \times 4! + 2 \times 3! + 0 \times 2! + 1 \times 1! + 0 \times 0! = 61<br>$$</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">getPermutation</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">string</span> ans = <span class="string">""</span>;</span><br><span class="line">        <span class="keyword">int</span> nums[<span class="number">9</span>] = &#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">6</span>, <span class="number">24</span>, <span class="number">120</span>, <span class="number">720</span>, <span class="number">720</span>*<span class="number">7</span>, <span class="number">720</span>*<span class="number">56</span>&#125;;</span><br><span class="line">        <span class="keyword">bool</span> book[<span class="number">10</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">10</span>; i++)</span><br><span class="line">            book[i] = <span class="literal">false</span>;</span><br><span class="line">        k = k<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=n<span class="number">-1</span>; i&gt;=<span class="number">0</span>; i--)&#123;</span><br><span class="line">            <span class="keyword">int</span> large_num = k/nums[i];</span><br><span class="line">            k %= nums[i];</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(large_num==<span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">int</span> j=i; j&lt;=n; j++)&#123;</span><br><span class="line">                        <span class="keyword">if</span>(book[j]==<span class="literal">false</span>)&#123;</span><br><span class="line">                            ans += <span class="string">'0'</span> + j;</span><br><span class="line">                            book[j] = <span class="literal">true</span>;</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(book[i]==<span class="literal">false</span>)</span><br><span class="line">                    large_num--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;51、N皇后&quot;&gt;&lt;a href=&quot;#51、N皇后&quot; class=&quot;headerlink&quot; title=&quot;51、N皇后&quot;&gt;&lt;/a&gt;51、&lt;a href=&quot;https://leetcode-cn.com/problems/n-queens/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;N皇后&lt;/a&gt;&lt;/h2&gt;&lt;p&gt;回溯法&lt;/p&gt;
&lt;figure class=&quot;highlight c++&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;31&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;32&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;33&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Solution&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt;:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; record[&lt;span class=&quot;number&quot;&gt;100&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;bool&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;check&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; n, &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; step)&lt;/span&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt;(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; i=&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;; i&amp;lt;step; i++)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;(record[i]==record[step] || &lt;span class=&quot;built_in&quot;&gt;fabs&lt;/span&gt;(i-step)==&lt;span class=&quot;built_in&quot;&gt;fabs&lt;/span&gt;(record[i]-record[step]))&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;literal&quot;&gt;false&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;literal&quot;&gt;true&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;DFS&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;built_in&quot;&gt;vector&lt;/span&gt;&amp;lt;&lt;span class=&quot;built_in&quot;&gt;vector&lt;/span&gt;&amp;lt;&lt;span class=&quot;built_in&quot;&gt;string&lt;/span&gt;&amp;gt;&amp;gt; &amp;amp;ans, &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; n, &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; step)&lt;/span&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;(step&amp;gt;n)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;built_in&quot;&gt;vector&lt;/span&gt;&amp;lt;&lt;span class=&quot;built_in&quot;&gt;string&lt;/span&gt;&amp;gt; cur_ans(n,&lt;span class=&quot;built_in&quot;&gt;string&lt;/span&gt;(n,&lt;span class=&quot;string&quot;&gt;&#39;.&#39;&lt;/span&gt;));&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt;(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; i=&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;; i&amp;lt;=n; i++)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                cur_ans[i&lt;span class=&quot;number&quot;&gt;-1&lt;/span&gt;][record[i]&lt;span class=&quot;number&quot;&gt;-1&lt;/span&gt;] = &lt;span class=&quot;string&quot;&gt;&#39;Q&#39;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            ans.push_back(cur_ans);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; ;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt;(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; i=&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;; i&amp;lt;=n; i++)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            record[step] = i;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;(check(n, step))&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                DFS(ans, n, step+&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;vector&lt;/span&gt;&amp;lt;&lt;span class=&quot;built_in&quot;&gt;vector&lt;/span&gt;&amp;lt;&lt;span class=&quot;built_in&quot;&gt;string&lt;/span&gt;&amp;gt;&amp;gt; solveNQueens(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; n) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;built_in&quot;&gt;memset&lt;/span&gt;(record, &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;, &lt;span class=&quot;keyword&quot;&gt;sizeof&lt;/span&gt;(record));&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;built_in&quot;&gt;vector&lt;/span&gt;&amp;lt;&lt;span class=&quot;built_in&quot;&gt;vector&lt;/span&gt;&amp;lt;&lt;span class=&quot;built_in&quot;&gt;string&lt;/span&gt;&amp;gt;&amp;gt; ans;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt;(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; i=&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;; i&amp;lt;=n; i++)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            record[&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;] = i;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            DFS(ans, n, &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; ans;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="LeetCode" scheme="https://wangjibao.com.cn/categories/LeetCode/"/>
    
      <category term="LeetCode51-60" scheme="https://wangjibao.com.cn/categories/LeetCode/LeetCode51-60/"/>
    
    
      <category term="LeetCode" scheme="https://wangjibao.com.cn/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>加密流量测量和分析</title>
    <link href="https://wangjibao.com.cn/2019/07/07/%E5%8A%A0%E5%AF%86%E6%B5%81%E9%87%8F%E6%B5%8B%E9%87%8F%E5%92%8C%E5%88%86%E6%9E%90/"/>
    <id>https://wangjibao.com.cn/2019/07/07/加密流量测量和分析/</id>
    <published>2019-07-07T01:16:31.000Z</published>
    <updated>2019-08-28T07:38:55.867Z</updated>
    
    <content type="html"><![CDATA[<h5 id="一、加密与非加密流量识别"><a href="#一、加密与非加密流量识别" class="headerlink" title="一、加密与非加密流量识别"></a>一、加密与非加密流量识别</h5><p>1、利用 <strong>信息熵</strong> 的方法对加密流量进行识别。</p><p>对不同类型的文件，如文本、图片、压缩文件、加密文件等的前 <strong><code>1KB</code></strong>  数据的熵进行计算分析，可以发现文本文件的熵处于较低水平，压缩文件和加密文件的熵处于较高的水平，且两者较难区分。</p><p>多元组熵的定义：</p><p>（1）n元字符组集合指以大小为 n 的滑动窗口对报文序列 P 进行切割后得到的字符串 $s_i (1 \le i \le L-n+1)$ 的集合，L 表示分析报文序列以 <strong>字节</strong> 为单位的长度：<br>$$<br>S_n = \lbrace s_1, s_2, …, s_{L-n+1} \rbrace<br>$$<br> 如 <code>“data.dat”</code> 对应的二元字符组集合为 $S_2 = \lbrace da, at, ta, a., .d, da, at \rbrace​$。</p><a id="more"></a><p>（2）从 n 元字符组集合中各元素出现的频率进行考虑，选择 n 元字符组集合中出现频数高于 k 的元素 $s\prime_{i, k}(1 \le i \le m)$ ，并统计其在集合中出现的频数 $f_{i, k}$ ，组成 k 频 n 元字符组集合为：<br>$$<br>S\prime_{n,k} = \lbrace s\prime_{1,k}:f_{1,k} ,\ \ s\prime_{2,k}:f_{2,k},\ \dots \ ,s\prime_{m,k}:f_{m,k}\rbrace<br>$$<br>其中，频数阈值 k 为 [1, L-n+1] 区间内的整数， $m(0 \le m \le n)​$ 表示频数不小于 k 的不重复元素的个数。在上文例子中，若取 $n=2, k=1​$ ，则有 $S\prime_{2,1} = \lbrace da:2,\  at:2,\  ta:1,\  a.:1,\  .d:1\rbrace​$ ; 若取 n=2, k=2, 则有 $S\prime_{2,2} = \lbrace da:2, \ at:2\rbrace​$。</p><p>根据以上定义， k 频 n 元字符组集合 $S\prime_{n,k}​$ 的信息熵可以表示为：<br>$$<br>H_{n,k} = -\sum_{i=1}^{m} P(s\prime_{i,k}) log_2P(s\prime_{i,k})<br>$$<br>其中，$P\prime_{i,k} = f_{i,k}/\sum_{t=1}^{m}f_{t,k}​$。</p><p>（3）若对长度 n, 频数阈值 k 各取不同的值时，则可以得到一系列关于报文序列 P 的熵值特征，就构成了多元组熵值特征集：<br>$$<br>H = \lbrace H_{n,k} \ \rvert \ n \in[N_a, N_b], k \in [K_a, K_b] \rbrace<br>$$<br>其中，H 中元素(熵值) 的个数为 $(N_b - N_a) \times (K_b - K_a)​$ 。一般地，对 n, k 的取值区间分别定义为 $[1, N]  和 [1, K]​$ 。在上例中，取 N=2, K=2，则序列 <code>“data.dat”</code> 的多元熵值特征集为 $H = \lbrace H_{1,1}\approx1.906, \ H_{1,2}\approx0.835, \ H_{2,1}\approx1.514, H_{2,2}\approx1\rbrace​$。</p><p>2、利用 <strong>累加和检测</strong> 的方法对加密流量进行识别。</p><p>多元组熵是以字节为单位的随机性检测，其需要一定数量的数据，计算相对复杂；而累加和检验是以比特位单位的随机性检测，通常只需要较少的数据即可有较好的检验效果，且具有较快的计算速度。</p><p>累加和检验有正向和反向两种模式，两个模式的区别仅在于遍历顺序，其中，正向模式下的累加和检测的步骤如下：</p><ul><li><p>将比特序列 $\varepsilon$ 调整为 $(-1, 1)$ 的形式的序列 X。 $X_i = 2\varepsilon_i - 1$</p></li><li><p>计算序列 X 的前 k 项和 $S_k$</p></li><li><p>计算正向模式下 $\lvert S_k \rvert$ 的最大值 z</p></li><li><p>计算检验值 P</p></li></ul><p>P 的取值一般在 $0\thicksim1$ 之间，其值越大，则待检测序列的随机性越高。通常情况下，设定一个 $\alpha$ 为阈值，当 $P &gt; \alpha$ ，接受检验序列为随机，反之，则拒绝随机性假设。</p><h5 id="二、加密流量应用服务识别"><a href="#二、加密流量应用服务识别" class="headerlink" title="二、加密流量应用服务识别"></a>二、加密流量应用服务识别</h5><p><strong>1、基于选择性集成的特征选择方法</strong></p><p>该方法可以克服基于端口和深度包检测方法的不足，但特征属性中包含的冗余和不相关特征会增加模型复杂度、降低模型可信度，导致分类效果和效率同时下降。</p><p>算法流程：第一部分，将多个特征选择器选取的特征子集根据评价指标进行排序，再根据选择性集成策略选择部分特征选择器，从已有的特征选择器中将作用不大和性能不好的特征选择器剔除，将保留的特征选择器集成（特征的并集）。第二部分，采用朴素贝叶斯算法评估<strong>序列前向搜索</strong>（先选择一个最优的特征，再选择一个与其组合起来最优的特征，一直一个个特征往最优特征子集中加，直到判据值 $J$ 降低为结束准则）产生的特征子集，以分类准确率下降为结束准则，再比较多个数据集（同一目的的数据集，只是不同类别的分布状况不一样）的最优特征子集选出全局特征子集，提高特征子集的稳定性。流程如下图：</p><p><img src="/2019/07/07/加密流量测量和分析/FSEN.png" alt=""></p><p><strong>2、基于加权集成学习的自适应分类方法</strong></p><p>针对 <code>DPI</code> 分类方法解析数据包负载内容侵犯隐私，且对加密业务无能为力，促使研究人员转向基于机器学习的流量分类方法。</p><p>如果能够准确地识别网络流的变化，就可以及时有效地更新分类器，从而避免仅根据经验设置固定的时间间隔频繁更新分类器。首先，多个集成的分类器根据他们的分类性能设置不同的权重（分类精度高的分类器权值大），然后，根据信息熵检测网络流的变化，一但网络流发生变化，再建立一个分类器，这个新的分类器是用最新的样本训练出来的，之后，用它替换掉原始多个分类器中权值最小的那个。</p><p>这样，一方面充分利用先前训练的分类器，另一方面在保留先前训练的分类器的基础上引入当前样本训练的分类器集成，并剔除性能下降的分类器，保证模型集成分类器的泛化能力。</p><p><strong><a href="https://www.cs.waikato.ac.nz/ml/weka/" target="_blank" rel="noopener">Weka 3</a>: Machine Learning Software in Java</strong></p><p><strong>3、<code>non-VPN</code> 和 <code>VPN</code> 加密流量分类方法</strong></p><p><code>TCP</code> 流通常在会话结束时（通过 <code>FIN</code> 数据包） 终止，而 <code>UDP</code> 流由流超时终止。</p><p>通过提取 <strong>流</strong> 中与时间相关的特征来识别 <code>加密和VPN</code> 流量，进行分类。用到的特征如下图：</p><p><img src="/2019/07/07/加密流量测量和分析/feature.jpg" alt=""></p><h5 id="三、TLS-加密流量分类方法"><a href="#三、TLS-加密流量分类方法" class="headerlink" title="三、TLS 加密流量分类方法"></a>三、<code>TLS</code> 加密流量分类方法</h5><p><strong>1、基于<code>Markov</code>链的分类</strong></p><p>识别<code>SSL/TLS</code> 加密应用，二阶<code>Markov</code>链和<code>HMM</code> 模型分别建立在 <code>SSL/TLS</code> 协议交互的握手过程和数据传输过程（使用握手过程中的报文类型和分组长度，数据传输过程中的数据包长度），然后建立加权集成分类器。每个每类器的权重与当前分类器的分类误差 成反比，具体的：<br>$$<br>MSE_i = \frac{1}{|S_n|} \sum_{(x,c) \in S_n }(1-f_c^i(x))^2<br>$$</p><p>$$<br>MSE_r = \sum_c p(c)(1-p(c))^2<br>$$</p><p>$$<br>第i个分类器的权重：w_i = MSE_r - MSE_i<br>$$</p><p><strong>2、<code>Tor</code> 行为分析 </strong></p><p>默认情况下，<code>Tor</code> 服务器生成的证书的<strong>颁发者</strong>和<strong>证书主体</strong>都使用随机公共名称，<strong>主题</strong> 和 <strong>发布者</strong> 字段是独立生成的，因此彼此不同。主题和发行者字段都不包含证书中常见的（并有证书颁发机构强制要求）的其他信息，例如<strong>位置</strong> 或 <strong>公司名称</strong>。这些特征允许通过解析数据集中的 <code>X.509</code> 证书，然后在其 <strong>主题</strong> 和 <strong>颁发者</strong>  字段上匹配相应的正则表达式来识别 <code>Tor</code> 连接。</p><p>但以这种方式识别 <code>Tor</code> 连接的一个潜在缺陷在于 <code>TLS</code> 会话恢复，其跳过大多数<code>TLS</code> 握手，包括证书交换，用于连接到同一<code>TLS</code> 服务器的连接。但是，<code>Tor</code> 规范声名 <code>Tor</code> 客户端和服务器不能实现会话恢复。</p><h5 id="四、HTTPS-加密流量分类方法"><a href="#四、HTTPS-加密流量分类方法" class="headerlink" title="四、HTTPS 加密流量分类方法"></a>四、<code>HTTPS</code> 加密流量分类方法</h5><p><strong>1、<code>HTTPS</code> 加密流量的识别方法</strong></p><p>会话（流）用五元组 <code>(协议、源IP、目的IP、源端口、目的端口)</code>  表示，标签是元组 <code>(OS、浏览器、应用)</code> 。提取特征，训练分类器对其进行识别。</p><p><strong>2、<code>HTTPS</code> 协议语义推断</strong></p><p>在不解密 <code>HTTPS</code> 流量的情况下，训练分类器识别 <code>HTTPS</code> 流中的某些字段，如状态码、方法、是否含有 <code>Cookie</code> 字段、<code>Content-Type</code> 字段的类型 等等。</p><p><strong>3、识别<code>TLS</code> 连接拦截</strong></p><p>如网络中间件和防病毒安全产品会对 <code>TLS</code> 连接进行拦截，其在本地客户端和远程服务器中间充当一个中间人。为了识别出是否发生了 <code>TLS</code> 连接拦截，可以通过 <code>Client Hello</code> 消息中宣称的浏览器类型和其中的<strong><code>TLS</code>扩展、密码、椭圆曲线和压缩方法</strong> 等生成的指纹是否匹配来识别，因为每个浏览器虽然有不同的客户端类型和版本，但也可以为它们生成特定的指纹库。</p><p>当发生了拦截时，可进一步识别出是谁（什么设备）拦截了此<code>TLS</code> 连接，通过为市面上的大量产品生成一个设备指纹库，然后匹配被拦截修改后的 <code>Client Hello</code> 中的<strong>版本、密码、扩展、压缩方法、椭圆曲线和签名算法</strong> 等生成的指纹和库中的那个设备的指纹相匹配。</p><p>通过对 <code>TLS</code> 连接的安全性进行量化后，发现网络中间件或拦截产品降低了原始连接的安全性。</p><h5 id="五、加密视频流量参数识别"><a href="#五、加密视频流量参数识别" class="headerlink" title="五、加密视频流量参数识别"></a>五、加密视频流量参数识别</h5><p><strong>1、对视频 <code>QoE</code> 进行量化评估</strong></p><p>1）视频是分块传输的，其中，视频源质量、初始缓冲时延和卡顿时长 是影响用户体验的最重要的外部因素。</p><p>视频源质量 <code>sQuality</code> 表示如下：<br>$$<br>sQuality = Qualitymax \times (1-\frac{1}{(1+VB \times VC \times \frac{CP}{VR})^2})<br>$$<br>其中，<code>VC</code> 代表 视频压缩算法，<code>CP</code> 代表 视频源编码等级， <code>VR</code> 代表 视频清晰度， <code>VB</code> 代表 码率， <code>Qualitymax</code> 代表当前清晰度视频源质量评分的最高值，对于清晰度为 <code>4K, 2K, 1080P, 720P 和 360P</code> 的视频，<code>Qualitymax</code> 值分别为 <code>4.9, 4.8, 4.5, 4, 3.6 和 2.8</code>。</p><p>2）初始缓冲时延<code>(IBL)</code>是从点击<code>播放</code> 到视频播放的等待时间，初始缓冲时延 <code>sLatency</code> 表示如下：</p><p><img src="/2019/07/07/加密流量测量和分析/1.png" alt=""></p><p>3）卡顿是指播放过程中缓冲的数据量被消耗完所产生的视频播放停止（与 卡顿时长、次数等相关），卡顿时长占比 <code>sStalling</code> 表示如下：</p><p><img src="/2019/07/07/加密流量测量和分析/2.png" alt=""></p><p>综合考虑视频源质量、初始缓冲时延和卡顿占比 3 个 <code>KPIs</code> 提出的 <code>vMOS</code> 模型对视频 <code>QoE</code> 进行客观评估，<code>vMoS</code> 表示如下：<br>$$<br>\begin{equation}<br>vMoS =<br>(1-0.092 \times (1+2e^{-sLatency})) \times (5-sLatency) \times sQuality - \<br>0.018 \times (1+2e^{-sStalling}) \times (5-sStalling)<br>\end{equation}<br>$$<br><strong>2、基于视频块特征的视频 <code>QoE</code> 参数识别</strong></p><p><code>SSL/TLS</code> 加密 <code>YouTube</code> 流量识别模块、传输模式识别模块、<code>QoE</code> 参数识别模块以及视频<code>QoE</code> 评估模块。首先，根据 <code>SSL/TLS</code> 协议握手过程中 <code>Client Hello</code> 数据包中的未加密内容识别加密 <code>YouTube</code> 流量；然后，根据视频流的前几个包的特征识别出不同传输模式，在根据视频块统计特征建立分类模式识别视频块的码率和清晰度；最后，根据该视频参数和传输参数计算视频 <code>QoE</code>。</p><p>1）在 <code>SSL/TLS</code> 加密 <code>YouTube</code> 流量识别模块中，根据预先建立视频服务器 <code>IP</code> 白名单，过滤出混乱流量中的加密 <code>YouTube</code> 流量。</p><p>2）在传输模式识别模块中，当前加密 <code>YouTube</code> 自适应码流传输模式主要有 <code>Apple HLS</code>、<code>MPEG DASH</code> 和 <code>HPD</code>。在同一时间，<code>HPD</code>采用单流传输（视频和音频没有分离），而<code>DASH</code> 和 <code>HLS</code> 采用多条流传输，采用相邻两条流之间的 <code>SYN-ACK</code> 包的到达时间间隔来区分出 <code>HPD</code> 传输模式。</p><p><code>DASH</code> 和 <code>HLS</code> 视频传输都是将视频进行分段后使用基于 <code>TCP</code> 的 <code>HTTPS</code> 流传输的，由于 <code>TCP</code> 的 <code>MSS</code> 所限制，视频片段被分割成大量 <code>1.4KB</code> 左右的数据包传输，而这些数据包响应的都是同一个请求，所以他们的 <code>ACK Number</code> 相同。但是在 <code>DASH</code> 传输模式下，服务器需要先向客户端发送 <code>Initial Segment</code>，<code>Initial Segment</code> 包含了视频解码器所需的初始化信息，然后再开始传输视频数据，在加密数据包中的表现就是经过 <code>SSL/TLS</code> 握手阶段后开始传输的前 <code>P</code> 个 <code>Application data</code> 数据包出现 <code>S</code> 种 <code>ACK Number</code>。可以利用此特征来区分 <code>DASH</code> 和 <code>HLS</code> 视频传输模式，统计发现 <code>DASH</code> 前 <strong>三</strong> 个数据包的 <code>ACK Number</code> 种类数为 <code>2</code> 或 <code>3</code> ，而 <code>HLS</code> 和 <code>HPD</code> 的种类数都为 <code>1</code>。</p><p><strong>3、加密视频 <code>QoE</code> 评估</strong></p><p>影响自适应和经典视频流 <code>QoE</code> 的 3 个关键因素：卡顿、清晰度质量和质量切换。</p><p>研究发现，视频片段的大小和到达间隔时间的变化是影响质量的两个重要指标。</p><h5 id="六、加密恶意流量识别"><a href="#六、加密恶意流量识别" class="headerlink" title="六、加密恶意流量识别"></a>六、加密恶意流量识别</h5><p><strong>1、处理数据类别不平衡问题</strong></p><p>存在两种方法，一种是<strong>过采样</strong>：不断将少数类重新采样到训练数据集中的方法；另一种是<strong>欠采样</strong>：随机消除多数类数据的方法。</p><p><strong>2、梯度稀释问题</strong><br>$$<br>\frac{\partial Loss}{\partial \theta} = \sum_{M_i \in M}\sum_{A_{ik} \in M_i}\frac{\partial Loss_{A_{ik}}}{\partial \theta}<br>$$<br><code>M</code> 代表训练数据集，$M_i$ 代表 <code>M</code> 的第 <code>i</code> 类，$A_{ik}$ 是 $M_i$ 的第 <code>k</code> 个数据， $Loss_{A_{ik}}$ 是数据 $A_{ik}$ 贡献的损失。可以看到参数 $\theta$ 相对于每个类的更新次数取决于每个类的大小。一旦数据的数量严重不同，模型将倾向于偏向多数类，因为总梯度将由多数类在频率方面贡献的梯度所支配。这种现象将导致模型对少数类的不敏感，因为模型很少更新关于少数类的参数。由少数群体贡献的梯度逐渐消失，好像被多数群体所贡献的那样稀释了，这种现象称为 <strong>梯度稀释</strong>。</p><p><strong>3、零样本学习</strong></p><p>网络社会中存在各种恶意软件，每天都有许多新的变种，所以不可能手机每个家族的数据样本。为了评估所提出模型的泛化性能，检查<code>***</code>模型识别从未训练过的一些恶意软件的能力，这种场景被创造为机器学习术语中的“零样本学习”。</p><p><strong>4、字节分布特征</strong></p><p>字节分布是长度为 <code>256</code> 的数组，它保持流中每个数据包的有效负载中遇到的每个字节值的计数。通过将字节分布计数除以在分组的有效载荷中的总字节数，可以容易地计算字节值概率。</p><p>完整的字节分布提供了大量有关数据编码的信息。</p><p><strong>5、正常企业流量和恶意软件流量中的<code>TLS</code>连接的区别</strong></p><ul><li>密码套件。 一般企业流量中提供的密码套件安全性比较高，而恶意软件流量中提供的密码套件安全性低，两者存在比较大的区别。</li><li><code>TLS</code> 扩展。 几乎一半的企业客户端会支持多达 9 个扩展，但恶意客户端只会一致地支持一个。</li><li>客户端的公钥长度。 大多数企业流量使用 <code>512</code> 位<code>(ECDHE_RSA)</code> 公钥，恶意软件几乎只使用 <code>2048</code> 位 <code>(DHE_RSA)</code> 公钥。</li></ul><p><strong>6、分类恶意 <code>TLS</code> 流量</strong></p><p><code>DNS</code> + <code>HTTP</code> + <code>TLS</code> 三者相关联，提取特征进行分类识别。</p><p>用到的特征:</p><ul><li>可观察元特征。 包长及时间间隔转移矩阵，字节分布等。</li><li><code>TLS</code> 数据。 密码套件、支持的扩展及公钥长度； 服务器选定的密码套件、支持的扩展、证书数量、有效天数及是否有自签名等。 统计出现的所有种类，然后<code>onehot</code>编码生成一个特征向量。</li><li><code>DNS</code> 数据。 <code>TTL</code> 值、<code>DNS</code>响应中域名的数字字符数、非字母数字字符数、返回的 <code>IP</code>地址的个数、域名是否出现在 <code>Alexa</code> 列表前 100、 前1000、 前10000、 前 100000里等。</li><li><code>HTTP</code> 数据。 <code>Content-Type</code> 、 <code>User-Agent</code> 、<code>Accept-Language</code> 、 <code>Server</code> 和 <code>Code</code> 等。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h5 id=&quot;一、加密与非加密流量识别&quot;&gt;&lt;a href=&quot;#一、加密与非加密流量识别&quot; class=&quot;headerlink&quot; title=&quot;一、加密与非加密流量识别&quot;&gt;&lt;/a&gt;一、加密与非加密流量识别&lt;/h5&gt;&lt;p&gt;1、利用 &lt;strong&gt;信息熵&lt;/strong&gt; 的方法对加密流量进行识别。&lt;/p&gt;
&lt;p&gt;对不同类型的文件，如文本、图片、压缩文件、加密文件等的前 &lt;strong&gt;&lt;code&gt;1KB&lt;/code&gt;&lt;/strong&gt;  数据的熵进行计算分析，可以发现文本文件的熵处于较低水平，压缩文件和加密文件的熵处于较高的水平，且两者较难区分。&lt;/p&gt;
&lt;p&gt;多元组熵的定义：&lt;/p&gt;
&lt;p&gt;（1）n元字符组集合指以大小为 n 的滑动窗口对报文序列 P 进行切割后得到的字符串 $s_i (1 \le i \le L-n+1)$ 的集合，L 表示分析报文序列以 &lt;strong&gt;字节&lt;/strong&gt; 为单位的长度：&lt;br&gt;$$&lt;br&gt;S_n = \lbrace s_1, s_2, …, s_{L-n+1} \rbrace&lt;br&gt;$$&lt;br&gt; 如 &lt;code&gt;“data.dat”&lt;/code&gt; 对应的二元字符组集合为 $S_2 = \lbrace da, at, ta, a., .d, da, at \rbrace​$。&lt;/p&gt;
    
    </summary>
    
      <category term="笔记" scheme="https://wangjibao.com.cn/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="笔记" scheme="https://wangjibao.com.cn/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>HTTP2协议解析及抓包分析</title>
    <link href="https://wangjibao.com.cn/2019/07/05/HTTP2%E5%8D%8F%E8%AE%AE%E8%A7%A3%E6%9E%90%E5%8F%8A%E6%8A%93%E5%8C%85%E5%88%86%E6%9E%90/"/>
    <id>https://wangjibao.com.cn/2019/07/05/HTTP2协议解析及抓包分析/</id>
    <published>2019-07-05T12:17:27.000Z</published>
    <updated>2019-07-05T12:34:48.856Z</updated>
    
    <content type="html"><![CDATA[<h4 id="一、HTTP2协议简介"><a href="#一、HTTP2协议简介" class="headerlink" title="一、HTTP2协议简介"></a>一、HTTP2协议简介</h4><h5 id="1、HTTP2的帧格式"><a href="#1、HTTP2的帧格式" class="headerlink" title="1、HTTP2的帧格式"></a>1、HTTP2的帧格式</h5><p>HTTP2的所有帧都是由一个固定的<strong>9</strong>字节头部（payload之前）和一个指定长度的负载（payload）组成，如下图所示：</p><p><img src="/2019/07/05/HTTP2协议解析及抓包分析/h2帧格式.jpg" alt=""></p><p>其中，<code>Stream Identifier</code>用作流控制，用31位无符号整数表示。客户端建立的<code>sid</code>必须为奇数，服务端建立的<code>sid</code>必须为偶数，<strong>值（0x0）保留给与整个连接相关联的帧（连接控制消息），而不是单个流。</strong></p><p><code>Frame Payload</code>是主体内容，有帧类型决定，HTTP2一共有<strong>10</strong>种类型的帧：</p><a id="more"></a><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">   名称           描述         type值</span><br><span class="line"> HEADERS        报头帧          0x1</span><br><span class="line">   DATA         数据帧          0x0</span><br><span class="line"> PRIORITY       优先级帧        0x2</span><br><span class="line">RST_STREAM      流终止帧        0x3</span><br><span class="line"> SETTINGS       设置帧          0x4</span><br><span class="line">PUSH_PROMISE    推送帧          0x5</span><br><span class="line">   PING         PING帧         0x6</span><br><span class="line">  GOAWAY        GOAWAY帧       0x7</span><br><span class="line">WINDOW_UPDATE   窗口更新帧       0x8</span><br><span class="line">CONTINUATION    延续帧          0x9</span><br></pre></td></tr></table></figure><p>实际上，HTTP2并没有改变HTTP1.x的语义，只是把原来HTTP1.x的<code>Header</code>和<code>Body</code>部分用<code>Frame</code>重新封装了一层而已。调试的时候浏览器设置会把<code>HTTP2</code>的<code>Frame</code>自动还原成<code>HTTP1.x</code>的格式。两者的帧格式对比如下图：</p><p><img src="/2019/07/05/HTTP2协议解析及抓包分析/h1_vs_h2.png" alt=""></p><h5 id="2、HTTP2的改进及优点"><a href="#2、HTTP2的改进及优点" class="headerlink" title="2、HTTP2的改进及优点"></a>2、HTTP2的改进及优点</h5><ul><li><p>二进制分帧</p><p>帧是客户端和服务端之间通信的最小单位，比起<code>HTTP1.x</code>这样的文本协议，二进制协议解析起来更高效，且没有冗余字段（HTTP1.x 协议每个包都会有重复传输的头部字段），占用带宽少。</p></li><li><p>多路复用</p><blockquote><p>可以并行交错地发送请求，请求之间互不影响；</p><p>可以并行交错地发送响应，响应之间互不干扰；</p><p>只使用一个连接即可并行发送多个请求和响应；</p><p>消除不必要的延迟，从而减少页面加载的时间；</p></blockquote></li></ul><p>增加了<strong>请求优先级</strong>字段，服务器可以根据流的优先级，控制资源分配，而在响应数据准备好之后，将优先级最高的帧发送给客户端。</p><p>增加了<strong>Header压缩</strong>，通信双方各自 <code>cache</code> 一份 <code>header fields</code>表。</p><p>增加了<strong>服务器推送</strong>，服务器可以对一个客户端请求发送多个响应，服务器向客户端推送资源无需客户端明确地请求。服务器推送通过<code>PUSH</code>那些它认为客户端将会需要的内容到客户端的缓存中，避免往返的延迟。比如，请求<code>index.html</code>，但服务器会把<code>style.css, example.png</code>等资源也发送给浏览器。</p><p><strong>流量控制</strong>，每个<code>HTTP2</code>的流都拥有自己公示的流量窗口，它可以限制另一端发送数据。</p><p><img src="/2019/07/05/HTTP2协议解析及抓包分析/h2.png" alt=""></p><h4 id="二、配置Wireshark抓取HTTP2数据包"><a href="#二、配置Wireshark抓取HTTP2数据包" class="headerlink" title="二、配置Wireshark抓取HTTP2数据包"></a>二、配置Wireshark抓取HTTP2数据包</h4><p>1、在电脑里创建一个后缀名为 <code>.log</code> 的文件，记住其路径。</p><p>2、在电脑的系统变量里创建一个新的变量，名为<code>SSLKEYLOGFILE</code>。配置了此变量后，浏览器会到这里来记录通信过程中密钥。</p><p><img src="/2019/07/05/HTTP2协议解析及抓包分析/h2_4.png" alt=""></p><p>3、在<code>wireshark</code>中，<code>分析 &gt;&gt; 已解析的协议...</code>中，启用<code>HTTP2</code>的解析。并在 <code>编辑 &gt;&gt; 首选项 &gt;&gt; Protocols &gt;&gt; TLS</code> 中，配置 <code>(Pre)-Master-Secret</code> 为之前创建的<code>log</code>文件，之后，<code>wireshark</code>就可以凭借此文件中的秘钥解密<code>HTTP2</code>中的各个加密字段，便于我们进行协议分析。</p><p><img src="/2019/07/05/HTTP2协议解析及抓包分析/h2_2.png" alt=""></p><h4 id="三、HTTP2协议数据包解析"><a href="#三、HTTP2协议数据包解析" class="headerlink" title="三、HTTP2协议数据包解析"></a>三、HTTP2协议数据包解析</h4><p>数据包<a href="/download/h2.rar">点击下载</a></p><p><img src="/2019/07/05/HTTP2协议解析及抓包分析/h2_3.png" alt=""></p><p>1、从上图可以看到，<code>HTTP2</code>协议的工作流程为：建立<code>TCP</code>连接、建立<code>TLS</code>连接、<code>HTTP2</code>通信，断开<code>TCP</code>连接 四个过程。在<code>Client Hello</code>中，客户端再扩展字段中会说明其所支持的协议，指定<code>ALPN Next Protocol</code> 为 <code>h2</code> 或 <code>HTTP/1.1</code>。之后，服务端在<code>Server Hello</code>中，回复所协商的接下来使用的应用层协议。如下图：</p><p><img src="/2019/07/05/HTTP2协议解析及抓包分析/h2_5.png" alt=""></p><p>2、在<code>TLS</code>连接过程中，如果服务器支持<code>session ticket</code>，则发送<code>New Session Ticket</code>类型的握手报文，其中包含了能够恢复包括主密钥在内的会话信息。为了不让中间人可见，这个<code>session ticket</code>部分会进行编码、加密等操作，同时，还会指定此<code>ticket</code>的过期时间等。</p><p><img src="/2019/07/05/HTTP2协议解析及抓包分析/h2_6.png" alt=""></p><p>3、从第一幅图中可以看出，在客户端发送<code>Finished</code>消息（#11）之后，就开始将<code>HTTP</code>封装到<code>Application Data</code>协议中发送给服务器（#12，#13，#14，#15，#16）了，此时，<code>TLS</code>握手还没有完全完成。</p><p><code>HTTP2</code>中基本的协议单位是帧，每个帧都有不同的类型和用途。例如，报头<code>(HEADERS)</code>和数据<code>(DATA)</code>帧组成了基本的<code>HTTP</code>请求和响应；其他帧如设置<code>(SETTINGS)</code>，窗口更新<code>(WINDOW_UPDATE)</code>和推送承诺<code>(PUSH_PROMISE)</code>是用来实现<code>HTTP2</code>的其他功能。</p><p>4、<strong>（#12）</strong>帧分析：在<code>HTTP2</code>请求创建连接发送<code>SETTINGS</code>帧初始化之前有一个<code>Magic</code>帧，为建立<code>HTTP2</code>请求的前言<code>(connection preface)</code>，此前言作为对所使用协议的最终确认，并确定<code>HTTP2</code>连接的初始设置。在发送完前言后，双方都得向对方发送带有<code>ACK</code>标识的<code>SETTINGS</code>帧标识确认，对应图中的<strong>#21</strong> 和 <strong>#22</strong> 号帧：</p><p><img src="/2019/07/05/HTTP2协议解析及抓包分析/h2_7.png" alt=""></p><p>12号帧，组合了<code>Magic</code>、<code>SETTINGS</code>和<code>WINDOW_UPDATE</code>三种帧为一个数据包，其中包含的参数如下图：</p><p><img src="/2019/07/05/HTTP2协议解析及抓包分析/h2_8.png" alt=""></p><p><code>WINDOW_UPDATE</code>中的<code>stream identifier</code>为<code>0</code>表示此窗口更新帧作用于整个连接，指定其他具体值可使其作用于某个特定的单独连接。</p><p>5、<strong>（#13）</strong>号帧分析，客户端在发送完连接前言后，可立即跟上一个请求<code>(request)</code>。这里客户端向服务器发送<code>GET /HEADERS</code>，<code>HEADERS</code>帧用来打开一个流或携带一个首部块片段，此<code>HEADERS</code>帧包括了请求行和请求头的内容，属于<code>1</code> 号流：</p><p><img src="/2019/07/05/HTTP2协议解析及抓包分析/h2_9.png" alt=""></p><p>其中，<code>Exclusive</code>：一个比特位声明流的依赖性是否是排它的，这里为 <code>1</code>，代表此流不依赖其他的流。<code>Weight</code>：代表当前流的优先级权重。<code>End Headers</code>：这里为 <code>1</code> 代表<code>header</code>块结束。<code>Priority</code>设置为 <code>1</code>，代表存在<code>Exclusive</code>、<code>Stream Dependency</code> 和 <code>Weight</code>。</p><p>6、<strong>(#19)</strong> 号包分析，服务器向客户端发送<code>SETTINGS</code> 和 <code>WINDOW_UPDATE</code> 帧，<code>SETTINGS</code>帧为连接前言 <code>(connection preface)</code>，帧中设置了最大并行流数量、初始窗口大小、最大帧长度，<code>WINDOW_UPDATE</code> 给出扩大窗口的大小。这两个帧属于 <code>0</code> 号流。</p><p><img src="/2019/07/05/HTTP2协议解析及抓包分析/h2_10.png" alt=""></p><p>7、<code>DATA</code> 帧，服务器向客户端发送<code>DATA</code>帧，即响应主体。<code>DATA</code> 帧用来装填主体信息，可以用一个或多个<code>DATA</code> 帧来返回一个请求的响应主体。</p><p><img src="/2019/07/05/HTTP2协议解析及抓包分析/h2_11.png" alt=""></p><p>上图左边为<code>HEADERS</code>帧，服务器向客户端返回响应<code>(response)</code>，此报头帧包含了状态行和响应头的内容，此帧属于 <code>3</code> 号流。 <code>Status: 200 OK</code> 表示状态码为 200，客户端请求成功。此外，响应头还给出了服务器所使用的的服务器型号、内容类型等。注意观察图中的标志位 <code>End Stream</code> 和 <code>End Headers</code> 的变化。</p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;一、HTTP2协议简介&quot;&gt;&lt;a href=&quot;#一、HTTP2协议简介&quot; class=&quot;headerlink&quot; title=&quot;一、HTTP2协议简介&quot;&gt;&lt;/a&gt;一、HTTP2协议简介&lt;/h4&gt;&lt;h5 id=&quot;1、HTTP2的帧格式&quot;&gt;&lt;a href=&quot;#1、HTTP2的帧格式&quot; class=&quot;headerlink&quot; title=&quot;1、HTTP2的帧格式&quot;&gt;&lt;/a&gt;1、HTTP2的帧格式&lt;/h5&gt;&lt;p&gt;HTTP2的所有帧都是由一个固定的&lt;strong&gt;9&lt;/strong&gt;字节头部（payload之前）和一个指定长度的负载（payload）组成，如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/2019/07/05/HTTP2协议解析及抓包分析/h2帧格式.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;其中，&lt;code&gt;Stream Identifier&lt;/code&gt;用作流控制，用31位无符号整数表示。客户端建立的&lt;code&gt;sid&lt;/code&gt;必须为奇数，服务端建立的&lt;code&gt;sid&lt;/code&gt;必须为偶数，&lt;strong&gt;值（0x0）保留给与整个连接相关联的帧（连接控制消息），而不是单个流。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Frame Payload&lt;/code&gt;是主体内容，有帧类型决定，HTTP2一共有&lt;strong&gt;10&lt;/strong&gt;种类型的帧：&lt;/p&gt;
    
    </summary>
    
      <category term="笔记" scheme="https://wangjibao.com.cn/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="笔记" scheme="https://wangjibao.com.cn/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>IPSec VPN搭建及协议解析</title>
    <link href="https://wangjibao.com.cn/2019/07/02/IPSec-VPN%E6%90%AD%E5%BB%BA%E5%8F%8A%E5%8D%8F%E8%AE%AE%E8%A7%A3%E6%9E%90/"/>
    <id>https://wangjibao.com.cn/2019/07/02/IPSec-VPN搭建及协议解析/</id>
    <published>2019-07-02T14:08:50.000Z</published>
    <updated>2019-07-03T01:42:36.710Z</updated>
    
    <content type="html"><![CDATA[<h4 id="一、IPSec协议简介"><a href="#一、IPSec协议简介" class="headerlink" title="一、IPSec协议简介"></a>一、IPSec协议简介</h4><p><code>IPSec</code>是<code>IETF</code>制定的为保证在<code>Internet</code>上传送数据的安全保密性能的三层隧道加密协议。<code>IPSec</code>是应用于<code>IP</code>层上网络数据安全的一整套体系结构，他包括<strong>报文首部认证协议</strong><code>（ Authentication Header, AH）</code>、<strong>封装安全载荷协议</strong><code>(Encapsulating Security Payload, ESP)</code>、<strong>互联网间密钥交换协议</strong><code>(Internet Key Exchange, IKE)</code> 和一些用于网络认证及加密的算法等。<code>IPSec</code>协议本身定义了如何在<code>IP</code>数据包中增加字段来保证<code>IP</code>包的完整性、私有性和真实性，以及如何加密数据包。</p><p><code>IPSec</code>有传输<code>(transport)</code>和隧道<code>(tunnel)</code>两种工作方式，其中，传输模式适用于主机之间建立<code>IPSec</code>安全传输，隧道模式更适合网关之间的通信，常用来实现虚拟专用网<code>VPN</code>。</p><h4 id="二、IPSec-VPN搭建"><a href="#二、IPSec-VPN搭建" class="headerlink" title="二、IPSec-VPN搭建"></a>二、IPSec-VPN搭建</h4><p>详细教程请参考：<a href="https://github.com/hwdsl2/setup-ipsec-vpn/blob/master/README-zh.md" target="_blank" rel="noopener">https://github.com/hwdsl2/setup-ipsec-vpn/blob/master/README-zh.md</a></p><p>以 <code>Ubuntu 16.04</code>为例，首先执行：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget https://git.io/vpnsetup -O vpnsetup.sh</span><br></pre></td></tr></table></figure><p>之后，在<code>vpnsetup.sh</code>文件中，设置<code>YOUR_IPSEC_PSK, YOUR_USERNAME 和 YOUR_PASSWORD</code>三个字段，如下图：</p><p><img src="/2019/07/02/IPSec-VPN搭建及协议解析/vpnsetup.png" alt=""></p><a id="more"></a><p>最后，通过命令 <code>sudo sh vpnsetup.sh</code> 启动服务器的 <code>ipsec vpn</code>服务。接下来，就是客户端的配置，以安卓手机为例：</p><p><img src="/2019/07/02/IPSec-VPN搭建及协议解析/ipsec1.png" alt=""></p><p>选择对应的 <code>VPN</code> 添加类型，其中<code>IPSec Xauth</code> 类型也称 <code>Cisco IPsec</code> 模式，更加高效一些。填写好服务器地址、预共享密钥<code>(PSK)</code> 、用户名和密码后，即可使用该 <code>VPN</code>，如果服务器在香港或国外的话，即可实现<code>翻墙</code>的功能。</p><h4 id="三、IPSec协议解析"><a href="#三、IPSec协议解析" class="headerlink" title="三、IPSec协议解析"></a>三、<code>IPSec</code>协议解析</h4><p><code>IPSec</code>主要包括两部分协议，分别是 <code>ISAKMP</code> 协议和 <code>ESP</code>协议，可使用<code>wireshark</code>采集以上两种协议的报文。</p><p><strong>(1) <code>ISAKMP</code>协议</strong></p><blockquote><p>第一阶段，通信双方彼此间建立一个已通过身份认证和安全保护的通道，即建立一个<code>ISAKMP SA</code>。第一阶段有主模式<code>（Main Mode）</code>和野蛮模式<code>（Aggressive Mode）</code>两种<code>IKE</code>交换方法。        </p><p> 第二阶段，使用在第一阶段建立的安全隧道为<code>IPsec</code>协商安全服务，即为<code>IPsec</code>协商具体的<code>SA</code>，建立用于最终的<code>IP</code>数据安全传输的<code>IPsec SA</code>。</p></blockquote><p><strong>第一阶段</strong>的<strong>主模式</strong>交换过程：</p><p><img src="/2019/07/02/IPSec-VPN搭建及协议解析/isakmp.png" alt=""></p><p>对应的数据包为<a href="/download/isakmp.pcap">点我下载</a>：</p><p><img src="/2019/07/02/IPSec-VPN搭建及协议解析/isakmp_1.png" alt=""></p><ul><li>消息①和②用于策略交换（包为明文）</li></ul><blockquote><p>发起方发送一个或多个<code>IKE</code>安全提议，响应方查找最先匹配的<code>IKE</code>安全提议，并将这个<code>IKE</code>安全提议回应给发起方。匹配的原则为协商双方具有相同的加密算法、认证算法、认证方法和<code>Diffie-Hellman</code>组标识。</p></blockquote><ul><li>消息③和④用于密钥信息交换（包为明文）</li></ul><blockquote><p>双方交换<code>Diffie-Hellman</code>公共值和<code>nonce</code>值，用于<code>IKE SA</code>的认证和加密密钥在这个阶段产生。</p></blockquote><ul><li>消息⑤和⑥用于身份和认证信息交换（包为密文）</li></ul><blockquote><p>双方使用生成的密钥发送信息，双方进行身份认证和对整个主模式交换内容的认证。</p></blockquote><p><strong>第二阶段</strong>的<code>IPSEC SA</code>协商:</p><p>上图中的 8、9、10 号包使用快速模式，进行<code>IPSec SA</code>的协商。</p><p>最后的 <code>11、12、13、14</code>号数据包为断开连接。</p><p><strong>(2) <code>ESP</code>协议</strong></p><p><img src="/2019/07/02/IPSec-VPN搭建及协议解析/esp.png" alt=""></p><p>因为 <code>IPSec</code>协议要求通信双方建立单工的安全联盟，所以两个<code>SPI</code> 分别标识了两个方向的通信报文。</p><h4 id="四、IPSec穿越NAT"><a href="#四、IPSec穿越NAT" class="headerlink" title="四、IPSec穿越NAT"></a>四、IPSec穿越NAT</h4><p><strong><code>IPSec VPN</code>中标准身份标识是<code>IP</code>地址，<code>NAT</code>处理过程中会改变<code>IP</code>地址，因此<code>IPSec</code>的身份确认机制必须能够适应<code>IP</code>地址变化。</strong><code>IPSec</code>的身份确认最常见是通过<code>IKE</code>协议代劳，<code>IKE</code>支持的身份认证机制有两种:</p><ul><li><p>数字证书方式，通过CA数字证书体系确认身份，是最为安全、可靠的方式。</p></li><li><p>身份标识+预共享密钥方式，通过发起方和响应方预先配置相同的密钥，完成双方对彼此身份的认证，这是最为常见的方式。在预共享秘密钥认证机制中，身份标识则可以分为几类：</p><ul><li><p>指定<code>IP</code>地址，使用<code>IP</code>地址作为身份标识，是<code>IKE</code>的默认方式，响应方只允许指定<code>IP</code>地址发起协商，安全性比较高。</p></li><li><p>指定<code>IP</code>地址范围，这种方式依然使用<code>IP</code>地址作为身份标识，由于发起方必须要指定<code>IP</code>地址，否则无法发起协商，指定<code>IP</code>地址范围是响应方特性，如响应方可以指定<code>2.0.0.0/8</code>范围内的地址都可以发起协商，而不是只允许<code>2.1.1.2</code>发起协商，能够减少配置，但安全性略有下降。</p></li><li><p>什么都不指定，也是使用IP地址作为身份标识，但允许任意IP地址发起协商，只要预共享密钥一致，双方就能够通过身份确认，这种方式虽然不是非常安全，但是可以简化配置，安全性再次下降；</p></li><li><p>指定对端名字，发起方和响应方都预先配置好本端名字，使用该名字作为身份标识，与指定<code>IP</code>地址类似，通过指定对端名字方式，即使双方预共享密钥一致，只要对端名字不合法，立即中断协商，由于名字未与<code>IP</code>地址进行绑定，而且名字在网络中明文传递，故安全性不如指定<code>IP</code>地址方式高，但这种身份标识方式可以穿<code>NAT</code>。</p></li></ul></li></ul><p>具体过程如下：</p><p> 1、开启<code>NAT</code>穿越时，协商第一阶段的前两个消息会发送标识<code>NAT</code>穿越（<code>NAT Traversal</code>，简称<code>NAT-T</code>）能力的<code>Vendor ID</code>载荷。用于检查通信双方是否支持<code>NAT-T</code>。</p><p><img src="/2019/07/02/IPSec-VPN搭建及协议解析/nat1.png" alt=""></p><p>当双方都在各自的消息中包含了该载荷时，才会进行相关的<code>NAT-T</code>协商。</p><p>2、主模式消息3和消息4中发送<code>NAT-D（NAT Discovery）</code>载荷。<code>NAT-D</code>载荷用于探测两个要建立<code>IPSec</code>隧道的网关之间是否存在<code>NAT</code>网关以及<code>NAT</code>网关的位置。</p><p><img src="/2019/07/02/IPSec-VPN搭建及协议解析/nat2.png" alt=""></p><p>通过协商双方向对端发送源和目的的<code>IP</code>地址与端口的<code>Hash</code>值，就可以检测到地址和端口在传输过程中是否发生变化。若果协商双方计算出来的<code>Hash</code>值与它收到的<code>Hash</code>值一样，则表示它们之间没有<code>NAT</code>。否则，则说明传输过程中对<code>IP</code>或端口进行了<code>NAT</code>转换。</p><p>第一个<code>NAT-D</code>载荷为对端<code>IP</code>和端口的<code>Hash</code>值，第二个<code>NAT-D载</code>荷为本端<code>IP</code>和端口的<code>Hash</code>值。</p><p>3、发现<code>NAT</code>网关后，后续<code>ISAKMP</code>消息的端口号转换为<strong>4500</strong>。<code>ISAKMP</code>报文标识了<code>“Non-ESP Marker”</code>。</p><p><img src="/2019/07/02/IPSec-VPN搭建及协议解析/nat3.png" alt=""></p><p>4、在第二阶段会启用<code>NAT</code>穿越协商。在<code>IKE</code>中增加了两种<code>IPSec</code>报文封装模式：<code>UDP</code>封装隧道模式报文（<code>UDP-Encapsulated-Tunnel</code>）和<code>UDP</code>封装传输模式报文（<code>UDP-Encapsulated-Transport</code>）。<strong>通过为<code>ESP</code>报文封装<code>UDP</code>头</strong>，当封装后的报文通过<code>NAT</code>设备时，<code>NAT</code>设备对该报文的外层<code>IP</code>头和增加的<code>UDP</code>头进行地址和端口号转换。<code>UDP</code>报文端口号修改为<code>4500</code>。</p><p><img src="/2019/07/02/IPSec-VPN搭建及协议解析/nat4.png" alt=""></p><h4 id="五、IPSec协议流量特征分析"><a href="#五、IPSec协议流量特征分析" class="headerlink" title="五、IPSec协议流量特征分析"></a>五、<code>IPSec</code>协议流量特征分析</h4><p><img src="/2019/07/02/IPSec-VPN搭建及协议解析/feature.jpg" alt=""></p><p>在上图 4.14 (a) 中，<code>IPSec</code>流量与原始流量几乎完全重合，这符合<code>ESP</code>协议的特性，即一一对应，一条<code>ESP</code>报文封装一条原始报文，然后进行转发。折线的重合说明<code>IPSec</code>不会对原始流量进行分片等操作，且自身不会产生大量与传输内容无关的流量，它在得到一条原始报文后，仅对其进行加密并加上<code>IPSec</code>头部，然后忠实地发送到目的地。</p><p>在上图 4.14 (b) 中，<code>IPSec</code>流量与原始流量基本重合，但是<code>IPSec</code>流量的字节数到达速率在每个峰值处均比原始流量高。这说明<code>IPSec</code>每条报文的大小都要大于原始报文，这符合<code>IPSec</code>协议的封装特征。加密与完整性保护会产生额外的数据开销，同时无论在隧道模式还是传输模式下，<code>IPSec</code>协议都会对报文进行重新封装，再加上额外的头部，使得讲<code>IPSec</code>处理后的报文数据量大于原始报文。</p><p>在上图 4.15 (a) 中，不论是<code>IPSec</code>流量还是原始流量，其报文大小分布都是<code>U</code>形，即报文大小多集中在<code>0--200</code>字节与<code>1400--1500</code>字节之间，尤其是<code>1400--1500</code>的部分，而<code>200--1400</code>字节的报文数量明显较少。<code>U</code>形分布原因有以下几点：1、有大量数据正在传输；2、网络状况理想，<code>TCP</code>链路极少堵塞，可以持续以较大的发送窗口传输数据；3、左边部分为大量的<code>ACK</code>报文与相关协议的控制报文，以及数据量较小的报文。然后再对比<code>IPSec</code>流量与原始流量，可以观察到其报文大小分布模式及其相似，原始流量相较<code>IPSec</code>流量整体左偏，说明原始流量的报文教<code>IPSec</code>流量较小，这和折线图的结论一致。</p><p>在上图 4.15 (b) 中，可以看到横坐标的报文到达时间间隔范围较大。这与流量采集的方法与环境相关，偶发性的网络阻塞，可能瞬间将报文到达时间间隔提升到千毫秒级。当然，还有很多原因会导致报文到达时间间隔发生异常，因此，报文到达时间间隔时间是一种很不稳定的特征。从图中还可以看到，大部分的到达间隔时间极小，且<code>IPSec</code>流量和原始流量的到达间隔时间分布及其相似。</p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;一、IPSec协议简介&quot;&gt;&lt;a href=&quot;#一、IPSec协议简介&quot; class=&quot;headerlink&quot; title=&quot;一、IPSec协议简介&quot;&gt;&lt;/a&gt;一、IPSec协议简介&lt;/h4&gt;&lt;p&gt;&lt;code&gt;IPSec&lt;/code&gt;是&lt;code&gt;IETF&lt;/code&gt;制定的为保证在&lt;code&gt;Internet&lt;/code&gt;上传送数据的安全保密性能的三层隧道加密协议。&lt;code&gt;IPSec&lt;/code&gt;是应用于&lt;code&gt;IP&lt;/code&gt;层上网络数据安全的一整套体系结构，他包括&lt;strong&gt;报文首部认证协议&lt;/strong&gt;&lt;code&gt;（ Authentication Header, AH）&lt;/code&gt;、&lt;strong&gt;封装安全载荷协议&lt;/strong&gt;&lt;code&gt;(Encapsulating Security Payload, ESP)&lt;/code&gt;、&lt;strong&gt;互联网间密钥交换协议&lt;/strong&gt;&lt;code&gt;(Internet Key Exchange, IKE)&lt;/code&gt; 和一些用于网络认证及加密的算法等。&lt;code&gt;IPSec&lt;/code&gt;协议本身定义了如何在&lt;code&gt;IP&lt;/code&gt;数据包中增加字段来保证&lt;code&gt;IP&lt;/code&gt;包的完整性、私有性和真实性，以及如何加密数据包。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;IPSec&lt;/code&gt;有传输&lt;code&gt;(transport)&lt;/code&gt;和隧道&lt;code&gt;(tunnel)&lt;/code&gt;两种工作方式，其中，传输模式适用于主机之间建立&lt;code&gt;IPSec&lt;/code&gt;安全传输，隧道模式更适合网关之间的通信，常用来实现虚拟专用网&lt;code&gt;VPN&lt;/code&gt;。&lt;/p&gt;
&lt;h4 id=&quot;二、IPSec-VPN搭建&quot;&gt;&lt;a href=&quot;#二、IPSec-VPN搭建&quot; class=&quot;headerlink&quot; title=&quot;二、IPSec-VPN搭建&quot;&gt;&lt;/a&gt;二、IPSec-VPN搭建&lt;/h4&gt;&lt;p&gt;详细教程请参考：&lt;a href=&quot;https://github.com/hwdsl2/setup-ipsec-vpn/blob/master/README-zh.md&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/hwdsl2/setup-ipsec-vpn/blob/master/README-zh.md&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;以 &lt;code&gt;Ubuntu 16.04&lt;/code&gt;为例，首先执行：&lt;/p&gt;
&lt;figure class=&quot;highlight shell&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;wget https://git.io/vpnsetup -O vpnsetup.sh&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;之后，在&lt;code&gt;vpnsetup.sh&lt;/code&gt;文件中，设置&lt;code&gt;YOUR_IPSEC_PSK, YOUR_USERNAME 和 YOUR_PASSWORD&lt;/code&gt;三个字段，如下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/2019/07/02/IPSec-VPN搭建及协议解析/vpnsetup.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="笔记" scheme="https://wangjibao.com.cn/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="笔记" scheme="https://wangjibao.com.cn/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode41-50</title>
    <link href="https://wangjibao.com.cn/2019/05/09/LeetCode41-50/"/>
    <id>https://wangjibao.com.cn/2019/05/09/LeetCode41-50/</id>
    <published>2019-05-09T06:50:40.000Z</published>
    <updated>2019-08-28T03:39:02.973Z</updated>
    
    <content type="html"><![CDATA[<h2 id="41、缺失的第一个正数"><a href="#41、缺失的第一个正数" class="headerlink" title="41、缺失的第一个正数"></a>41、<a href="https://leetcode-cn.com/problems/first-missing-positive" target="_blank" rel="noopener">缺失的第一个正数</a></h2><p>数组中元素互换，让元素大小与下标相对应。数值小于0或者大于数组长度的元素值，直接略过，之后遍历整个数组，第一次出现数值和下标不相等的位置就是<code>ans</code>，如果全部满足，返回数组长度即可。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">firstMissingPositive</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        nums.push_back(<span class="number">-1</span>);  <span class="comment">// 添加一个无用元素，方便后续操作</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;nums.size(); i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>( nums[i]&lt;<span class="number">0</span> || nums[i]&gt;=nums.size() || nums[nums[i]]==nums[i] )</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            swap(nums[nums[i]], nums[i]);</span><br><span class="line">            i--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;nums.size(); i++)&#123; <span class="comment">// i 从 1 开始，保证正整数</span></span><br><span class="line">            <span class="keyword">if</span>( nums[i]!=i )</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums.size();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="42、接雨水"><a href="#42、接雨水" class="headerlink" title="42、接雨水"></a>42、<a href="https://leetcode-cn.com/problems/trapping-rain-water" target="_blank" rel="noopener">接雨水</a></h2><p>先找到全局最高的那个柱子，然后从两边往最高柱靠近，靠近过程中不断更新当前最高柱，并根据当前最高柱的值来计算当前遍历点能够接雨水的量。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">trap</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; height)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(height.size()==<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> max_index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;height.size(); i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>( height[max_index]&lt;height[i] )</span><br><span class="line">                max_index = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> cur_max = height[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;max_index; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>( height[i]&gt;=cur_max )&#123;</span><br><span class="line">                cur_max = height[i];</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            ans += cur_max - height[i];</span><br><span class="line">        &#125;</span><br><span class="line">        cur_max = height[height.size()<span class="number">-1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=height.size()<span class="number">-2</span>; i&gt;max_index; i--)&#123;</span><br><span class="line">            <span class="keyword">if</span>( height[i]&gt;=cur_max )&#123;</span><br><span class="line">                cur_max = height[i];</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            ans += cur_max - height[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="43、字符串相乘"><a href="#43、字符串相乘" class="headerlink" title="43、字符串相乘"></a>43、<a href="https://leetcode-cn.com/problems/multiply-strings" target="_blank" rel="noopener">字符串相乘</a></h2><p>模拟题，使用字符串模拟乘法运算即可。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">multiply</span><span class="params">(<span class="built_in">string</span> num1, <span class="built_in">string</span> num2)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">string</span> ans, cur_multi;</span><br><span class="line">        <span class="keyword">int</span> multiplier, product_step;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=num2.size()<span class="number">-1</span>; i&gt;=<span class="number">0</span>; i--)&#123;</span><br><span class="line">            cur_multi = num1;</span><br><span class="line">            multiplier = num2[i] - <span class="string">'0'</span>;</span><br><span class="line">            product_step = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=cur_multi.size()<span class="number">-1</span>; j&gt;=<span class="number">0</span>; j--)&#123;</span><br><span class="line">                product_step += (cur_multi[j]-<span class="string">'0'</span>)*multiplier;</span><br><span class="line">                cur_multi[j] = product_step%<span class="number">10</span> + <span class="string">'0'</span>;</span><br><span class="line">                product_step /= <span class="number">10</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(product_step)</span><br><span class="line">                cur_multi.insert(cur_multi.begin(), product_step+<span class="string">'0'</span>);</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;num2.size()<span class="number">-1</span>-i; j++)</span><br><span class="line">                cur_multi += <span class="string">"0"</span>;</span><br><span class="line">            <span class="comment">// 计算 cur_multi + ans</span></span><br><span class="line">            <span class="keyword">int</span> m=<span class="number">0</span>, n=<span class="number">0</span>, sum=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(m=ans.size()<span class="number">-1</span>, n=cur_multi.size()<span class="number">-1</span>; m&gt;=<span class="number">0</span>&amp;&amp;n&gt;=<span class="number">0</span>; m--,n--)&#123;</span><br><span class="line">                sum += (ans[m]-<span class="string">'0'</span>) + (cur_multi[n]-<span class="string">'0'</span>);</span><br><span class="line">                ans[m] = sum%<span class="number">10</span> + <span class="string">'0'</span>;</span><br><span class="line">                sum /= <span class="number">10</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span>(m&gt;=<span class="number">0</span>)&#123;</span><br><span class="line">                sum += (ans[m]-<span class="string">'0'</span>);</span><br><span class="line">                ans[m] = sum%<span class="number">10</span> + <span class="string">'0'</span>;</span><br><span class="line">                sum /= <span class="number">10</span>;</span><br><span class="line">                m--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span>(n&gt;=<span class="number">0</span>)&#123;</span><br><span class="line">                sum += (cur_multi[n]-<span class="string">'0'</span>);</span><br><span class="line">                ans.insert(ans.begin(), sum%<span class="number">10</span>+<span class="string">'0'</span>);</span><br><span class="line">                sum /= <span class="number">10</span>;</span><br><span class="line">                n--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(sum)</span><br><span class="line">                ans.insert(ans.begin(), sum+<span class="string">'0'</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(ans.size()&gt;<span class="number">0</span> &amp;&amp; ans[<span class="number">0</span>]==<span class="string">'0'</span>)  <span class="comment">//过滤前导 0 </span></span><br><span class="line">            ans.erase(ans.begin());</span><br><span class="line">        <span class="keyword">return</span> ans.size()==<span class="number">0</span>? <span class="string">"0"</span> : ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="44、通配符匹配"><a href="#44、通配符匹配" class="headerlink" title="44、通配符匹配"></a>44、<a href="https://leetcode-cn.com/problems/wildcard-matching/" target="_blank" rel="noopener">通配符匹配</a></h2><p><code>dp</code> 题，写出状态转移方程即可。根据 <code>*</code> 号考虑各种情况。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isMatch</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">string</span> p)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> lenS = s.length(), lenP = p.length();</span><br><span class="line">        <span class="keyword">bool</span> match[lenS+<span class="number">1</span>][lenP+<span class="number">1</span>] = &#123;<span class="literal">true</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=lenS; i++)</span><br><span class="line">            match[i][<span class="number">0</span>] = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=lenP; i++)</span><br><span class="line">            match[<span class="number">0</span>][i] = p[i<span class="number">-1</span>]==<span class="string">'*'</span> &amp;&amp; match[<span class="number">0</span>][i<span class="number">-1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=lenS; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>; j&lt;=lenP; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>( p[j<span class="number">-1</span>]==<span class="string">'*'</span> )</span><br><span class="line">                    match[i][j] = match[i][j<span class="number">-1</span>] || match[i<span class="number">-1</span>][j];   <span class="comment">//匹配 0 个或多个</span></span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    match[i][j] = (s[i<span class="number">-1</span>]==p[j<span class="number">-1</span>] || p[j<span class="number">-1</span>]==<span class="string">'?'</span>) &amp;&amp; match[i<span class="number">-1</span>][j<span class="number">-1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> match[lenS][lenP];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="45、跳跃游戏-II"><a href="#45、跳跃游戏-II" class="headerlink" title="45、跳跃游戏 II"></a>45、<a href="https://leetcode-cn.com/problems/jump-game-ii/" target="_blank" rel="noopener">跳跃游戏 II</a></h2><p>贪心题，每次选择下次跳的最远的位置。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">jump</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> pos = <span class="number">0</span>, ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(pos &lt; nums.size()<span class="number">-1</span>)&#123;</span><br><span class="line">            <span class="keyword">int</span> max_step = <span class="number">-1</span>, max_index = <span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=nums[pos]; i++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(pos+i==nums.size()<span class="number">-1</span>)</span><br><span class="line">                    <span class="keyword">return</span> ans+<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span>(max_step &lt;= i+nums[pos+i])&#123;</span><br><span class="line">                    max_step = i + nums[pos+i];</span><br><span class="line">                    max_index = i;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            ans++;</span><br><span class="line">            pos = pos + max_index;</span><br><span class="line">            <span class="comment">//cout &lt;&lt; max_index &lt;&lt; " " &lt;&lt; pos &lt;&lt; endl;</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="46、全排列"><a href="#46、全排列" class="headerlink" title="46、全排列"></a>46、<a href="https://leetcode-cn.com/problems/permutations/" target="_blank" rel="noopener">全排列</a></h2><p>直接上 <code>next_permutation</code> 库函数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; permute(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt; <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; ans;</span><br><span class="line">        sort(nums.begin(), nums.end());</span><br><span class="line">        <span class="keyword">do</span>&#123;</span><br><span class="line">            ans.push_back(nums);</span><br><span class="line">        &#125;<span class="keyword">while</span>(next_permutation(nums.begin(), nums.end()));</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="47、全排列-II"><a href="#47、全排列-II" class="headerlink" title="47、全排列 II"></a>47、<a href="https://leetcode-cn.com/problems/permutations-ii/" target="_blank" rel="noopener">全排列 II</a></h2><p>之所以出现重复是因为相同的元素的排列导致的，<code>DFS</code> 实现全排列并去重。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt; <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; ans;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">DFS</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;&amp; book, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; temp_ans)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.size() == temp_ans.size())&#123;</span><br><span class="line">            ans.push_back(temp_ans);</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;nums.size(); i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(book[i]==<span class="literal">true</span>) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span>(i&gt;<span class="number">0</span> &amp;&amp; nums[i<span class="number">-1</span>]==nums[i] &amp;&amp; book[i<span class="number">-1</span>]==<span class="literal">false</span>) <span class="keyword">continue</span>;</span><br><span class="line">            book[i] = <span class="literal">true</span>;</span><br><span class="line">            temp_ans.push_back(nums[i]);</span><br><span class="line">            DFS(nums, book, temp_ans);</span><br><span class="line">            temp_ans.pop_back();</span><br><span class="line">            book[i] = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; permuteUnique(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        sort(nums.begin(), nums.end());</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; book(nums.size(), <span class="literal">false</span>);</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; temp_ans;</span><br><span class="line">        DFS(nums, book, temp_ans);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="48、旋转图像"><a href="#48、旋转图像" class="headerlink" title="48、旋转图像"></a>48、<a href="https://leetcode-cn.com/problems/rotate-image/" target="_blank" rel="noopener">旋转图像</a></h2><p>模拟题，计算好对应的位置即可。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">rotate</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; matrix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = matrix[<span class="number">0</span>].size();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> row=<span class="number">0</span>; row&lt;len/<span class="number">2</span>; row++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> col=row; col&lt;len<span class="number">-1</span>-row; col++)&#123;</span><br><span class="line">                <span class="keyword">int</span> tmp_val = matrix[row][col];</span><br><span class="line"></span><br><span class="line">                <span class="keyword">int</span> row1 = row, col1 = col;</span><br><span class="line">                matrix[row1][col1] = matrix[len<span class="number">-1</span>-col1][row1];</span><br><span class="line"></span><br><span class="line">                <span class="keyword">int</span> row2 = len<span class="number">-1</span>-col1, col2 = row1;</span><br><span class="line">                matrix[row2][col2] = matrix[len<span class="number">-1</span>-col2][row2];</span><br><span class="line"></span><br><span class="line">                <span class="keyword">int</span> row3 = len<span class="number">-1</span>-col2, col3 = row2;</span><br><span class="line">                matrix[row3][col3] = matrix[len<span class="number">-1</span>-col3][row3];</span><br><span class="line"></span><br><span class="line">                <span class="keyword">int</span> row4 = len<span class="number">-1</span>-col3, col4 = row3;</span><br><span class="line">                matrix[row4][col4] = tmp_val;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="49、字母异位词分组"><a href="#49、字母异位词分组" class="headerlink" title="49、字母异位词分组"></a>49、<a href="https://leetcode-cn.com/problems/group-anagrams/" target="_blank" rel="noopener">字母异位词分组</a></h2><p>水题，直接用 <code>map</code> 或者 <code>sort</code> 后使用 <code>vector</code>都可以。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">compare</span><span class="params">(<span class="built_in">string</span> s1, <span class="built_in">string</span> s2)</span></span>&#123;</span><br><span class="line">        sort(s1.begin(), s1.end());</span><br><span class="line">        sort(s2.begin(), s2.end());</span><br><span class="line">        <span class="keyword">return</span> s1 &lt; s2;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; groupAnagrams(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; strs) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; tmp_ans;</span><br><span class="line">        <span class="built_in">vector</span>&lt; <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; &gt; ans;</span><br><span class="line">        sort(strs.begin(), strs.end(), compare);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> str : strs)&#123;</span><br><span class="line">            <span class="keyword">if</span>(tmp_ans.size()==<span class="number">0</span>)&#123;</span><br><span class="line">                tmp_ans.push_back(str);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">string</span> s1 = tmp_ans.back();</span><br><span class="line">            <span class="built_in">string</span> s2 = str;</span><br><span class="line">            sort(s1.begin(), s1.end());</span><br><span class="line">            sort(s2.begin(), s2.end());</span><br><span class="line">            <span class="keyword">if</span>( s1!=s2 )&#123;</span><br><span class="line">                ans.push_back(tmp_ans);</span><br><span class="line">                tmp_ans.clear();</span><br><span class="line">                tmp_ans.push_back(str);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                tmp_ans.push_back(str);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(tmp_ans.size()&gt;=<span class="number">1</span>)</span><br><span class="line">            ans.push_back(tmp_ans);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="50、Pow-x-n"><a href="#50、Pow-x-n" class="headerlink" title="50、Pow(x, n)"></a>50、<a href="https://leetcode-cn.com/problems/powx-n/" target="_blank" rel="noopener">Pow(x, n)</a></h2><p>快速幂</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">myPow</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> flag = n&gt;=<span class="number">0</span>? <span class="number">1</span> : <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> N = (<span class="keyword">long</span> <span class="keyword">long</span>)(flag)*(<span class="keyword">long</span> <span class="keyword">long</span>)(n);</span><br><span class="line">        <span class="keyword">double</span> ans = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(N)&#123;</span><br><span class="line">            <span class="keyword">if</span>(N%<span class="number">2</span>)</span><br><span class="line">                ans *= x;</span><br><span class="line">            x *= x;</span><br><span class="line">            N /= <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> flag==<span class="number">-1</span>? <span class="number">1.0</span>/ans : ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;41、缺失的第一个正数&quot;&gt;&lt;a href=&quot;#41、缺失的第一个正数&quot; class=&quot;headerlink&quot; title=&quot;41、缺失的第一个正数&quot;&gt;&lt;/a&gt;41、&lt;a href=&quot;https://leetcode-cn.com/problems/first-missing-positive&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;缺失的第一个正数&lt;/a&gt;&lt;/h2&gt;&lt;p&gt;数组中元素互换，让元素大小与下标相对应。数值小于0或者大于数组长度的元素值，直接略过，之后遍历整个数组，第一次出现数值和下标不相等的位置就是&lt;code&gt;ans&lt;/code&gt;，如果全部满足，返回数组长度即可。&lt;/p&gt;
&lt;figure class=&quot;highlight c++&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Solution&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt;:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;firstMissingPositive&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;built_in&quot;&gt;vector&lt;/span&gt;&amp;lt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt;&amp;gt;&amp;amp; nums)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        nums.push_back(&lt;span class=&quot;number&quot;&gt;-1&lt;/span&gt;);  &lt;span class=&quot;comment&quot;&gt;// 添加一个无用元素，方便后续操作&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt;(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; i=&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;; i&amp;lt;nums.size(); i++)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;( nums[i]&amp;lt;&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt; || nums[i]&amp;gt;=nums.size() || nums[nums[i]]==nums[i] )&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &lt;span class=&quot;keyword&quot;&gt;continue&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            swap(nums[nums[i]], nums[i]);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            i--;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt;(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; i=&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;; i&amp;lt;nums.size(); i++)&amp;#123; &lt;span class=&quot;comment&quot;&gt;// i 从 1 开始，保证正整数&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;( nums[i]!=i )&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; i;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; nums.size();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="LeetCode" scheme="https://wangjibao.com.cn/categories/LeetCode/"/>
    
      <category term="LeetCode41-50" scheme="https://wangjibao.com.cn/categories/LeetCode/LeetCode41-50/"/>
    
    
      <category term="LeetCode" scheme="https://wangjibao.com.cn/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode31-40</title>
    <link href="https://wangjibao.com.cn/2019/05/09/LeetCode31-40/"/>
    <id>https://wangjibao.com.cn/2019/05/09/LeetCode31-40/</id>
    <published>2019-05-08T16:19:05.000Z</published>
    <updated>2019-05-09T06:52:38.873Z</updated>
    
    <content type="html"><![CDATA[<h2 id="31、下一个排列"><a href="#31、下一个排列" class="headerlink" title="31、下一个排列"></a>31、<a href="https://leetcode-cn.com/problems/next-permutation" target="_blank" rel="noopener">下一个排列</a></h2><p>偷个懒，直接使用库函数<code>next_permutation</code>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">nextPermutation</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        next_permutation(nums.begin(), nums.end());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="32、最长有效括号"><a href="#32、最长有效括号" class="headerlink" title="32、最长有效括号"></a>32、<a href="https://leetcode-cn.com/problems/longest-valid-parentheses" target="_blank" rel="noopener">最长有效括号</a></h2><p>用栈进行括号匹配消除，在消除过程中记录最大长度值。</p><a id="more"></a><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">longestValidParentheses</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">stack</span>&lt; pair&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt; &gt; st;</span><br><span class="line">        st.push(make_pair(<span class="string">'#'</span>, <span class="number">-1</span>));</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;s.length(); i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>( st.top().first==<span class="string">'('</span> &amp;&amp; s[i]==<span class="string">')'</span> )&#123;</span><br><span class="line">                st.pop();</span><br><span class="line">                ans = max(ans, i-st.top().second);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                st.push(make_pair(s[i], i));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="33、搜索旋转排序数组"><a href="#33、搜索旋转排序数组" class="headerlink" title="33、搜索旋转排序数组"></a>33、<a href="https://leetcode-cn.com/problems/search-in-rotated-sorted-array" target="_blank" rel="noopener">搜索旋转排序数组</a></h2><p>变形的二分搜索，关键点一：判断<code>mid</code>到底位于数组的前半段还是后半段；关键点二：判断下一步的搜索方向。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">search</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>, r = nums.size()<span class="number">-1</span>, mid;</span><br><span class="line">        <span class="keyword">while</span>(l&lt;=r)&#123;</span><br><span class="line">            mid = (l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>( nums[mid] &gt;= nums[l] )&#123;  <span class="comment">//落在左边</span></span><br><span class="line">                <span class="keyword">if</span>( target &gt; nums[mid] )</span><br><span class="line">                    l = mid + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>( target &lt; nums[mid] )&#123;</span><br><span class="line">                    <span class="keyword">if</span>( target&gt;nums[l] )</span><br><span class="line">                        r = mid - <span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span>( target&lt;nums[l] )</span><br><span class="line">                        l = mid + <span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                        <span class="keyword">return</span>  l;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    <span class="keyword">return</span> mid;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>( nums[mid] &lt;= nums[r] )&#123;   <span class="comment">//落在右边</span></span><br><span class="line">                <span class="keyword">if</span>( target &lt; nums[mid] )</span><br><span class="line">                    r = mid - <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>( target &gt; nums[mid] )&#123;</span><br><span class="line">                    <span class="keyword">if</span>( target&lt;nums[r] )</span><br><span class="line">                        l = mid + <span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span>( target&gt;nums[r] )</span><br><span class="line">                        r = mid - <span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                        <span class="keyword">return</span> r;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    <span class="keyword">return</span> mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="34、在排序数组中查找元素的第一个和最后一个位置"><a href="#34、在排序数组中查找元素的第一个和最后一个位置" class="headerlink" title="34、在排序数组中查找元素的第一个和最后一个位置"></a>34、<a href="https://leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array" target="_blank" rel="noopener">在排序数组中查找元素的第一个和最后一个位置</a></h2><p>使用模板库里的二分查找函数，<code>lower_bound</code>查找第一个大于或等于某个元素的位置，<code>upper_bound</code>查找第一个大于某个元素的位置。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; searchRange(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        <span class="keyword">int</span> l = lower_bound(nums.begin(), nums.end(), target) - nums.begin();</span><br><span class="line">        <span class="keyword">int</span> r = upper_bound(nums.begin(), nums.end(), target) - nums.begin();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ans&#123;l,r<span class="number">-1</span>&#125;;</span><br><span class="line">        <span class="keyword">if</span>(l==r)</span><br><span class="line">           ans[<span class="number">0</span>] = ans[<span class="number">1</span>] = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="35、搜索插入位置"><a href="#35、搜索插入位置" class="headerlink" title="35、搜索插入位置"></a>35、<a href="https://leetcode-cn.com/problems/search-insert-position" target="_blank" rel="noopener">搜索插入位置</a></h2><p>同样偷懒使用库提供的二分查找函数<code>lower_bound</code>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">searchInsert</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> lower_bound(nums.begin(), nums.end(), target) - nums.begin();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="36、有效的数独"><a href="#36、有效的数独" class="headerlink" title="36、有效的数独"></a>36、<a href="https://leetcode-cn.com/problems/valid-sudoku" target="_blank" rel="noopener">有效的数独</a></h2><p>搞个<code>book</code>数组记录，然后直接暴力循环判断就行了。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isValidSudoku</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; board)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">bool</span> book_row[<span class="number">9</span>][<span class="number">9</span>], book_col[<span class="number">9</span>][<span class="number">9</span>], book_cell[<span class="number">9</span>][<span class="number">9</span>];</span><br><span class="line">        <span class="built_in">memset</span>(book_row, <span class="number">0</span>, <span class="keyword">sizeof</span>(book_row));</span><br><span class="line">        <span class="built_in">memset</span>(book_col, <span class="number">0</span>, <span class="keyword">sizeof</span>(book_col));</span><br><span class="line">        <span class="built_in">memset</span>(book_cell, <span class="number">0</span>, <span class="keyword">sizeof</span>(book_cell));</span><br><span class="line">        <span class="keyword">int</span> num;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">9</span>; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;<span class="number">9</span>; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(board[i][j]==<span class="string">'.'</span>)</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                num = board[i][j] - <span class="string">'0'</span> - <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span>(book_row[i][num] || book_col[j][num] || book_cell[i/<span class="number">3</span>*<span class="number">3</span>+j/<span class="number">3</span>][num])</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                book_row[i][num] = <span class="literal">true</span>;</span><br><span class="line">                book_col[j][num] = <span class="literal">true</span>;</span><br><span class="line">                book_cell[i/<span class="number">3</span>*<span class="number">3</span>+j/<span class="number">3</span>][num] = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="37、解数独"><a href="#37、解数独" class="headerlink" title="37、解数独"></a>37、<a href="https://leetcode-cn.com/problems/sudoku-solver" target="_blank" rel="noopener">解数独</a></h2><p>深搜入门题，注意期间的剪枝操作。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">bool</span> book_row[<span class="number">9</span>][<span class="number">9</span>];</span><br><span class="line">    <span class="keyword">bool</span> book_col[<span class="number">9</span>][<span class="number">9</span>];</span><br><span class="line">    <span class="keyword">bool</span> book_cell[<span class="number">9</span>][<span class="number">9</span>];</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">mySolve</span><span class="params">(<span class="built_in">vector</span>&lt; <span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt; &gt;&amp; board, <span class="keyword">int</span> position)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>( position==<span class="number">81</span> )</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">int</span> row = position/<span class="number">9</span>;</span><br><span class="line">        <span class="keyword">int</span> col = position%<span class="number">9</span>;</span><br><span class="line">        <span class="keyword">if</span>(board[row][col]!=<span class="string">'.'</span>)</span><br><span class="line">            <span class="keyword">return</span> mySolve(board, position+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">9</span>; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>( !book_row[row][i] &amp;&amp; !book_col[col][i] &amp;&amp; !book_cell[row/<span class="number">3</span>*<span class="number">3</span>+col/<span class="number">3</span>][i] )&#123;</span><br><span class="line">                board[row][col] = <span class="string">'1'</span>+i;</span><br><span class="line">                book_row[row][i] = <span class="literal">true</span>;</span><br><span class="line">                book_col[col][i] = <span class="literal">true</span>;</span><br><span class="line">                book_cell[row/<span class="number">3</span>*<span class="number">3</span>+col/<span class="number">3</span>][i] = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">if</span>(!mySolve(board, position+<span class="number">1</span>))&#123;</span><br><span class="line">                    board[row][col] = <span class="string">'.'</span>;</span><br><span class="line">                    book_row[row][i] = <span class="literal">false</span>;</span><br><span class="line">                    book_col[col][i] = <span class="literal">false</span>;</span><br><span class="line">                    book_cell[row/<span class="number">3</span>*<span class="number">3</span>+col/<span class="number">3</span>][i] = <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;  <span class="comment">//唯一解</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">solveSudoku</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; board)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">9</span>; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;<span class="number">9</span>; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>( board[i][j]!=<span class="string">'.'</span> )&#123;</span><br><span class="line">                    <span class="keyword">int</span> num = board[i][j] - <span class="string">'0'</span> - <span class="number">1</span>;</span><br><span class="line">                    book_row[i][num] = <span class="literal">true</span>;</span><br><span class="line">                    book_col[j][num] = <span class="literal">true</span>;</span><br><span class="line">                    book_cell[i/<span class="number">3</span>*<span class="number">3</span>+j/<span class="number">3</span>][num] = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        mySolve(board, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="38、报数"><a href="#38、报数" class="headerlink" title="38、报数"></a>38、<a href="https://leetcode-cn.com/problems/count-and-say" target="_blank" rel="noopener">报数</a></h2><p>模拟题</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">countAndSay</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">string</span> ans = <span class="string">"1"</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> step=<span class="number">1</span>; step&lt;n; step++)&#123;</span><br><span class="line">            <span class="built_in">string</span> tmp_ans;</span><br><span class="line">            <span class="keyword">int</span> sum = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">char</span> ch = ans[<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;ans.size(); i++)&#123;</span><br><span class="line">                <span class="keyword">if</span>( ch == ans[i] )&#123;</span><br><span class="line">                    sum++;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                tmp_ans += (to_string(sum) + ch);</span><br><span class="line">                ch = ans[i];</span><br><span class="line">                sum = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            tmp_ans += (to_string(sum) + ch);</span><br><span class="line">            ans = tmp_ans;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="39、组合总和"><a href="#39、组合总和" class="headerlink" title="39、组合总和"></a>39、<a href="https://leetcode-cn.com/problems/combination-sum" target="_blank" rel="noopener">组合总和</a></h2><p>深搜入门题，注意期间的剪枝操作。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt; <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; ans;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">DFS</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; candidates, <span class="keyword">int</span> target, <span class="keyword">int</span> position, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; tmp_ans)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(target==<span class="number">0</span>)&#123;</span><br><span class="line">            ans.push_back(tmp_ans);</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=position; i&lt;candidates.size(); i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>( target&gt;=candidates[i] )&#123;  <span class="comment">//一个小剪枝</span></span><br><span class="line">                tmp_ans.push_back(candidates[i]);</span><br><span class="line">                DFS(candidates, target-candidates[i], i, tmp_ans);</span><br><span class="line">                tmp_ans.pop_back();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; combinationSum(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; candidates, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        sort(candidates.begin(), candidates.end());  <span class="comment">// 排序为了后期剪枝用</span></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; tmp_ans;</span><br><span class="line">        DFS(candidates, target, <span class="number">0</span>, tmp_ans);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="40、组合总和-II"><a href="#40、组合总和-II" class="headerlink" title="40、组合总和 II"></a>40、<a href="https://leetcode-cn.com/problems/combination-sum-ii" target="_blank" rel="noopener">组合总和 II</a></h2><p>在<code>39</code>题的基础上稍微改一下即可，一是<code>13</code>行的禁止元素重复使用，二是<code>15</code>行的去重操作。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt; <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; ans;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">DFS</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; candidates, <span class="keyword">int</span> target, <span class="keyword">int</span> position, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; tmp_ans)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(target==<span class="number">0</span>)&#123;</span><br><span class="line">            ans.push_back(tmp_ans);</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=position; i&lt;candidates.size(); i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>( target&gt;=candidates[i] )&#123;  <span class="comment">//一个小剪枝</span></span><br><span class="line">                tmp_ans.push_back(candidates[i]);</span><br><span class="line">                DFS(candidates, target-candidates[i], i+<span class="number">1</span>, tmp_ans);</span><br><span class="line">                tmp_ans.pop_back();</span><br><span class="line">                <span class="keyword">while</span>(i+<span class="number">1</span>&lt;candidates.size() &amp;&amp; candidates[i+<span class="number">1</span>]==candidates[i]) <span class="comment">// 去重操作</span></span><br><span class="line">                    i++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; combinationSum2(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; candidates, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        sort(candidates.begin(), candidates.end());  <span class="comment">// 排序为了后期剪枝用</span></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; tmp_ans;</span><br><span class="line">        ans.clear();</span><br><span class="line">        DFS(candidates, target, <span class="number">0</span>, tmp_ans);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;31、下一个排列&quot;&gt;&lt;a href=&quot;#31、下一个排列&quot; class=&quot;headerlink&quot; title=&quot;31、下一个排列&quot;&gt;&lt;/a&gt;31、&lt;a href=&quot;https://leetcode-cn.com/problems/next-permutation&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;下一个排列&lt;/a&gt;&lt;/h2&gt;&lt;p&gt;偷个懒，直接使用库函数&lt;code&gt;next_permutation&lt;/code&gt;。&lt;/p&gt;
&lt;figure class=&quot;highlight c++&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Solution&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt;:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;nextPermutation&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;built_in&quot;&gt;vector&lt;/span&gt;&amp;lt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt;&amp;gt;&amp;amp; nums)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        next_permutation(nums.begin(), nums.end());&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h2 id=&quot;32、最长有效括号&quot;&gt;&lt;a href=&quot;#32、最长有效括号&quot; class=&quot;headerlink&quot; title=&quot;32、最长有效括号&quot;&gt;&lt;/a&gt;32、&lt;a href=&quot;https://leetcode-cn.com/problems/longest-valid-parentheses&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;最长有效括号&lt;/a&gt;&lt;/h2&gt;&lt;p&gt;用栈进行括号匹配消除，在消除过程中记录最大长度值。&lt;/p&gt;
    
    </summary>
    
      <category term="LeetCode" scheme="https://wangjibao.com.cn/categories/LeetCode/"/>
    
      <category term="LeetCode31-40" scheme="https://wangjibao.com.cn/categories/LeetCode/LeetCode31-40/"/>
    
    
      <category term="LeetCode" scheme="https://wangjibao.com.cn/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>双仓库部署实现博客访问加速</title>
    <link href="https://wangjibao.com.cn/2019/04/22/%E5%8F%8C%E4%BB%93%E5%BA%93%E9%83%A8%E7%BD%B2%E5%AE%9E%E7%8E%B0%E5%8D%9A%E5%AE%A2%E8%AE%BF%E9%97%AE%E5%8A%A0%E9%80%9F/"/>
    <id>https://wangjibao.com.cn/2019/04/22/双仓库部署实现博客访问加速/</id>
    <published>2019-04-21T16:53:40.000Z</published>
    <updated>2019-04-21T18:03:28.139Z</updated>
    
    <content type="html"><![CDATA[<p>博客停更了将近半年的时间，然后近期闲着打算接着写写记录下日常学习过程，其中被同学吐槽，你这访问太慢了啊，页面好大会转不出来，怎么回事小老弟？<code>github pages</code>国内访问的话，速度还是很慢的，想要更好的提升访问速度，得将博客迁移到国内才行，幸运的是，国内的<code>coding.net</code>也提供<code>pages</code>服务。下面，我们主要讲解如何实现个人博客的<strong>双仓库</strong>部署。</p><p>1、注册 <code>coding</code> 账号，创建一个和注册名一样的仓库，部署公钥，此处部署的公钥一定要和<code>github pages</code>上的公钥一致。运行 <code>ssh -T git@git.coding.net</code> 指令，测试公钥是否添加成功，如下图所示，代表成功添加了公钥。</p><p><img src="/2019/04/22/双仓库部署实现博客访问加速/public_key.png" alt=""></p><p>2、<code>deploy</code>部署配置，更改本地 根目录下的<code>_config.yml</code>文件，如下图，这样才可以实现两个仓库的同步推送。</p><a id="more"></a><p><img src="/2019/04/22/双仓库部署实现博客访问加速/deploy.png" alt=""></p><p>配置完成后，<code>hexo clean;   hexo g -d</code> 将博客内容同步到两个仓库，在 <code>coding.net</code>中记得同步完成后开启<code>pages 服务</code>，此时便可以访问地址 <code>localdomain.coding.net</code>来浏览博客内容了。</p><p><img src="/2019/04/22/双仓库部署实现博客访问加速/pages.png" alt=""></p><p>3、<code>Pages 服务 &gt;&gt; 设置</code>中，绑定个人域名。我对此步骤的理解是，因为后期要将自己个人域名的<code>CNAME</code>指向这里，所以要绑定一下个人域名来实现验证的效果，如果没有验证的话，任何人买个域名，然后设置<code>CNAME</code>指向这里，就可以通过其他人的域名肆意访问我的资源了，这是不能容忍的。通过绑定机制，属于我的资源我可以控制通过哪些域名可以来访问。</p><p><img src="/2019/04/22/双仓库部署实现博客访问加速/bind_dns.png" alt=""></p><p>4、之前在 阿里云 买的域名， 设置域名解析如图：</p><p><img src="/2019/04/22/双仓库部署实现博客访问加速/dns.png" alt=""></p><p>当在国内访问 <code>www.wangjibao.com.cn</code>时，会解析国内的<code>localdomain.coding.net</code>，这样速度比较快。</p><p>无论在国内还是国外访问<code>wangjibao.com.cn</code>时，会直接返回<code>185.199.111.153</code>的<code>github.io</code>的地址，虽然速度可能有些慢，但这样实现了无论加不加<code>www</code>的头都可以访问博客的目的。</p><p>当在国外访问<code>www.wangjibao.com.cn</code>时，会解析国外的<code>wangjibao.github.io</code>的地址，对外国人来说的话， 速度也不慢。</p><p><img src="/2019/04/22/双仓库部署实现博客访问加速/nslookup.png" alt=""></p><p>5、上图中的 <code>nslookup</code>印证了我们的想法，接下来使用站长之家的<a href="http://tool.chinaz.com/speedtest.aspx" target="_blank" rel="noopener">网站测速</a>功能，查看改造前与改造后的访问速度效果图，如下：</p><p><img src="/2019/04/22/双仓库部署实现博客访问加速/qian.png" alt=""></p><p><img src="/2019/04/22/双仓库部署实现博客访问加速/hou.png" alt=""></p><p>看着就舒坦啊，要想生活过得去，就需要来点绿。穷X一枚，等后期有空看看能不能通过免费的<code>CDN</code>再加速一波。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;博客停更了将近半年的时间，然后近期闲着打算接着写写记录下日常学习过程，其中被同学吐槽，你这访问太慢了啊，页面好大会转不出来，怎么回事小老弟？&lt;code&gt;github pages&lt;/code&gt;国内访问的话，速度还是很慢的，想要更好的提升访问速度，得将博客迁移到国内才行，幸运的是，国内的&lt;code&gt;coding.net&lt;/code&gt;也提供&lt;code&gt;pages&lt;/code&gt;服务。下面，我们主要讲解如何实现个人博客的&lt;strong&gt;双仓库&lt;/strong&gt;部署。&lt;/p&gt;
&lt;p&gt;1、注册 &lt;code&gt;coding&lt;/code&gt; 账号，创建一个和注册名一样的仓库，部署公钥，此处部署的公钥一定要和&lt;code&gt;github pages&lt;/code&gt;上的公钥一致。运行 &lt;code&gt;ssh -T git@git.coding.net&lt;/code&gt; 指令，测试公钥是否添加成功，如下图所示，代表成功添加了公钥。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/2019/04/22/双仓库部署实现博客访问加速/public_key.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;2、&lt;code&gt;deploy&lt;/code&gt;部署配置，更改本地 根目录下的&lt;code&gt;_config.yml&lt;/code&gt;文件，如下图，这样才可以实现两个仓库的同步推送。&lt;/p&gt;
    
    </summary>
    
      <category term="笔记" scheme="https://wangjibao.com.cn/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="笔记" scheme="https://wangjibao.com.cn/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>Ubuntu个性美化</title>
    <link href="https://wangjibao.com.cn/2019/04/20/Ubuntu%E4%B8%AA%E6%80%A7%E7%BE%8E%E5%8C%96/"/>
    <id>https://wangjibao.com.cn/2019/04/20/Ubuntu个性美化/</id>
    <published>2019-04-20T08:26:33.000Z</published>
    <updated>2019-04-20T08:40:49.852Z</updated>
    
    <content type="html"><![CDATA[<p>1、<strong>安装<code>VMware Tools</code></strong></p><p>在<code>VMware</code>中安装虚拟机后，记得安装<code>VMware Tools</code>。在虚拟机中找到名为<code>VMwareTools…tar.gz</code>的压缩包（一般在<code>media</code>文件夹中），复制到某个文件夹中后执行：<code>tar -xvzf VMwareTools…tar.gz</code>进行解压。之后会看到一个 <code>./vmware-install.pl</code>的执行程序，执行后安装，一路默认即可，安装完成后，重启虚拟机。</p><p>2、<strong>卸载自带软件</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dpkg --list   # 查看自带已安装程序</span><br><span class="line">sudo apt-get --purge remove &lt;programname&gt;      # 卸载程序和所有配置文件</span><br><span class="line">sudo apt-get remove &lt;programname&gt;              # 只卸载程序</span><br></pre></td></tr></table></figure><p>当然也可以在<code>软件管理</code>中进行查看已安装软件，卸载软件等操作。</p><p>3、<strong><code>GTK</code>,<code>GTK+</code>,<code>Qt</code>, <code>KDE</code>,<code>GNOME</code>, <code>Unity</code>的区别与联系</strong></p><a id="more"></a><p>Linux本身没有图形界面，Linux现在的图形界面系统只是Linux下的应用程序。</p><p><code>GTK</code>,  <code>GTK+</code>, <code>Qt</code>是图形界面开发库(GUI Toolkit)，用户可以使用这些开发库编写GUI应用。</p><p><code>KDE</code>，<code>GNOME</code>，<code>Unity</code>是<code>linux</code>下的桌面环境(Desktop Environment)，其中<code>KDE</code>使用<code>Qt</code>开发，<code>GNOME</code>使用<code>GTK+</code>开发，<code>Unity</code>是基于<code>GNOME</code>开发的一个桌面环境。</p><p>从 <code>Ubuntu 16.04 LTS</code> 到<code>Ubuntu 18.04 LTS</code> 最显著的变化是 Unity 用户界面被替换为了GNOME 桌面环境。</p><p>4、<strong>安装美化主题</strong></p><p><a href="https://www.cnblogs.com/feipeng8848/p/8970556.html" target="_blank" rel="noopener">参考博客</a>，本文用到的主题工具包<a href="/download/Ubuntu美化.rar">下载</a></p><p>美化过程中涉及的两个目录：<code>/usr/share/themes</code> 和 <code>/usr/share/icons</code>。</p><p>1）安装 <code>TweakTool</code> 工具：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install gnome-tweak-tool</span><br><span class="line">sudo apt-get install gnome-shell-extensions   # 解决Tweaks中shell无法设置的问题</span><br></pre></td></tr></table></figure><p>2）安装<code>GTK</code>主题，修改图标，更改桌面<code>shell</code>，<a href="https://www.opendesktop.org/" target="_blank" rel="noopener">下载网址</a>，将主题和桌面shell放到<code>/usr/share/themes/</code>目录下，图标包放到<code>/usr/share/icons/</code>文件夹下，之后在<code>Tweaks</code>工具中，即可选择使用它们</p><p><img src="/2019/04/20/Ubuntu个性美化/tweaks.png" alt=""></p><p>效果图如下：</p><p><img src="/2019/04/20/Ubuntu个性美化/macos.png" alt=""></p><p>3）更改开机动画，<a href="https://www.gnome-look.org/" target="_blank" rel="noopener">下载网址</a></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">将下载的开机动画解压并拷贝到： usr/share/plymouth/themes</span><br><span class="line">sudo update-alternatives --install /usr/share/plymouth/themes/default.plymouth default.plymouth /usr/share/plymouth/themes/***/***.plymouth 100</span><br><span class="line">sudo update-alternatives --config default.plymouth  # 选择对应序号即可，*号代表当前使用</span><br><span class="line">sudo update-initramfs -u</span><br></pre></td></tr></table></figure><p>4）更改<a href="https://github.com/taeven/Ocean-blue-GDM3" target="_blank" rel="noopener">登录界面的背景</a>（也可只修改<code>css</code>文件中对应的图片链接即可）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">cp 下载的登录界面.jpg /usr/share/backgrounds/</span><br><span class="line"><span class="meta">#</span> 备份自带登录css文件</span><br><span class="line">cp /usr/share/gnome-shell/theme/ubuntu.css /usr/share/gnome-shell/theme/ubuntu.css.bak</span><br><span class="line">cp 下载的并更名为ubuntu.css的文件 /usr/share/gnome-shell/theme/</span><br><span class="line">reboot</span><br></pre></td></tr></table></figure><p>效果图：</p><p><img src="/2019/04/20/Ubuntu个性美化/login.png" alt=""></p><p>4）修改桌面<code>shell</code>的宽度和字体等。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;1、&lt;strong&gt;安装&lt;code&gt;VMware Tools&lt;/code&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在&lt;code&gt;VMware&lt;/code&gt;中安装虚拟机后，记得安装&lt;code&gt;VMware Tools&lt;/code&gt;。在虚拟机中找到名为&lt;code&gt;VMwareTools…tar.gz&lt;/code&gt;的压缩包（一般在&lt;code&gt;media&lt;/code&gt;文件夹中），复制到某个文件夹中后执行：&lt;code&gt;tar -xvzf VMwareTools…tar.gz&lt;/code&gt;进行解压。之后会看到一个 &lt;code&gt;./vmware-install.pl&lt;/code&gt;的执行程序，执行后安装，一路默认即可，安装完成后，重启虚拟机。&lt;/p&gt;
&lt;p&gt;2、&lt;strong&gt;卸载自带软件&lt;/strong&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight shell&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;dpkg --list   # 查看自带已安装程序&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;sudo apt-get --purge remove &amp;lt;programname&amp;gt;      # 卸载程序和所有配置文件&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;sudo apt-get remove &amp;lt;programname&amp;gt;              # 只卸载程序&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;当然也可以在&lt;code&gt;软件管理&lt;/code&gt;中进行查看已安装软件，卸载软件等操作。&lt;/p&gt;
&lt;p&gt;3、&lt;strong&gt;&lt;code&gt;GTK&lt;/code&gt;,&lt;code&gt;GTK+&lt;/code&gt;,&lt;code&gt;Qt&lt;/code&gt;, &lt;code&gt;KDE&lt;/code&gt;,&lt;code&gt;GNOME&lt;/code&gt;, &lt;code&gt;Unity&lt;/code&gt;的区别与联系&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="笔记" scheme="https://wangjibao.com.cn/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="笔记" scheme="https://wangjibao.com.cn/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>Ubuntu官方源和PPA源简介</title>
    <link href="https://wangjibao.com.cn/2019/04/20/Ubuntu%E5%AE%98%E6%96%B9%E6%BA%90%E5%92%8CPPA%E6%BA%90%E7%AE%80%E4%BB%8B/"/>
    <id>https://wangjibao.com.cn/2019/04/20/Ubuntu官方源和PPA源简介/</id>
    <published>2019-04-20T08:12:10.000Z</published>
    <updated>2019-04-20T08:25:32.475Z</updated>
    
    <content type="html"><![CDATA[<p>在<code>ubuntu</code>中，软件的安装主要有3种方式：</p><ul><li><p>通过<code>apt</code>包管理工具从官方软件源安装</p></li><li><p>通过<code>deb</code>格式的软件包安装，以安装<code>搜狗输入法</code>为例：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">下载 sogou.deb</span><br><span class="line">sudo dpkg -i sogou.deb       #出现安装不成功，需要依赖</span><br><span class="line">sudo apt-get install -f      #安装依赖</span><br><span class="line">sudo dpkg -i sogou.deb</span><br></pre></td></tr></table></figure></li><li><p>使用软件的源码手动编译安装</p></li></ul><p>下面我们主要介绍第一种安装方式，即<code>apt</code>命令从软件源安装。软件源分为 <code>Ubuntu官方软件源</code> 和 <code>PPA软件源</code> 两种。</p><a id="more"></a><p>1）<code>Ubuntu</code> 官方软件源，其中包含了系统中绝大多数的软件，对应的目录为 <code>/etc/apt/sources.list</code>，如下所示：</p><p><img src="/2019/04/20/Ubuntu官方源和PPA源简介/sources_list.png" alt=""></p><p>一般情况下，我们会将其改成国内的镜像源，因为访问国外的资源太慢了，<a href="https://segmentfault.com/a/1190000000375848" target="_blank" rel="noopener">国内开源镜像站点汇总</a>。</p><p>安装和卸载软件也非常的简单：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install &lt;package-name&gt;    # 安装</span><br><span class="line">sudo apt-get remove &lt;package-name&gt;     # 卸载</span><br></pre></td></tr></table></figure><p>每当通过 <code>install</code> 命令去安装一个软件时，apt 包管理工具就会从系统中的<code>/etc/apt/sources.list</code>文件或<code>/etc/apt/sources.list.d</code>文件夹中去读取软件源的网址信息，查找可以包含该软件的软件源的网址，然后就从这个网址上把指定的软件给下载下来，然后由 apt 包管理工具在本地进行一些解压和安装的其他操作。</p><p>2）<code>PPA(Personal Package Archives)</code>个人软件包集，它出现的原因是：系统自带的源是非常有限的 ，如果通过<code>deb</code>直接安装其他软件的话，得不到更新和维护，所以此时<code>PPA</code>软件源就应运而生。它其实是一个<a href="https://launchpad.net/" target="_blank" rel="noopener">网站</a>，开发者们在上面建立自己的仓库，上传开发的软件供用户安装。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo add-apt-repository ppa:user/ppa-name    # 添加ppa软件源</span><br><span class="line">sudo add-apt-repository --remove ppa:user/ppa-name    # 删除ppa软件源</span><br></pre></td></tr></table></figure><p>当添加完某个<code>ppa</code>软件源后，会在系统的 <code>/etc/apt/sources.list.d</code> 目录下生成对应的源文件：</p><p><img src="/2019/04/20/Ubuntu官方源和PPA源简介/sources_list_d.png" alt=""></p><p>可见，此操作就是在文件里添加了一个和软件源一模一样的东西，以 <code>notepad++</code> 的使用为例：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> 安装</span><br><span class="line">sudo add-apt-repository ppa:notepadqq-team/notepadqq</span><br><span class="line">sudo apt-get update   # 记得此时要更新一下软件源</span><br><span class="line">sudo apt-get install notepadqq</span><br><span class="line"><span class="meta">#</span> 卸载</span><br><span class="line">sudo apt-get remove notepadqq</span><br><span class="line">sudo add-apt-repository --remove ppa:notepadqq-team/notepadqq</span><br></pre></td></tr></table></figure><p>3）上面两个东西，其实要实现的功能是一样的，之所以在系统中存在<code>/etc/apt/sources.list</code>和<code>/etc/apt/sources.list.d</code>两套东西，是系统为了区分官方源与第三方源，毕竟第三方源存在安全问题的可能性比较大。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在&lt;code&gt;ubuntu&lt;/code&gt;中，软件的安装主要有3种方式：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;通过&lt;code&gt;apt&lt;/code&gt;包管理工具从官方软件源安装&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;通过&lt;code&gt;deb&lt;/code&gt;格式的软件包安装，以安装&lt;code&gt;搜狗输入法&lt;/code&gt;为例：&lt;/p&gt;
&lt;figure class=&quot;highlight shell&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;下载 sogou.deb&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;sudo dpkg -i sogou.deb       #出现安装不成功，需要依赖&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;sudo apt-get install -f      #安装依赖&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;sudo dpkg -i sogou.deb&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;使用软件的源码手动编译安装&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;下面我们主要介绍第一种安装方式，即&lt;code&gt;apt&lt;/code&gt;命令从软件源安装。软件源分为 &lt;code&gt;Ubuntu官方软件源&lt;/code&gt; 和 &lt;code&gt;PPA软件源&lt;/code&gt; 两种。&lt;/p&gt;
    
    </summary>
    
      <category term="笔记" scheme="https://wangjibao.com.cn/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="笔记" scheme="https://wangjibao.com.cn/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>HTTP抓包实战</title>
    <link href="https://wangjibao.com.cn/2018/11/13/HTTP%E6%8A%93%E5%8C%85%E5%AE%9E%E6%88%98/"/>
    <id>https://wangjibao.com.cn/2018/11/13/HTTP抓包实战/</id>
    <published>2018-11-13T15:39:06.000Z</published>
    <updated>2018-11-16T16:33:47.860Z</updated>
    
    <content type="html"><![CDATA[<p>开始读《HTTP抓包实战》，在这个作业满天飞的日子里，计划1周读完，本篇博文对其中的部分知识点做一下简单的记录。</p><p>1、HTTP抓包分析使用的工具不再是wireshark（研究TCP/IP协议使用），而是使用 <a href="https://www.telerik.com/fiddler" target="_blank" rel="noopener">fiddler</a>，版本4。其实 fiddler 做HTTP数据包分析的原理就是相当于一个<strong>web代理</strong>，如下图：</p><p><img src="/2018/11/13/HTTP抓包实战/web_proxy.png" alt=""></p><p>fiddler在中间，可以记录所用的HTTP流量。fiddler启动时，会偷偷把 Internet 选项中的代理修改为 ：127.0.0.1,端口： 8888; fiddler在关闭时，会自动在Internet选项中取消代理，这样就不会对其他程序产生影响。如下图：</p><p><img src="/2018/11/13/HTTP抓包实战/127001.png" alt=""></p><a id="more"></a><p>fiddler界面如下图，使用方法请自行百度或google.</p><p><img src="/2018/11/13/HTTP抓包实战/fiddler.png" alt=""></p><p>2、在 <code>fiddler</code>中抓取 <code>https</code> 的流量，需要做如下图配置并安装证书。</p><p><img src="/2018/11/13/HTTP抓包实战/ca.png" alt=""></p><p>像 <code>IE</code>，<code>chrome</code>等浏览器都是使用<code>windows</code>证书库来验证证书，但是<code>firefox</code>浏览器是自己维护一个证书列表，所以需要在<code>firefox</code>中单独安装 <code>fiddler</code>证书。在上图中的<code>action</code>选项中可以下载<code>fiddler</code>的根证书到桌面，<code>firefox &gt;&gt; 工具 &gt;&gt; 选项 &gt;&gt; 隐私与安全 &gt;&gt; 证书 &gt;&gt; 查看证书 &gt;&gt; 证书机构</code>中可以导入证书，这里，<code>fiddler</code>的作者开了个玩笑，证书名叫<code>DO_NOT_TRUST_FiddlerRoot</code>。</p><p>3、在抓包时，我们经常能看到 <code>tunnel to</code>的握手包，这对我们分析数据包没啥作用，可以在<code>fiddler &gt;&gt; rules &gt;&gt; hide connects</code>中设置其隐藏掉。</p><p><img src="/2018/11/13/HTTP抓包实战/tunnelto.png" alt=""></p><p>4、Win+R输入<code>certmgr.msc</code>查看<code>windows</code>证书管理库</p><p><img src="/2018/11/13/HTTP抓包实战/certmgr.png" alt=""></p><p>5、<code>https://www.wangjibao.com.cn/2018/11/13/HTTP%E6%8A%93%E5%8C%85%E5%AE%9E%E6%88%98/#more</code></p><p>上面是个<code>url</code>的例子，<code>https</code>协议，<code>www.wangjibao.com.cn</code>为域名，这里使用的是默认<code>80</code>端口，所以省略端口显示，后面的<code>/2018/11/13/HTTP%E6%8A%93%E5%8C%85%E5%AE%9E%E6%88%98/</code>代表资源的路径，后面的<code>#</code>号代表啥呢，其实这是个 <code>锚点(anchor)</code>，我们知道，当一个页面非常长的时候，我们可以在页面中根据锚点直接定位到我们需要的地方。</p><p>6、HTTP的状态码，200类是成功，300类代表重定向，400类代表客户端错误，500类错误代表服务器错误。</p><p>其中的<code>206(Partial Content)</code>代表的是部分内容，迅雷、HTTP下载工具就是使用<code>206</code>状态码来实现的断点续传。</p><p>当遇到<code>301 或 302</code>的响应时，浏览器会自动根据<code>response</code>中的重定向<code>url</code>重新访问资源地址。如下图（京东之前叫<code>360buy</code>)：</p><p><img src="/2018/11/13/HTTP抓包实战/location.png" alt=""></p><p>先访问<code>www.360buy.com</code>返回<code>301</code>说这个网址已经<code>move permanently</code>了，给了个<code>http://www.jd.com</code>，然后，浏览器就是访问这个网址，但是服务器说<code>302</code>，代表说，这次对了，但是为了安全，去访问另一个网址吧<code>https://www.jd.com</code>吧，接着就会发现，129号中显示了<code>tunnel to</code>，代表开始握手协商了。</p><p>其实，这里<code>301或302</code>还是有区别的，<code>301</code>代表旧<code>url</code>已经永久移除了，搜索引擎会把权重计算到新的<code>url</code>上。但<code>302</code>代表旧<code>url</code>还在，只是临时重定向到新<code>url</code>上，搜索引擎会把权重计算到旧<code>url</code>上。</p><p>7、常用的HTTP请求方法就是 <code>get</code>和<code>post</code>。</p><p><img src="/2018/11/13/HTTP抓包实战/post.png" alt=""></p><p>我们登录国科大的选课网站，在 <code>fildder</code>中，可以清楚的看到，用户名和密码被包含在<code>post</code>请求的<code>body</code>中，发送给了服务器。同样，如果是<code>get</code>请求，包含在<code>url</code>中<code>?</code>后面的字段可以在<code>QueryString</code>中看到对应的<code>Name--Value</code>字段。</p><p>8、可以在<code>fiddler &gt;&gt; tools &gt;&gt; user-agent</code>中修改<code>User-Agent</code>字段的值，如下图，再浏览某些网页时，就变成了对应的显示模式。</p><p><img src="/2018/11/13/HTTP抓包实战/user-agent.png" alt=""></p><p>9、Ajax (<strong>A</strong>synchronous  <strong>J</strong>avascript  <strong>A</strong>nd  <strong>X</strong>ML”: 异步 JavaScript 和 XML）,是一种在无需重新加载整个网页的情况下，能够更新部分网页的技术。</p><p>10、在 <code>Rules &gt;&gt; Automatic Breakpoint &gt;&gt; after/before Response</code>中可以设置拦截<code>HTTP</code>请求。比如，我可以设置拦击HTTP的响应，然后在<code>raw</code>中修改页面的<code>title</code>字段，点击<code>Run to Completion</code>发成修改后的发送。</p><p><img src="/2018/11/13/HTTP抓包实战/breakpoint.png" alt=""></p><p>1号包中的红色代表拦截到了，这时别忘了，<strong>之前设置的全局断点给取消掉</strong>，不然会影响其他请求的发送和接收。效果如下图：</p><p><img src="/2018/11/13/HTTP抓包实战/modifyresponse.png" alt=""></p><p>注意：修改操作必须在<code>raw</code>选项框里。当然，也可以设置局部断点，<code>bpu www.baidu.com</code>设置只拦截百度的请求，取消拦截在页面左下角的命令框中输入<code>bpu</code>即可；<code>bpafter www.baidu.com</code>拦截响应，<code>bpafter</code>取消拦截响应。</p><p>11、浏览器中的缓存</p><p>如下图，浏览器想请求某个资源的时候，先检查本地缓存，如果本地缓存存在这个文件的时候，直接获取该文件的最后修改时间等信息，构造数据包发送请求（内含有<code>If-Modified-Since</code>字段和<code>If-None-Match</code>字段）给服务器，服务器根据这两个值，结合自身的<code>Last-Modified</code>字段和<code>Etag</code>字段来判断需不需要发送数据给浏览器，如果不需要（1、Request中的If-Modified-Since的时间大于或等于Resonse中的Last-Modified的时间；2、ETag值和If-None-Match相匹配，说明hash值不变文档没改变），则服务器发送 <code>304 Response</code>给浏览器，告诉它，直接使用缓存就行了，节省时间加快网页加载速度。</p><p><img src="/2018/11/13/HTTP抓包实战/lastmodify.png" alt=""></p><p>当然，我们也可以 <code>ctrl + F5</code>强制刷新浏览器，告诉服务器，我不使用缓存，请发送最新的数据资源给我。</p><p><img src="/2018/11/13/HTTP抓包实战/nocache.png" alt=""></p><p>其中的<code>pragma</code>是HTTP1.0中使用的，<code>Cache-Control</code>是现在HTTP1.1用的，同时存在这两个字段，完全是为了兼容。</p><p>12、<code>URL</code>只能使用英文字母、数字或者某些标点符号，URL Encode(URL 编码)就是把所有非英文字母、数字字符都替换成百分号（%）后加两位十六进制数。如：</p><p><code>https://www.wangjibao.com.cn/2018/11/13/HTTP抓包实战</code> 编码后变成了如下模式，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://www.wangjibao.com.cn/2018/11/13/HTTP%E6%8A%93%E5%8C%85%E5%AE%9E%E6%88%98/</span><br></pre></td></tr></table></figure><p>13、<code>Fiddler</code>提供了丰富的插件，可以在<a href="https://www.telerik.com/fiddler/add-ons中下载安装使用，如`Java" target="_blank" rel="noopener">https://www.telerik.com/fiddler/add-ons中下载安装使用，如`Java</a> Script Formatter<code>、</code>Gallery<code>、</code>WinDiff`（比较两个session的不同）等等。</p><p>14、 <code>Fiddler</code>中可以在线调试 <code>JavaScript</code>文件，使用的是<code>AutoResponder</code>功能，如下图，其原理就是当命中某个文件时，自动替换成我们设置的文件返回给客户端，就不去服务器索取了。</p><p><img src="/2018/11/13/HTTP抓包实战/js.png" alt=""></p><p>当然，不仅可以替换 <code>JS</code> 文件，还可以替换网页中的图片为本地我们设置的图片。</p><p>15、我们还可以直接编辑<code>Fiddler Script</code>来修改HTTP请求或者响应，并且不中断程序（之前介绍的设置断点的方式，会使得程序中断）。<code>Rules &gt;&gt; Coustomize Rules</code>中，打开<code>Fiddler ScriptEditor</code>来编辑<code>CustomRules.js</code>文件，如图：</p><p><img src="/2018/11/13/HTTP抓包实战/scripteditor.png" alt=""></p><p>16、HTTP的<code>Cookie</code>机制</p><p>因为<code>HTTP</code>协议是无状态的，可以通过<code>Cookie</code>来维持会话。登录 <code>http://piaoweb.sstm.org.cn</code>，可以在<code>fiddler</code>中看到<code>cookie</code>的运行机制，如下图：</p><p><img src="/2018/11/13/HTTP抓包实战/cookie.png" alt=""></p><p>浏览器把<code>Cookie</code>通过HTTP请求中的<code>Header</code>发送给服务器，同时，服务器通过HTTP响应中的<code>Header</code>(Set-Cookie机制)把<code>Cookie</code>发送给浏览器。</p><p>上图中的 <code>HttpOnly</code>字段是说通过<code>JavaScript</code>脚本无法读取到<code>Cookie</code>信息，可以有效防止<code>XSS</code>攻击。</p><p>浏览器根据服务器返回的<code>Set-Cookie</code>设置好本地<code>Cookie</code>以后，浏览器每次请求服务器的资源时，就在<code>Header</code>中将<code>Cookie</code>附加上，这样，服务器就认为浏览器是登录状态。</p><p>17、Cookie劫持攻击</p><p>这里我们使用<code>豆瓣</code>网为例，演示一下<code>Cookie</code>劫持攻击。</p><p>（1）登录<a href="https://www.douban.com/" target="_blank" rel="noopener">豆瓣网</a>，用<code>Fiddler</code>抓取登录过程产生的数据包，可以看到一个如下图中的包，里面含有我们需要的<code>cookie</code>。</p><p><img src="/2018/11/13/HTTP抓包实战/doubanaccount.png" alt=""></p><p>（2）我们打开这个会话的<code>session</code>，可以看到用户的<code>cookie</code>，其中的<code>dbcl2</code>是和用户登录相关的。</p><p><img src="/2018/11/13/HTTP抓包实战/accounts.png" alt=""></p><p>（3）我们在该会话上右键，<code>replay &gt;&gt; Reissue and Edit</code>，将cookie中的此字段删除，然后<code>Run to Completion</code>放行，可以看到此时我们现在是非登录状态，并且跳转到了登录界面，服务器返回<code>302</code>。</p><p><img src="/2018/11/13/HTTP抓包实战/relocation.png" alt=""></p><p>（4）现在我们知道，这个<code>cookie</code>字段就是和用户登录相关的，并且已经劫持到了，那么如何利用它呢？可以利用之前提到的<code>Fiddler Script</code>，编写脚本，每次发送数据包的时候，自动加上这个cookie不就行了，并且这个操作不会有任何中断。</p><p>在 <code>Fiddler Script</code>中的<code>OnBeforeRequest</code>函数中添加如下代码段：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(oSession.uriContains(<span class="string">"douban.com"</span>))&#123;</span><br><span class="line"><span class="keyword">var</span> sCookie = <span class="string">"dbcl2=\"170842457:NW8ZWiZHFUU\""</span>;</span><br><span class="line">oSession.oRequest[<span class="string">"Cookie"</span>] = sCookie;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再次访问豆瓣网，发现自己已经处于登录状态了。</p><p>18、<code>HTTP</code>基本验证</p><p>把<code>用户名+冒号+密码</code>用<code>Base64</code>编码后生成字符串，放在<code>header</code>中的<code>Authorization</code>字段中，发送给服务器。</p><p>19、手机<code>Fiddler</code>抓包</p><p>手机和电脑处于同一局域网中，在<code>fiddler &gt;&gt; Tools &gt;&gt; Options &gt;&gt; Connections</code>中将<code>allow remote computers to connect</code>勾选上，同时在手机的<code>wlan</code>设置中，将其代理设置成电脑，<code>IP</code>为电脑IP，端口为<code>8888</code>；同时，在手机的安全设置中可以安装之前下载的<code>fiddler root</code>根证书，这样，就可以捕获到手机的<code>https</code>数据包了。</p><p>20、<code>Replay</code>菜单的详细说明：</p><p><code>Reissue Requests</code>：重新发送请求，和菜单栏上的<code>Replay</code>按钮是一样的功能。</p><p><code>Reissue Unconditionally</code>：无条件反复发送选中的请求。</p><p><code>Reissue and Edit</code>：把选中的请求以原来的形式重新发送，在每个新的<code>Session</code>中设置断点，在请求发送给服务器之前，可以修改请求。</p><p><code>Reissue and Verify</code>：重新发送请求，检查响应，如果响应和上一个请求一样，就会变成绿色。</p><p><code>Reissue Sequentially</code>：选中多个<code>Session</code>会按顺序一个一个重新发送请求，是单线程模式。</p><p><code>Reissue from Composer</code>：在<code>Composer</code>中编辑该请求。</p><p><code>Revisit in IE</code>：在<code>IE</code>浏览器中用<code>Get</code>方法访问这个请求。</p><p>21、重放攻击，在<code>Fiddler</code>中，可以使用<code>Composer</code>编辑数据包并进行发送。</p><p><img src="/2018/11/13/HTTP抓包实战/composer.png" alt=""></p><p>其实，重放攻击危害很大，比如说，某网站的投票或者点赞功能，当我们抓取到某个点赞的包时，我们可以重复发送这个数据包来进行刷票。再比如说，某些软件的注册，当我们抓取到某个注册请求包的时候，我们进行大量重复发送，对<code>app</code>造成的损失还是很大的。</p><p>解决方案：在<code>HTTP</code>请求中，添加时间戳<code>stamp</code>和数字签名<code>sign</code>。数字签名保证有效性，时间戳保证时效性。</p><p>22、后面的3–4个章节是使用<code>JMeter</code>对网站做自动化测试和压力测试的，在此略过。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;开始读《HTTP抓包实战》，在这个作业满天飞的日子里，计划1周读完，本篇博文对其中的部分知识点做一下简单的记录。&lt;/p&gt;
&lt;p&gt;1、HTTP抓包分析使用的工具不再是wireshark（研究TCP/IP协议使用），而是使用 &lt;a href=&quot;https://www.telerik.com/fiddler&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;fiddler&lt;/a&gt;，版本4。其实 fiddler 做HTTP数据包分析的原理就是相当于一个&lt;strong&gt;web代理&lt;/strong&gt;，如下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/2018/11/13/HTTP抓包实战/web_proxy.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;fiddler在中间，可以记录所用的HTTP流量。fiddler启动时，会偷偷把 Internet 选项中的代理修改为 ：127.0.0.1,端口： 8888; fiddler在关闭时，会自动在Internet选项中取消代理，这样就不会对其他程序产生影响。如下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/2018/11/13/HTTP抓包实战/127001.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="笔记" scheme="https://wangjibao.com.cn/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="笔记" scheme="https://wangjibao.com.cn/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>小知识科普</title>
    <link href="https://wangjibao.com.cn/2018/11/12/%E5%B0%8F%E7%9F%A5%E8%AF%86%E7%A7%91%E6%99%AE/"/>
    <id>https://wangjibao.com.cn/2018/11/12/小知识科普/</id>
    <published>2018-11-12T15:52:28.000Z</published>
    <updated>2018-11-12T16:26:51.535Z</updated>
    
    <content type="html"><![CDATA[<p>本篇博文记录一下平时生活中遇到的小知识，不定期更新。</p><h4 id="1、判断USB接口类型"><a href="#1、判断USB接口类型" class="headerlink" title="1、判断USB接口类型"></a>1、判断USB接口类型</h4><p>晚上同学过来借扩展坞，看了眼USB接口的颜色，问，这是2.0的口吗？很明显，本渣渣耗费 199大洋 采购的东东，怎么能不是 3.0 的口呢。其实凭借USB接口的颜色能够一定程度上判断接口类型，但并不一定准确。</p><p>准确的做法是：看<strong>接口的针脚数</strong> ，<code>USB2.0</code> 的针脚数目是 <strong>4</strong> 个，<code>USB3.0</code> 的针脚数目是 <strong>9</strong> 个。如下图：</p><p><img src="/2018/11/12/小知识科普/usb2.png" alt=""></p><p>上图是本渣18年从青大毕业时，学院发的纪念U盘，4个引脚，USB2.0的接口。为啥发U盘呢，18年在青岛开上合峰会的时候正值毕业季，各种大型活动统统不让搞，往年的毕业歌会也被无情的取消，那么办晚会的钱就拿来每人发个U盘吧，反正大家都是搞计算机的，以后也用得到，话说要发好歹也发个3.0口的u盘呗，吐槽一下。不过，当时每个U盘里都拷了毕业纪念视频，还是挺走心的，这个得表扬一波。</p><a id="more"></a><p>多说一句，<strong>信息安全班</strong>里当时毕业没有毕业聚餐你敢相信！？？其实知道现在想起来，还是耿耿于怀，原因大家也都心知肚明，怎么说，无愧于心就好！</p><p><img src="/2018/11/12/小知识科普/usb3.png" alt=""></p><p>上图是<strong>3.0</strong> 的口，<strong>9</strong>个引脚能看清不，外面 <strong>5</strong> 个，里面 <strong>4</strong> 个。想一下，为啥2.0的东西插到3.0的口也能正常使用，是不就是使用的里面那<strong>4</strong>个引脚，外面那<strong>5</strong>个是闲着的，当插入3.0的东西时，这9个引脚会全部起作用。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本篇博文记录一下平时生活中遇到的小知识，不定期更新。&lt;/p&gt;
&lt;h4 id=&quot;1、判断USB接口类型&quot;&gt;&lt;a href=&quot;#1、判断USB接口类型&quot; class=&quot;headerlink&quot; title=&quot;1、判断USB接口类型&quot;&gt;&lt;/a&gt;1、判断USB接口类型&lt;/h4&gt;&lt;p&gt;晚上同学过来借扩展坞，看了眼USB接口的颜色，问，这是2.0的口吗？很明显，本渣渣耗费 199大洋 采购的东东，怎么能不是 3.0 的口呢。其实凭借USB接口的颜色能够一定程度上判断接口类型，但并不一定准确。&lt;/p&gt;
&lt;p&gt;准确的做法是：看&lt;strong&gt;接口的针脚数&lt;/strong&gt; ，&lt;code&gt;USB2.0&lt;/code&gt; 的针脚数目是 &lt;strong&gt;4&lt;/strong&gt; 个，&lt;code&gt;USB3.0&lt;/code&gt; 的针脚数目是 &lt;strong&gt;9&lt;/strong&gt; 个。如下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/2018/11/12/小知识科普/usb2.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;上图是本渣18年从青大毕业时，学院发的纪念U盘，4个引脚，USB2.0的接口。为啥发U盘呢，18年在青岛开上合峰会的时候正值毕业季，各种大型活动统统不让搞，往年的毕业歌会也被无情的取消，那么办晚会的钱就拿来每人发个U盘吧，反正大家都是搞计算机的，以后也用得到，话说要发好歹也发个3.0口的u盘呗，吐槽一下。不过，当时每个U盘里都拷了毕业纪念视频，还是挺走心的，这个得表扬一波。&lt;/p&gt;
    
    </summary>
    
      <category term="笔记" scheme="https://wangjibao.com.cn/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="笔记" scheme="https://wangjibao.com.cn/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
</feed>
