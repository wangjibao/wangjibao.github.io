<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>来呀，不服抓个包~~</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://wangjibao.com.cn/"/>
  <updated>2019-07-05T12:34:48.856Z</updated>
  <id>https://wangjibao.com.cn/</id>
  
  <author>
    <name>大宝哥spring</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>HTTP2协议解析及抓包分析</title>
    <link href="https://wangjibao.com.cn/2019/07/05/HTTP2%E5%8D%8F%E8%AE%AE%E8%A7%A3%E6%9E%90%E5%8F%8A%E6%8A%93%E5%8C%85%E5%88%86%E6%9E%90/"/>
    <id>https://wangjibao.com.cn/2019/07/05/HTTP2协议解析及抓包分析/</id>
    <published>2019-07-05T12:17:27.000Z</published>
    <updated>2019-07-05T12:34:48.856Z</updated>
    
    <content type="html"><![CDATA[<h4 id="一、HTTP2协议简介"><a href="#一、HTTP2协议简介" class="headerlink" title="一、HTTP2协议简介"></a>一、HTTP2协议简介</h4><h5 id="1、HTTP2的帧格式"><a href="#1、HTTP2的帧格式" class="headerlink" title="1、HTTP2的帧格式"></a>1、HTTP2的帧格式</h5><p>HTTP2的所有帧都是由一个固定的<strong>9</strong>字节头部（payload之前）和一个指定长度的负载（payload）组成，如下图所示：</p><p><img src="/2019/07/05/HTTP2协议解析及抓包分析/h2帧格式.jpg" alt=""></p><p>其中，<code>Stream Identifier</code>用作流控制，用31位无符号整数表示。客户端建立的<code>sid</code>必须为奇数，服务端建立的<code>sid</code>必须为偶数，<strong>值（0x0）保留给与整个连接相关联的帧（连接控制消息），而不是单个流。</strong></p><p><code>Frame Payload</code>是主体内容，有帧类型决定，HTTP2一共有<strong>10</strong>种类型的帧：</p><a id="more"></a><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">   名称           描述         type值</span><br><span class="line"> HEADERS        报头帧          0x1</span><br><span class="line">   DATA         数据帧          0x0</span><br><span class="line"> PRIORITY       优先级帧        0x2</span><br><span class="line">RST_STREAM      流终止帧        0x3</span><br><span class="line"> SETTINGS       设置帧          0x4</span><br><span class="line">PUSH_PROMISE    推送帧          0x5</span><br><span class="line">   PING         PING帧         0x6</span><br><span class="line">  GOAWAY        GOAWAY帧       0x7</span><br><span class="line">WINDOW_UPDATE   窗口更新帧       0x8</span><br><span class="line">CONTINUATION    延续帧          0x9</span><br></pre></td></tr></table></figure><p>实际上，HTTP2并没有改变HTTP1.x的语义，只是把原来HTTP1.x的<code>Header</code>和<code>Body</code>部分用<code>Frame</code>重新封装了一层而已。调试的时候浏览器设置会把<code>HTTP2</code>的<code>Frame</code>自动还原成<code>HTTP1.x</code>的格式。两者的帧格式对比如下图：</p><p><img src="/2019/07/05/HTTP2协议解析及抓包分析/h1_vs_h2.png" alt=""></p><h5 id="2、HTTP2的改进及优点"><a href="#2、HTTP2的改进及优点" class="headerlink" title="2、HTTP2的改进及优点"></a>2、HTTP2的改进及优点</h5><ul><li><p>二进制分帧</p><p>帧是客户端和服务端之间通信的最小单位，比起<code>HTTP1.x</code>这样的文本协议，二进制协议解析起来更高效，且没有冗余字段（HTTP1.x 协议每个包都会有重复传输的头部字段），占用带宽少。</p></li><li><p>多路复用</p><blockquote><p>可以并行交错地发送请求，请求之间互不影响；</p><p>可以并行交错地发送响应，响应之间互不干扰；</p><p>只使用一个连接即可并行发送多个请求和响应；</p><p>消除不必要的延迟，从而减少页面加载的时间；</p></blockquote></li></ul><p>增加了<strong>请求优先级</strong>字段，服务器可以根据流的优先级，控制资源分配，而在响应数据准备好之后，将优先级最高的帧发送给客户端。</p><p>增加了<strong>Header压缩</strong>，通信双方各自 <code>cache</code> 一份 <code>header fields</code>表。</p><p>增加了<strong>服务器推送</strong>，服务器可以对一个客户端请求发送多个响应，服务器向客户端推送资源无需客户端明确地请求。服务器推送通过<code>PUSH</code>那些它认为客户端将会需要的内容到客户端的缓存中，避免往返的延迟。比如，请求<code>index.html</code>，但服务器会把<code>style.css, example.png</code>等资源也发送给浏览器。</p><p><strong>流量控制</strong>，每个<code>HTTP2</code>的流都拥有自己公示的流量窗口，它可以限制另一端发送数据。</p><p><img src="/2019/07/05/HTTP2协议解析及抓包分析/h2.png" alt=""></p><h4 id="二、配置Wireshark抓取HTTP2数据包"><a href="#二、配置Wireshark抓取HTTP2数据包" class="headerlink" title="二、配置Wireshark抓取HTTP2数据包"></a>二、配置Wireshark抓取HTTP2数据包</h4><p>1、在电脑里创建一个后缀名为 <code>.log</code> 的文件，记住其路径。</p><p>2、在电脑的系统变量里创建一个新的变量，名为<code>SSLKEYLOGFILE</code>。配置了此变量后，浏览器会到这里来记录通信过程中密钥。</p><p><img src="/2019/07/05/HTTP2协议解析及抓包分析/h2_4.png" alt=""></p><p>3、在<code>wireshark</code>中，<code>分析 &gt;&gt; 已解析的协议...</code>中，启用<code>HTTP2</code>的解析。并在 <code>编辑 &gt;&gt; 首选项 &gt;&gt; Protocols &gt;&gt; TLS</code> 中，配置 <code>(Pre)-Master-Secret</code> 为之前创建的<code>log</code>文件，之后，<code>wireshark</code>就可以凭借此文件中的秘钥解密<code>HTTP2</code>中的各个加密字段，便于我们进行协议分析。</p><p><img src="/2019/07/05/HTTP2协议解析及抓包分析/h2_2.png" alt=""></p><h4 id="三、HTTP2协议数据包解析"><a href="#三、HTTP2协议数据包解析" class="headerlink" title="三、HTTP2协议数据包解析"></a>三、HTTP2协议数据包解析</h4><p>数据包<a href="/download/h2.rar">点击下载</a></p><p><img src="/2019/07/05/HTTP2协议解析及抓包分析/h2_3.png" alt=""></p><p>1、从上图可以看到，<code>HTTP2</code>协议的工作流程为：建立<code>TCP</code>连接、建立<code>TLS</code>连接、<code>HTTP2</code>通信，断开<code>TCP</code>连接 四个过程。在<code>Client Hello</code>中，客户端再扩展字段中会说明其所支持的协议，指定<code>ALPN Next Protocol</code> 为 <code>h2</code> 或 <code>HTTP/1.1</code>。之后，服务端在<code>Server Hello</code>中，回复所协商的接下来使用的应用层协议。如下图：</p><p><img src="/2019/07/05/HTTP2协议解析及抓包分析/h2_5.png" alt=""></p><p>2、在<code>TLS</code>连接过程中，如果服务器支持<code>session ticket</code>，则发送<code>New Session Ticket</code>类型的握手报文，其中包含了能够恢复包括主密钥在内的会话信息。为了不让中间人可见，这个<code>session ticket</code>部分会进行编码、加密等操作，同时，还会指定此<code>ticket</code>的过期时间等。</p><p><img src="/2019/07/05/HTTP2协议解析及抓包分析/h2_6.png" alt=""></p><p>3、从第一幅图中可以看出，在客户端发送<code>Finished</code>消息（#11）之后，就开始将<code>HTTP</code>封装到<code>Application Data</code>协议中发送给服务器（#12，#13，#14，#15，#16）了，此时，<code>TLS</code>握手还没有完全完成。</p><p><code>HTTP2</code>中基本的协议单位是帧，每个帧都有不同的类型和用途。例如，报头<code>(HEADERS)</code>和数据<code>(DATA)</code>帧组成了基本的<code>HTTP</code>请求和响应；其他帧如设置<code>(SETTINGS)</code>，窗口更新<code>(WINDOW_UPDATE)</code>和推送承诺<code>(PUSH_PROMISE)</code>是用来实现<code>HTTP2</code>的其他功能。</p><p>4、<strong>（#12）</strong>帧分析：在<code>HTTP2</code>请求创建连接发送<code>SETTINGS</code>帧初始化之前有一个<code>Magic</code>帧，为建立<code>HTTP2</code>请求的前言<code>(connection preface)</code>，此前言作为对所使用协议的最终确认，并确定<code>HTTP2</code>连接的初始设置。在发送完前言后，双方都得向对方发送带有<code>ACK</code>标识的<code>SETTINGS</code>帧标识确认，对应图中的<strong>#21</strong> 和 <strong>#22</strong> 号帧：</p><p><img src="/2019/07/05/HTTP2协议解析及抓包分析/h2_7.png" alt=""></p><p>12号帧，组合了<code>Magic</code>、<code>SETTINGS</code>和<code>WINDOW_UPDATE</code>三种帧为一个数据包，其中包含的参数如下图：</p><p><img src="/2019/07/05/HTTP2协议解析及抓包分析/h2_8.png" alt=""></p><p><code>WINDOW_UPDATE</code>中的<code>stream identifier</code>为<code>0</code>表示此窗口更新帧作用于整个连接，指定其他具体值可使其作用于某个特定的单独连接。</p><p>5、<strong>（#13）</strong>号帧分析，客户端在发送完连接前言后，可立即跟上一个请求<code>(request)</code>。这里客户端向服务器发送<code>GET /HEADERS</code>，<code>HEADERS</code>帧用来打开一个流或携带一个首部块片段，此<code>HEADERS</code>帧包括了请求行和请求头的内容，属于<code>1</code> 号流：</p><p><img src="/2019/07/05/HTTP2协议解析及抓包分析/h2_9.png" alt=""></p><p>其中，<code>Exclusive</code>：一个比特位声明流的依赖性是否是排它的，这里为 <code>1</code>，代表此流不依赖其他的流。<code>Weight</code>：代表当前流的优先级权重。<code>End Headers</code>：这里为 <code>1</code> 代表<code>header</code>块结束。<code>Priority</code>设置为 <code>1</code>，代表存在<code>Exclusive</code>、<code>Stream Dependency</code> 和 <code>Weight</code>。</p><p>6、<strong>(#19)</strong> 号包分析，服务器向客户端发送<code>SETTINGS</code> 和 <code>WINDOW_UPDATE</code> 帧，<code>SETTINGS</code>帧为连接前言 <code>(connection preface)</code>，帧中设置了最大并行流数量、初始窗口大小、最大帧长度，<code>WINDOW_UPDATE</code> 给出扩大窗口的大小。这两个帧属于 <code>0</code> 号流。</p><p><img src="/2019/07/05/HTTP2协议解析及抓包分析/h2_10.png" alt=""></p><p>7、<code>DATA</code> 帧，服务器向客户端发送<code>DATA</code>帧，即响应主体。<code>DATA</code> 帧用来装填主体信息，可以用一个或多个<code>DATA</code> 帧来返回一个请求的响应主体。</p><p><img src="/2019/07/05/HTTP2协议解析及抓包分析/h2_11.png" alt=""></p><p>上图左边为<code>HEADERS</code>帧，服务器向客户端返回响应<code>(response)</code>，此报头帧包含了状态行和响应头的内容，此帧属于 <code>3</code> 号流。 <code>Status: 200 OK</code> 表示状态码为 200，客户端请求成功。此外，响应头还给出了服务器所使用的的服务器型号、内容类型等。注意观察图中的标志位 <code>End Stream</code> 和 <code>End Headers</code> 的变化。</p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;一、HTTP2协议简介&quot;&gt;&lt;a href=&quot;#一、HTTP2协议简介&quot; class=&quot;headerlink&quot; title=&quot;一、HTTP2协议简介&quot;&gt;&lt;/a&gt;一、HTTP2协议简介&lt;/h4&gt;&lt;h5 id=&quot;1、HTTP2的帧格式&quot;&gt;&lt;a href=&quot;#1、HTTP2的帧格式&quot; class=&quot;headerlink&quot; title=&quot;1、HTTP2的帧格式&quot;&gt;&lt;/a&gt;1、HTTP2的帧格式&lt;/h5&gt;&lt;p&gt;HTTP2的所有帧都是由一个固定的&lt;strong&gt;9&lt;/strong&gt;字节头部（payload之前）和一个指定长度的负载（payload）组成，如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/2019/07/05/HTTP2协议解析及抓包分析/h2帧格式.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;其中，&lt;code&gt;Stream Identifier&lt;/code&gt;用作流控制，用31位无符号整数表示。客户端建立的&lt;code&gt;sid&lt;/code&gt;必须为奇数，服务端建立的&lt;code&gt;sid&lt;/code&gt;必须为偶数，&lt;strong&gt;值（0x0）保留给与整个连接相关联的帧（连接控制消息），而不是单个流。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Frame Payload&lt;/code&gt;是主体内容，有帧类型决定，HTTP2一共有&lt;strong&gt;10&lt;/strong&gt;种类型的帧：&lt;/p&gt;
    
    </summary>
    
      <category term="笔记" scheme="https://wangjibao.com.cn/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="笔记" scheme="https://wangjibao.com.cn/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>IPSec VPN搭建及协议解析</title>
    <link href="https://wangjibao.com.cn/2019/07/02/IPSec-VPN%E6%90%AD%E5%BB%BA%E5%8F%8A%E5%8D%8F%E8%AE%AE%E8%A7%A3%E6%9E%90/"/>
    <id>https://wangjibao.com.cn/2019/07/02/IPSec-VPN搭建及协议解析/</id>
    <published>2019-07-02T14:08:50.000Z</published>
    <updated>2019-07-03T01:42:36.710Z</updated>
    
    <content type="html"><![CDATA[<h4 id="一、IPSec协议简介"><a href="#一、IPSec协议简介" class="headerlink" title="一、IPSec协议简介"></a>一、IPSec协议简介</h4><p><code>IPSec</code>是<code>IETF</code>制定的为保证在<code>Internet</code>上传送数据的安全保密性能的三层隧道加密协议。<code>IPSec</code>是应用于<code>IP</code>层上网络数据安全的一整套体系结构，他包括<strong>报文首部认证协议</strong><code>（ Authentication Header, AH）</code>、<strong>封装安全载荷协议</strong><code>(Encapsulating Security Payload, ESP)</code>、<strong>互联网间密钥交换协议</strong><code>(Internet Key Exchange, IKE)</code> 和一些用于网络认证及加密的算法等。<code>IPSec</code>协议本身定义了如何在<code>IP</code>数据包中增加字段来保证<code>IP</code>包的完整性、私有性和真实性，以及如何加密数据包。</p><p><code>IPSec</code>有传输<code>(transport)</code>和隧道<code>(tunnel)</code>两种工作方式，其中，传输模式适用于主机之间建立<code>IPSec</code>安全传输，隧道模式更适合网关之间的通信，常用来实现虚拟专用网<code>VPN</code>。</p><h4 id="二、IPSec-VPN搭建"><a href="#二、IPSec-VPN搭建" class="headerlink" title="二、IPSec-VPN搭建"></a>二、IPSec-VPN搭建</h4><p>详细教程请参考：<a href="https://github.com/hwdsl2/setup-ipsec-vpn/blob/master/README-zh.md" target="_blank" rel="noopener">https://github.com/hwdsl2/setup-ipsec-vpn/blob/master/README-zh.md</a></p><p>以 <code>Ubuntu 16.04</code>为例，首先执行：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget https://git.io/vpnsetup -O vpnsetup.sh</span><br></pre></td></tr></table></figure><p>之后，在<code>vpnsetup.sh</code>文件中，设置<code>YOUR_IPSEC_PSK, YOUR_USERNAME 和 YOUR_PASSWORD</code>三个字段，如下图：</p><p><img src="/2019/07/02/IPSec-VPN搭建及协议解析/vpnsetup.png" alt=""></p><a id="more"></a><p>最后，通过命令 <code>sudo sh vpnsetup.sh</code> 启动服务器的 <code>ipsec vpn</code>服务。接下来，就是客户端的配置，以安卓手机为例：</p><p><img src="/2019/07/02/IPSec-VPN搭建及协议解析/ipsec1.png" alt=""></p><p>选择对应的 <code>VPN</code> 添加类型，其中<code>IPSec Xauth</code> 类型也称 <code>Cisco IPsec</code> 模式，更加高效一些。填写好服务器地址、预共享密钥<code>(PSK)</code> 、用户名和密码后，即可使用该 <code>VPN</code>，如果服务器在香港或国外的话，即可实现<code>翻墙</code>的功能。</p><h4 id="三、IPSec协议解析"><a href="#三、IPSec协议解析" class="headerlink" title="三、IPSec协议解析"></a>三、<code>IPSec</code>协议解析</h4><p><code>IPSec</code>主要包括两部分协议，分别是 <code>ISAKMP</code> 协议和 <code>ESP</code>协议，可使用<code>wireshark</code>采集以上两种协议的报文。</p><p><strong>(1) <code>ISAKMP</code>协议</strong></p><blockquote><p>第一阶段，通信双方彼此间建立一个已通过身份认证和安全保护的通道，即建立一个<code>ISAKMP SA</code>。第一阶段有主模式<code>（Main Mode）</code>和野蛮模式<code>（Aggressive Mode）</code>两种<code>IKE</code>交换方法。        </p><p> 第二阶段，使用在第一阶段建立的安全隧道为<code>IPsec</code>协商安全服务，即为<code>IPsec</code>协商具体的<code>SA</code>，建立用于最终的<code>IP</code>数据安全传输的<code>IPsec SA</code>。</p></blockquote><p><strong>第一阶段</strong>的<strong>主模式</strong>交换过程：</p><p><img src="/2019/07/02/IPSec-VPN搭建及协议解析/isakmp.png" alt=""></p><p>对应的数据包为<a href="/download/isakmp.pcap">点我下载</a>：</p><p><img src="/2019/07/02/IPSec-VPN搭建及协议解析/isakmp_1.png" alt=""></p><ul><li>消息①和②用于策略交换（包为明文）</li></ul><blockquote><p>发起方发送一个或多个<code>IKE</code>安全提议，响应方查找最先匹配的<code>IKE</code>安全提议，并将这个<code>IKE</code>安全提议回应给发起方。匹配的原则为协商双方具有相同的加密算法、认证算法、认证方法和<code>Diffie-Hellman</code>组标识。</p></blockquote><ul><li>消息③和④用于密钥信息交换（包为明文）</li></ul><blockquote><p>双方交换<code>Diffie-Hellman</code>公共值和<code>nonce</code>值，用于<code>IKE SA</code>的认证和加密密钥在这个阶段产生。</p></blockquote><ul><li>消息⑤和⑥用于身份和认证信息交换（包为密文）</li></ul><blockquote><p>双方使用生成的密钥发送信息，双方进行身份认证和对整个主模式交换内容的认证。</p></blockquote><p><strong>第二阶段</strong>的<code>IPSEC SA</code>协商:</p><p>上图中的 8、9、10 号包使用快速模式，进行<code>IPSec SA</code>的协商。</p><p>最后的 <code>11、12、13、14</code>号数据包为断开连接。</p><p><strong>(2) <code>ESP</code>协议</strong></p><p><img src="/2019/07/02/IPSec-VPN搭建及协议解析/esp.png" alt=""></p><p>因为 <code>IPSec</code>协议要求通信双方建立单工的安全联盟，所以两个<code>SPI</code> 分别标识了两个方向的通信报文。</p><h4 id="四、IPSec穿越NAT"><a href="#四、IPSec穿越NAT" class="headerlink" title="四、IPSec穿越NAT"></a>四、IPSec穿越NAT</h4><p><strong><code>IPSec VPN</code>中标准身份标识是<code>IP</code>地址，<code>NAT</code>处理过程中会改变<code>IP</code>地址，因此<code>IPSec</code>的身份确认机制必须能够适应<code>IP</code>地址变化。</strong><code>IPSec</code>的身份确认最常见是通过<code>IKE</code>协议代劳，<code>IKE</code>支持的身份认证机制有两种:</p><ul><li><p>数字证书方式，通过CA数字证书体系确认身份，是最为安全、可靠的方式。</p></li><li><p>身份标识+预共享密钥方式，通过发起方和响应方预先配置相同的密钥，完成双方对彼此身份的认证，这是最为常见的方式。在预共享秘密钥认证机制中，身份标识则可以分为几类：</p><ul><li><p>指定<code>IP</code>地址，使用<code>IP</code>地址作为身份标识，是<code>IKE</code>的默认方式，响应方只允许指定<code>IP</code>地址发起协商，安全性比较高。</p></li><li><p>指定<code>IP</code>地址范围，这种方式依然使用<code>IP</code>地址作为身份标识，由于发起方必须要指定<code>IP</code>地址，否则无法发起协商，指定<code>IP</code>地址范围是响应方特性，如响应方可以指定<code>2.0.0.0/8</code>范围内的地址都可以发起协商，而不是只允许<code>2.1.1.2</code>发起协商，能够减少配置，但安全性略有下降。</p></li><li><p>什么都不指定，也是使用IP地址作为身份标识，但允许任意IP地址发起协商，只要预共享密钥一致，双方就能够通过身份确认，这种方式虽然不是非常安全，但是可以简化配置，安全性再次下降；</p></li><li><p>指定对端名字，发起方和响应方都预先配置好本端名字，使用该名字作为身份标识，与指定<code>IP</code>地址类似，通过指定对端名字方式，即使双方预共享密钥一致，只要对端名字不合法，立即中断协商，由于名字未与<code>IP</code>地址进行绑定，而且名字在网络中明文传递，故安全性不如指定<code>IP</code>地址方式高，但这种身份标识方式可以穿<code>NAT</code>。</p></li></ul></li></ul><p>具体过程如下：</p><p> 1、开启<code>NAT</code>穿越时，协商第一阶段的前两个消息会发送标识<code>NAT</code>穿越（<code>NAT Traversal</code>，简称<code>NAT-T</code>）能力的<code>Vendor ID</code>载荷。用于检查通信双方是否支持<code>NAT-T</code>。</p><p><img src="/2019/07/02/IPSec-VPN搭建及协议解析/nat1.png" alt=""></p><p>当双方都在各自的消息中包含了该载荷时，才会进行相关的<code>NAT-T</code>协商。</p><p>2、主模式消息3和消息4中发送<code>NAT-D（NAT Discovery）</code>载荷。<code>NAT-D</code>载荷用于探测两个要建立<code>IPSec</code>隧道的网关之间是否存在<code>NAT</code>网关以及<code>NAT</code>网关的位置。</p><p><img src="/2019/07/02/IPSec-VPN搭建及协议解析/nat2.png" alt=""></p><p>通过协商双方向对端发送源和目的的<code>IP</code>地址与端口的<code>Hash</code>值，就可以检测到地址和端口在传输过程中是否发生变化。若果协商双方计算出来的<code>Hash</code>值与它收到的<code>Hash</code>值一样，则表示它们之间没有<code>NAT</code>。否则，则说明传输过程中对<code>IP</code>或端口进行了<code>NAT</code>转换。</p><p>第一个<code>NAT-D</code>载荷为对端<code>IP</code>和端口的<code>Hash</code>值，第二个<code>NAT-D载</code>荷为本端<code>IP</code>和端口的<code>Hash</code>值。</p><p>3、发现<code>NAT</code>网关后，后续<code>ISAKMP</code>消息的端口号转换为<strong>4500</strong>。<code>ISAKMP</code>报文标识了<code>“Non-ESP Marker”</code>。</p><p><img src="/2019/07/02/IPSec-VPN搭建及协议解析/nat3.png" alt=""></p><p>4、在第二阶段会启用<code>NAT</code>穿越协商。在<code>IKE</code>中增加了两种<code>IPSec</code>报文封装模式：<code>UDP</code>封装隧道模式报文（<code>UDP-Encapsulated-Tunnel</code>）和<code>UDP</code>封装传输模式报文（<code>UDP-Encapsulated-Transport</code>）。<strong>通过为<code>ESP</code>报文封装<code>UDP</code>头</strong>，当封装后的报文通过<code>NAT</code>设备时，<code>NAT</code>设备对该报文的外层<code>IP</code>头和增加的<code>UDP</code>头进行地址和端口号转换。<code>UDP</code>报文端口号修改为<code>4500</code>。</p><p><img src="/2019/07/02/IPSec-VPN搭建及协议解析/nat4.png" alt=""></p><h4 id="五、IPSec协议流量特征分析"><a href="#五、IPSec协议流量特征分析" class="headerlink" title="五、IPSec协议流量特征分析"></a>五、<code>IPSec</code>协议流量特征分析</h4><p><img src="/2019/07/02/IPSec-VPN搭建及协议解析/feature.jpg" alt=""></p><p>在上图 4.14 (a) 中，<code>IPSec</code>流量与原始流量几乎完全重合，这符合<code>ESP</code>协议的特性，即一一对应，一条<code>ESP</code>报文封装一条原始报文，然后进行转发。折线的重合说明<code>IPSec</code>不会对原始流量进行分片等操作，且自身不会产生大量与传输内容无关的流量，它在得到一条原始报文后，仅对其进行加密并加上<code>IPSec</code>头部，然后忠实地发送到目的地。</p><p>在上图 4.14 (b) 中，<code>IPSec</code>流量与原始流量基本重合，但是<code>IPSec</code>流量的字节数到达速率在每个峰值处均比原始流量高。这说明<code>IPSec</code>每条报文的大小都要大于原始报文，这符合<code>IPSec</code>协议的封装特征。加密与完整性保护会产生额外的数据开销，同时无论在隧道模式还是传输模式下，<code>IPSec</code>协议都会对报文进行重新封装，再加上额外的头部，使得讲<code>IPSec</code>处理后的报文数据量大于原始报文。</p><p>在上图 4.15 (a) 中，不论是<code>IPSec</code>流量还是原始流量，其报文大小分布都是<code>U</code>形，即报文大小多集中在<code>0--200</code>字节与<code>1400--1500</code>字节之间，尤其是<code>1400--1500</code>的部分，而<code>200--1400</code>字节的报文数量明显较少。<code>U</code>形分布原因有以下几点：1、有大量数据正在传输；2、网络状况理想，<code>TCP</code>链路极少堵塞，可以持续以较大的发送窗口传输数据；3、左边部分为大量的<code>ACK</code>报文与相关协议的控制报文，以及数据量较小的报文。然后再对比<code>IPSec</code>流量与原始流量，可以观察到其报文大小分布模式及其相似，原始流量相较<code>IPSec</code>流量整体左偏，说明原始流量的报文教<code>IPSec</code>流量较小，这和折线图的结论一致。</p><p>在上图 4.15 (b) 中，可以看到横坐标的报文到达时间间隔范围较大。这与流量采集的方法与环境相关，偶发性的网络阻塞，可能瞬间将报文到达时间间隔提升到千毫秒级。当然，还有很多原因会导致报文到达时间间隔发生异常，因此，报文到达时间间隔时间是一种很不稳定的特征。从图中还可以看到，大部分的到达间隔时间极小，且<code>IPSec</code>流量和原始流量的到达间隔时间分布及其相似。</p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;一、IPSec协议简介&quot;&gt;&lt;a href=&quot;#一、IPSec协议简介&quot; class=&quot;headerlink&quot; title=&quot;一、IPSec协议简介&quot;&gt;&lt;/a&gt;一、IPSec协议简介&lt;/h4&gt;&lt;p&gt;&lt;code&gt;IPSec&lt;/code&gt;是&lt;code&gt;IETF&lt;/code&gt;制定的为保证在&lt;code&gt;Internet&lt;/code&gt;上传送数据的安全保密性能的三层隧道加密协议。&lt;code&gt;IPSec&lt;/code&gt;是应用于&lt;code&gt;IP&lt;/code&gt;层上网络数据安全的一整套体系结构，他包括&lt;strong&gt;报文首部认证协议&lt;/strong&gt;&lt;code&gt;（ Authentication Header, AH）&lt;/code&gt;、&lt;strong&gt;封装安全载荷协议&lt;/strong&gt;&lt;code&gt;(Encapsulating Security Payload, ESP)&lt;/code&gt;、&lt;strong&gt;互联网间密钥交换协议&lt;/strong&gt;&lt;code&gt;(Internet Key Exchange, IKE)&lt;/code&gt; 和一些用于网络认证及加密的算法等。&lt;code&gt;IPSec&lt;/code&gt;协议本身定义了如何在&lt;code&gt;IP&lt;/code&gt;数据包中增加字段来保证&lt;code&gt;IP&lt;/code&gt;包的完整性、私有性和真实性，以及如何加密数据包。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;IPSec&lt;/code&gt;有传输&lt;code&gt;(transport)&lt;/code&gt;和隧道&lt;code&gt;(tunnel)&lt;/code&gt;两种工作方式，其中，传输模式适用于主机之间建立&lt;code&gt;IPSec&lt;/code&gt;安全传输，隧道模式更适合网关之间的通信，常用来实现虚拟专用网&lt;code&gt;VPN&lt;/code&gt;。&lt;/p&gt;
&lt;h4 id=&quot;二、IPSec-VPN搭建&quot;&gt;&lt;a href=&quot;#二、IPSec-VPN搭建&quot; class=&quot;headerlink&quot; title=&quot;二、IPSec-VPN搭建&quot;&gt;&lt;/a&gt;二、IPSec-VPN搭建&lt;/h4&gt;&lt;p&gt;详细教程请参考：&lt;a href=&quot;https://github.com/hwdsl2/setup-ipsec-vpn/blob/master/README-zh.md&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/hwdsl2/setup-ipsec-vpn/blob/master/README-zh.md&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;以 &lt;code&gt;Ubuntu 16.04&lt;/code&gt;为例，首先执行：&lt;/p&gt;
&lt;figure class=&quot;highlight shell&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;wget https://git.io/vpnsetup -O vpnsetup.sh&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;之后，在&lt;code&gt;vpnsetup.sh&lt;/code&gt;文件中，设置&lt;code&gt;YOUR_IPSEC_PSK, YOUR_USERNAME 和 YOUR_PASSWORD&lt;/code&gt;三个字段，如下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/2019/07/02/IPSec-VPN搭建及协议解析/vpnsetup.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="笔记" scheme="https://wangjibao.com.cn/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="笔记" scheme="https://wangjibao.com.cn/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode41-50</title>
    <link href="https://wangjibao.com.cn/2019/05/09/LeetCode41-50/"/>
    <id>https://wangjibao.com.cn/2019/05/09/LeetCode41-50/</id>
    <published>2019-05-09T06:50:40.000Z</published>
    <updated>2019-05-09T17:05:50.250Z</updated>
    
    <content type="html"><![CDATA[<h2 id="41、缺失的第一个正数"><a href="#41、缺失的第一个正数" class="headerlink" title="41、缺失的第一个正数"></a>41、<a href="https://leetcode-cn.com/problems/first-missing-positive" target="_blank" rel="noopener">缺失的第一个正数</a></h2><p>数组中元素互换，让元素大小与下标相对应。数值小于0或者大于数组长度的元素值，直接略过，之后遍历整个数组，第一次出现数值和下标不相等的位置就是<code>ans</code>，如果全部满足，返回数组长度即可。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">firstMissingPositive</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        nums.push_back(<span class="number">-1</span>);  <span class="comment">// 添加一个无用元素，方便后续操作</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;nums.size(); i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>( nums[i]&lt;<span class="number">0</span> || nums[i]&gt;=nums.size() || nums[nums[i]]==nums[i] )</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            swap(nums[nums[i]], nums[i]);</span><br><span class="line">            i--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;nums.size(); i++)&#123; <span class="comment">// i 从 1 开始，保证正整数</span></span><br><span class="line">            <span class="keyword">if</span>( nums[i]!=i )</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums.size();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="42、接雨水"><a href="#42、接雨水" class="headerlink" title="42、接雨水"></a>42、<a href="https://leetcode-cn.com/problems/trapping-rain-water" target="_blank" rel="noopener">接雨水</a></h2><p>先找到全局最高的那个柱子，然后从两边往最高柱靠近，靠近过程中不断更新当前最高柱，并根据当前最高柱的值来计算当前遍历点能够接雨水的量。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">trap</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; height)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(height.size()==<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> max_index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;height.size(); i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>( height[max_index]&lt;height[i] )</span><br><span class="line">                max_index = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> cur_max = height[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;max_index; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>( height[i]&gt;=cur_max )&#123;</span><br><span class="line">                cur_max = height[i];</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            ans += cur_max - height[i];</span><br><span class="line">        &#125;</span><br><span class="line">        cur_max = height[height.size()<span class="number">-1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=height.size()<span class="number">-2</span>; i&gt;max_index; i--)&#123;</span><br><span class="line">            <span class="keyword">if</span>( height[i]&gt;=cur_max )&#123;</span><br><span class="line">                cur_max = height[i];</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            ans += cur_max - height[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="43、字符串相乘"><a href="#43、字符串相乘" class="headerlink" title="43、字符串相乘"></a>43、<a href="https://leetcode-cn.com/problems/multiply-strings" target="_blank" rel="noopener">字符串相乘</a></h2><p>模拟题，使用字符串模拟乘法运算即可。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">multiply</span><span class="params">(<span class="built_in">string</span> num1, <span class="built_in">string</span> num2)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">string</span> ans, cur_multi;</span><br><span class="line">        <span class="keyword">int</span> multiplier, product_step;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=num2.size()<span class="number">-1</span>; i&gt;=<span class="number">0</span>; i--)&#123;</span><br><span class="line">            cur_multi = num1;</span><br><span class="line">            multiplier = num2[i] - <span class="string">'0'</span>;</span><br><span class="line">            product_step = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=cur_multi.size()<span class="number">-1</span>; j&gt;=<span class="number">0</span>; j--)&#123;</span><br><span class="line">                product_step += (cur_multi[j]-<span class="string">'0'</span>)*multiplier;</span><br><span class="line">                cur_multi[j] = product_step%<span class="number">10</span> + <span class="string">'0'</span>;</span><br><span class="line">                product_step /= <span class="number">10</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(product_step)</span><br><span class="line">                cur_multi.insert(cur_multi.begin(), product_step+<span class="string">'0'</span>);</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;num2.size()<span class="number">-1</span>-i; j++)</span><br><span class="line">                cur_multi += <span class="string">"0"</span>;</span><br><span class="line">            <span class="comment">// 计算 cur_multi + ans</span></span><br><span class="line">            <span class="keyword">int</span> m=<span class="number">0</span>, n=<span class="number">0</span>, sum=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(m=ans.size()<span class="number">-1</span>, n=cur_multi.size()<span class="number">-1</span>; m&gt;=<span class="number">0</span>&amp;&amp;n&gt;=<span class="number">0</span>; m--,n--)&#123;</span><br><span class="line">                sum += (ans[m]-<span class="string">'0'</span>) + (cur_multi[n]-<span class="string">'0'</span>);</span><br><span class="line">                ans[m] = sum%<span class="number">10</span> + <span class="string">'0'</span>;</span><br><span class="line">                sum /= <span class="number">10</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span>(m&gt;=<span class="number">0</span>)&#123;</span><br><span class="line">                sum += (ans[m]-<span class="string">'0'</span>);</span><br><span class="line">                ans[m] = sum%<span class="number">10</span> + <span class="string">'0'</span>;</span><br><span class="line">                sum /= <span class="number">10</span>;</span><br><span class="line">                m--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span>(n&gt;=<span class="number">0</span>)&#123;</span><br><span class="line">                sum += (cur_multi[n]-<span class="string">'0'</span>);</span><br><span class="line">                ans.insert(ans.begin(), sum%<span class="number">10</span>+<span class="string">'0'</span>);</span><br><span class="line">                sum /= <span class="number">10</span>;</span><br><span class="line">                n--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(sum)</span><br><span class="line">                ans.insert(ans.begin(), sum+<span class="string">'0'</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(ans.size()&gt;<span class="number">0</span> &amp;&amp; ans[<span class="number">0</span>]==<span class="string">'0'</span>)  <span class="comment">//过滤前导 0 </span></span><br><span class="line">            ans.erase(ans.begin());</span><br><span class="line">        <span class="keyword">return</span> ans.size()==<span class="number">0</span>? <span class="string">"0"</span> : ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>## </p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;41、缺失的第一个正数&quot;&gt;&lt;a href=&quot;#41、缺失的第一个正数&quot; class=&quot;headerlink&quot; title=&quot;41、缺失的第一个正数&quot;&gt;&lt;/a&gt;41、&lt;a href=&quot;https://leetcode-cn.com/problems/first-missing-positive&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;缺失的第一个正数&lt;/a&gt;&lt;/h2&gt;&lt;p&gt;数组中元素互换，让元素大小与下标相对应。数值小于0或者大于数组长度的元素值，直接略过，之后遍历整个数组，第一次出现数值和下标不相等的位置就是&lt;code&gt;ans&lt;/code&gt;，如果全部满足，返回数组长度即可。&lt;/p&gt;
&lt;figure class=&quot;highlight c++&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Solution&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt;:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;firstMissingPositive&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;built_in&quot;&gt;vector&lt;/span&gt;&amp;lt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt;&amp;gt;&amp;amp; nums)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        nums.push_back(&lt;span class=&quot;number&quot;&gt;-1&lt;/span&gt;);  &lt;span class=&quot;comment&quot;&gt;// 添加一个无用元素，方便后续操作&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt;(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; i=&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;; i&amp;lt;nums.size(); i++)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;( nums[i]&amp;lt;&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt; || nums[i]&amp;gt;=nums.size() || nums[nums[i]]==nums[i] )&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &lt;span class=&quot;keyword&quot;&gt;continue&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            swap(nums[nums[i]], nums[i]);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            i--;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt;(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; i=&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;; i&amp;lt;nums.size(); i++)&amp;#123; &lt;span class=&quot;comment&quot;&gt;// i 从 1 开始，保证正整数&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;( nums[i]!=i )&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; i;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; nums.size();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="LeetCode" scheme="https://wangjibao.com.cn/categories/LeetCode/"/>
    
      <category term="LeetCode41-50" scheme="https://wangjibao.com.cn/categories/LeetCode/LeetCode41-50/"/>
    
    
      <category term="LeetCode" scheme="https://wangjibao.com.cn/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode31-40</title>
    <link href="https://wangjibao.com.cn/2019/05/09/LeetCode31-40/"/>
    <id>https://wangjibao.com.cn/2019/05/09/LeetCode31-40/</id>
    <published>2019-05-08T16:19:05.000Z</published>
    <updated>2019-05-09T06:52:38.873Z</updated>
    
    <content type="html"><![CDATA[<h2 id="31、下一个排列"><a href="#31、下一个排列" class="headerlink" title="31、下一个排列"></a>31、<a href="https://leetcode-cn.com/problems/next-permutation" target="_blank" rel="noopener">下一个排列</a></h2><p>偷个懒，直接使用库函数<code>next_permutation</code>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">nextPermutation</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        next_permutation(nums.begin(), nums.end());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="32、最长有效括号"><a href="#32、最长有效括号" class="headerlink" title="32、最长有效括号"></a>32、<a href="https://leetcode-cn.com/problems/longest-valid-parentheses" target="_blank" rel="noopener">最长有效括号</a></h2><p>用栈进行括号匹配消除，在消除过程中记录最大长度值。</p><a id="more"></a><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">longestValidParentheses</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">stack</span>&lt; pair&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt; &gt; st;</span><br><span class="line">        st.push(make_pair(<span class="string">'#'</span>, <span class="number">-1</span>));</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;s.length(); i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>( st.top().first==<span class="string">'('</span> &amp;&amp; s[i]==<span class="string">')'</span> )&#123;</span><br><span class="line">                st.pop();</span><br><span class="line">                ans = max(ans, i-st.top().second);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                st.push(make_pair(s[i], i));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="33、搜索旋转排序数组"><a href="#33、搜索旋转排序数组" class="headerlink" title="33、搜索旋转排序数组"></a>33、<a href="https://leetcode-cn.com/problems/search-in-rotated-sorted-array" target="_blank" rel="noopener">搜索旋转排序数组</a></h2><p>变形的二分搜索，关键点一：判断<code>mid</code>到底位于数组的前半段还是后半段；关键点二：判断下一步的搜索方向。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">search</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>, r = nums.size()<span class="number">-1</span>, mid;</span><br><span class="line">        <span class="keyword">while</span>(l&lt;=r)&#123;</span><br><span class="line">            mid = (l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>( nums[mid] &gt;= nums[l] )&#123;  <span class="comment">//落在左边</span></span><br><span class="line">                <span class="keyword">if</span>( target &gt; nums[mid] )</span><br><span class="line">                    l = mid + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>( target &lt; nums[mid] )&#123;</span><br><span class="line">                    <span class="keyword">if</span>( target&gt;nums[l] )</span><br><span class="line">                        r = mid - <span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span>( target&lt;nums[l] )</span><br><span class="line">                        l = mid + <span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                        <span class="keyword">return</span>  l;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    <span class="keyword">return</span> mid;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>( nums[mid] &lt;= nums[r] )&#123;   <span class="comment">//落在右边</span></span><br><span class="line">                <span class="keyword">if</span>( target &lt; nums[mid] )</span><br><span class="line">                    r = mid - <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>( target &gt; nums[mid] )&#123;</span><br><span class="line">                    <span class="keyword">if</span>( target&lt;nums[r] )</span><br><span class="line">                        l = mid + <span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span>( target&gt;nums[r] )</span><br><span class="line">                        r = mid - <span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                        <span class="keyword">return</span> r;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    <span class="keyword">return</span> mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="34、在排序数组中查找元素的第一个和最后一个位置"><a href="#34、在排序数组中查找元素的第一个和最后一个位置" class="headerlink" title="34、在排序数组中查找元素的第一个和最后一个位置"></a>34、<a href="https://leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array" target="_blank" rel="noopener">在排序数组中查找元素的第一个和最后一个位置</a></h2><p>使用模板库里的二分查找函数，<code>lower_bound</code>查找第一个大于或等于某个元素的位置，<code>upper_bound</code>查找第一个大于某个元素的位置。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; searchRange(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        <span class="keyword">int</span> l = lower_bound(nums.begin(), nums.end(), target) - nums.begin();</span><br><span class="line">        <span class="keyword">int</span> r = upper_bound(nums.begin(), nums.end(), target) - nums.begin();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ans&#123;l,r<span class="number">-1</span>&#125;;</span><br><span class="line">        <span class="keyword">if</span>(l==r)</span><br><span class="line">           ans[<span class="number">0</span>] = ans[<span class="number">1</span>] = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="35、搜索插入位置"><a href="#35、搜索插入位置" class="headerlink" title="35、搜索插入位置"></a>35、<a href="https://leetcode-cn.com/problems/search-insert-position" target="_blank" rel="noopener">搜索插入位置</a></h2><p>同样偷懒使用库提供的二分查找函数<code>lower_bound</code>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">searchInsert</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> lower_bound(nums.begin(), nums.end(), target) - nums.begin();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="36、有效的数独"><a href="#36、有效的数独" class="headerlink" title="36、有效的数独"></a>36、<a href="https://leetcode-cn.com/problems/valid-sudoku" target="_blank" rel="noopener">有效的数独</a></h2><p>搞个<code>book</code>数组记录，然后直接暴力循环判断就行了。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isValidSudoku</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; board)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">bool</span> book_row[<span class="number">9</span>][<span class="number">9</span>], book_col[<span class="number">9</span>][<span class="number">9</span>], book_cell[<span class="number">9</span>][<span class="number">9</span>];</span><br><span class="line">        <span class="built_in">memset</span>(book_row, <span class="number">0</span>, <span class="keyword">sizeof</span>(book_row));</span><br><span class="line">        <span class="built_in">memset</span>(book_col, <span class="number">0</span>, <span class="keyword">sizeof</span>(book_col));</span><br><span class="line">        <span class="built_in">memset</span>(book_cell, <span class="number">0</span>, <span class="keyword">sizeof</span>(book_cell));</span><br><span class="line">        <span class="keyword">int</span> num;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">9</span>; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;<span class="number">9</span>; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(board[i][j]==<span class="string">'.'</span>)</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                num = board[i][j] - <span class="string">'0'</span> - <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span>(book_row[i][num] || book_col[j][num] || book_cell[i/<span class="number">3</span>*<span class="number">3</span>+j/<span class="number">3</span>][num])</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                book_row[i][num] = <span class="literal">true</span>;</span><br><span class="line">                book_col[j][num] = <span class="literal">true</span>;</span><br><span class="line">                book_cell[i/<span class="number">3</span>*<span class="number">3</span>+j/<span class="number">3</span>][num] = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="37、解数独"><a href="#37、解数独" class="headerlink" title="37、解数独"></a>37、<a href="https://leetcode-cn.com/problems/sudoku-solver" target="_blank" rel="noopener">解数独</a></h2><p>深搜入门题，注意期间的剪枝操作。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">bool</span> book_row[<span class="number">9</span>][<span class="number">9</span>];</span><br><span class="line">    <span class="keyword">bool</span> book_col[<span class="number">9</span>][<span class="number">9</span>];</span><br><span class="line">    <span class="keyword">bool</span> book_cell[<span class="number">9</span>][<span class="number">9</span>];</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">mySolve</span><span class="params">(<span class="built_in">vector</span>&lt; <span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt; &gt;&amp; board, <span class="keyword">int</span> position)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>( position==<span class="number">81</span> )</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">int</span> row = position/<span class="number">9</span>;</span><br><span class="line">        <span class="keyword">int</span> col = position%<span class="number">9</span>;</span><br><span class="line">        <span class="keyword">if</span>(board[row][col]!=<span class="string">'.'</span>)</span><br><span class="line">            <span class="keyword">return</span> mySolve(board, position+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">9</span>; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>( !book_row[row][i] &amp;&amp; !book_col[col][i] &amp;&amp; !book_cell[row/<span class="number">3</span>*<span class="number">3</span>+col/<span class="number">3</span>][i] )&#123;</span><br><span class="line">                board[row][col] = <span class="string">'1'</span>+i;</span><br><span class="line">                book_row[row][i] = <span class="literal">true</span>;</span><br><span class="line">                book_col[col][i] = <span class="literal">true</span>;</span><br><span class="line">                book_cell[row/<span class="number">3</span>*<span class="number">3</span>+col/<span class="number">3</span>][i] = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">if</span>(!mySolve(board, position+<span class="number">1</span>))&#123;</span><br><span class="line">                    board[row][col] = <span class="string">'.'</span>;</span><br><span class="line">                    book_row[row][i] = <span class="literal">false</span>;</span><br><span class="line">                    book_col[col][i] = <span class="literal">false</span>;</span><br><span class="line">                    book_cell[row/<span class="number">3</span>*<span class="number">3</span>+col/<span class="number">3</span>][i] = <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;  <span class="comment">//唯一解</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">solveSudoku</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; board)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">9</span>; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;<span class="number">9</span>; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>( board[i][j]!=<span class="string">'.'</span> )&#123;</span><br><span class="line">                    <span class="keyword">int</span> num = board[i][j] - <span class="string">'0'</span> - <span class="number">1</span>;</span><br><span class="line">                    book_row[i][num] = <span class="literal">true</span>;</span><br><span class="line">                    book_col[j][num] = <span class="literal">true</span>;</span><br><span class="line">                    book_cell[i/<span class="number">3</span>*<span class="number">3</span>+j/<span class="number">3</span>][num] = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        mySolve(board, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="38、报数"><a href="#38、报数" class="headerlink" title="38、报数"></a>38、<a href="https://leetcode-cn.com/problems/count-and-say" target="_blank" rel="noopener">报数</a></h2><p>模拟题</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">countAndSay</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">string</span> ans = <span class="string">"1"</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> step=<span class="number">1</span>; step&lt;n; step++)&#123;</span><br><span class="line">            <span class="built_in">string</span> tmp_ans;</span><br><span class="line">            <span class="keyword">int</span> sum = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">char</span> ch = ans[<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;ans.size(); i++)&#123;</span><br><span class="line">                <span class="keyword">if</span>( ch == ans[i] )&#123;</span><br><span class="line">                    sum++;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                tmp_ans += (to_string(sum) + ch);</span><br><span class="line">                ch = ans[i];</span><br><span class="line">                sum = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            tmp_ans += (to_string(sum) + ch);</span><br><span class="line">            ans = tmp_ans;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="39、组合总和"><a href="#39、组合总和" class="headerlink" title="39、组合总和"></a>39、<a href="https://leetcode-cn.com/problems/combination-sum" target="_blank" rel="noopener">组合总和</a></h2><p>深搜入门题，注意期间的剪枝操作。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt; <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; ans;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">DFS</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; candidates, <span class="keyword">int</span> target, <span class="keyword">int</span> position, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; tmp_ans)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(target==<span class="number">0</span>)&#123;</span><br><span class="line">            ans.push_back(tmp_ans);</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=position; i&lt;candidates.size(); i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>( target&gt;=candidates[i] )&#123;  <span class="comment">//一个小剪枝</span></span><br><span class="line">                tmp_ans.push_back(candidates[i]);</span><br><span class="line">                DFS(candidates, target-candidates[i], i, tmp_ans);</span><br><span class="line">                tmp_ans.pop_back();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; combinationSum(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; candidates, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        sort(candidates.begin(), candidates.end());  <span class="comment">// 排序为了后期剪枝用</span></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; tmp_ans;</span><br><span class="line">        DFS(candidates, target, <span class="number">0</span>, tmp_ans);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="40、组合总和-II"><a href="#40、组合总和-II" class="headerlink" title="40、组合总和 II"></a>40、<a href="https://leetcode-cn.com/problems/combination-sum-ii" target="_blank" rel="noopener">组合总和 II</a></h2><p>在<code>39</code>题的基础上稍微改一下即可，一是<code>13</code>行的禁止元素重复使用，二是<code>15</code>行的去重操作。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt; <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; ans;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">DFS</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; candidates, <span class="keyword">int</span> target, <span class="keyword">int</span> position, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; tmp_ans)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(target==<span class="number">0</span>)&#123;</span><br><span class="line">            ans.push_back(tmp_ans);</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=position; i&lt;candidates.size(); i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>( target&gt;=candidates[i] )&#123;  <span class="comment">//一个小剪枝</span></span><br><span class="line">                tmp_ans.push_back(candidates[i]);</span><br><span class="line">                DFS(candidates, target-candidates[i], i+<span class="number">1</span>, tmp_ans);</span><br><span class="line">                tmp_ans.pop_back();</span><br><span class="line">                <span class="keyword">while</span>(i+<span class="number">1</span>&lt;candidates.size() &amp;&amp; candidates[i+<span class="number">1</span>]==candidates[i]) <span class="comment">// 去重操作</span></span><br><span class="line">                    i++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; combinationSum2(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; candidates, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        sort(candidates.begin(), candidates.end());  <span class="comment">// 排序为了后期剪枝用</span></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; tmp_ans;</span><br><span class="line">        ans.clear();</span><br><span class="line">        DFS(candidates, target, <span class="number">0</span>, tmp_ans);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;31、下一个排列&quot;&gt;&lt;a href=&quot;#31、下一个排列&quot; class=&quot;headerlink&quot; title=&quot;31、下一个排列&quot;&gt;&lt;/a&gt;31、&lt;a href=&quot;https://leetcode-cn.com/problems/next-permutation&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;下一个排列&lt;/a&gt;&lt;/h2&gt;&lt;p&gt;偷个懒，直接使用库函数&lt;code&gt;next_permutation&lt;/code&gt;。&lt;/p&gt;
&lt;figure class=&quot;highlight c++&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Solution&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt;:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;nextPermutation&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;built_in&quot;&gt;vector&lt;/span&gt;&amp;lt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt;&amp;gt;&amp;amp; nums)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        next_permutation(nums.begin(), nums.end());&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h2 id=&quot;32、最长有效括号&quot;&gt;&lt;a href=&quot;#32、最长有效括号&quot; class=&quot;headerlink&quot; title=&quot;32、最长有效括号&quot;&gt;&lt;/a&gt;32、&lt;a href=&quot;https://leetcode-cn.com/problems/longest-valid-parentheses&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;最长有效括号&lt;/a&gt;&lt;/h2&gt;&lt;p&gt;用栈进行括号匹配消除，在消除过程中记录最大长度值。&lt;/p&gt;
    
    </summary>
    
      <category term="LeetCode" scheme="https://wangjibao.com.cn/categories/LeetCode/"/>
    
      <category term="LeetCode31-40" scheme="https://wangjibao.com.cn/categories/LeetCode/LeetCode31-40/"/>
    
    
      <category term="LeetCode" scheme="https://wangjibao.com.cn/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>双仓库部署实现博客访问加速</title>
    <link href="https://wangjibao.com.cn/2019/04/22/%E5%8F%8C%E4%BB%93%E5%BA%93%E9%83%A8%E7%BD%B2%E5%AE%9E%E7%8E%B0%E5%8D%9A%E5%AE%A2%E8%AE%BF%E9%97%AE%E5%8A%A0%E9%80%9F/"/>
    <id>https://wangjibao.com.cn/2019/04/22/双仓库部署实现博客访问加速/</id>
    <published>2019-04-21T16:53:40.000Z</published>
    <updated>2019-04-21T18:03:28.139Z</updated>
    
    <content type="html"><![CDATA[<p>博客停更了将近半年的时间，然后近期闲着打算接着写写记录下日常学习过程，其中被同学吐槽，你这访问太慢了啊，页面好大会转不出来，怎么回事小老弟？<code>github pages</code>国内访问的话，速度还是很慢的，想要更好的提升访问速度，得将博客迁移到国内才行，幸运的是，国内的<code>coding.net</code>也提供<code>pages</code>服务。下面，我们主要讲解如何实现个人博客的<strong>双仓库</strong>部署。</p><p>1、注册 <code>coding</code> 账号，创建一个和注册名一样的仓库，部署公钥，此处部署的公钥一定要和<code>github pages</code>上的公钥一致。运行 <code>ssh -T git@git.coding.net</code> 指令，测试公钥是否添加成功，如下图所示，代表成功添加了公钥。</p><p><img src="/2019/04/22/双仓库部署实现博客访问加速/public_key.png" alt=""></p><p>2、<code>deploy</code>部署配置，更改本地 根目录下的<code>_config.yml</code>文件，如下图，这样才可以实现两个仓库的同步推送。</p><a id="more"></a><p><img src="/2019/04/22/双仓库部署实现博客访问加速/deploy.png" alt=""></p><p>配置完成后，<code>hexo clean;   hexo g -d</code> 将博客内容同步到两个仓库，在 <code>coding.net</code>中记得同步完成后开启<code>pages 服务</code>，此时便可以访问地址 <code>localdomain.coding.net</code>来浏览博客内容了。</p><p><img src="/2019/04/22/双仓库部署实现博客访问加速/pages.png" alt=""></p><p>3、<code>Pages 服务 &gt;&gt; 设置</code>中，绑定个人域名。我对此步骤的理解是，因为后期要将自己个人域名的<code>CNAME</code>指向这里，所以要绑定一下个人域名来实现验证的效果，如果没有验证的话，任何人买个域名，然后设置<code>CNAME</code>指向这里，就可以通过其他人的域名肆意访问我的资源了，这是不能容忍的。通过绑定机制，属于我的资源我可以控制通过哪些域名可以来访问。</p><p><img src="/2019/04/22/双仓库部署实现博客访问加速/bind_dns.png" alt=""></p><p>4、之前在 阿里云 买的域名， 设置域名解析如图：</p><p><img src="/2019/04/22/双仓库部署实现博客访问加速/dns.png" alt=""></p><p>当在国内访问 <code>www.wangjibao.com.cn</code>时，会解析国内的<code>localdomain.coding.net</code>，这样速度比较快。</p><p>无论在国内还是国外访问<code>wangjibao.com.cn</code>时，会直接返回<code>185.199.111.153</code>的<code>github.io</code>的地址，虽然速度可能有些慢，但这样实现了无论加不加<code>www</code>的头都可以访问博客的目的。</p><p>当在国外访问<code>www.wangjibao.com.cn</code>时，会解析国外的<code>wangjibao.github.io</code>的地址，对外国人来说的话， 速度也不慢。</p><p><img src="/2019/04/22/双仓库部署实现博客访问加速/nslookup.png" alt=""></p><p>5、上图中的 <code>nslookup</code>印证了我们的想法，接下来使用站长之家的<a href="http://tool.chinaz.com/speedtest.aspx" target="_blank" rel="noopener">网站测速</a>功能，查看改造前与改造后的访问速度效果图，如下：</p><p><img src="/2019/04/22/双仓库部署实现博客访问加速/qian.png" alt=""></p><p><img src="/2019/04/22/双仓库部署实现博客访问加速/hou.png" alt=""></p><p>看着就舒坦啊，要想生活过得去，就需要来点绿。穷X一枚，等后期有空看看能不能通过免费的<code>CDN</code>再加速一波。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;博客停更了将近半年的时间，然后近期闲着打算接着写写记录下日常学习过程，其中被同学吐槽，你这访问太慢了啊，页面好大会转不出来，怎么回事小老弟？&lt;code&gt;github pages&lt;/code&gt;国内访问的话，速度还是很慢的，想要更好的提升访问速度，得将博客迁移到国内才行，幸运的是，国内的&lt;code&gt;coding.net&lt;/code&gt;也提供&lt;code&gt;pages&lt;/code&gt;服务。下面，我们主要讲解如何实现个人博客的&lt;strong&gt;双仓库&lt;/strong&gt;部署。&lt;/p&gt;
&lt;p&gt;1、注册 &lt;code&gt;coding&lt;/code&gt; 账号，创建一个和注册名一样的仓库，部署公钥，此处部署的公钥一定要和&lt;code&gt;github pages&lt;/code&gt;上的公钥一致。运行 &lt;code&gt;ssh -T git@git.coding.net&lt;/code&gt; 指令，测试公钥是否添加成功，如下图所示，代表成功添加了公钥。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/2019/04/22/双仓库部署实现博客访问加速/public_key.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;2、&lt;code&gt;deploy&lt;/code&gt;部署配置，更改本地 根目录下的&lt;code&gt;_config.yml&lt;/code&gt;文件，如下图，这样才可以实现两个仓库的同步推送。&lt;/p&gt;
    
    </summary>
    
      <category term="笔记" scheme="https://wangjibao.com.cn/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="笔记" scheme="https://wangjibao.com.cn/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>Ubuntu个性美化</title>
    <link href="https://wangjibao.com.cn/2019/04/20/Ubuntu%E4%B8%AA%E6%80%A7%E7%BE%8E%E5%8C%96/"/>
    <id>https://wangjibao.com.cn/2019/04/20/Ubuntu个性美化/</id>
    <published>2019-04-20T08:26:33.000Z</published>
    <updated>2019-04-20T08:40:49.852Z</updated>
    
    <content type="html"><![CDATA[<p>1、<strong>安装<code>VMware Tools</code></strong></p><p>在<code>VMware</code>中安装虚拟机后，记得安装<code>VMware Tools</code>。在虚拟机中找到名为<code>VMwareTools…tar.gz</code>的压缩包（一般在<code>media</code>文件夹中），复制到某个文件夹中后执行：<code>tar -xvzf VMwareTools…tar.gz</code>进行解压。之后会看到一个 <code>./vmware-install.pl</code>的执行程序，执行后安装，一路默认即可，安装完成后，重启虚拟机。</p><p>2、<strong>卸载自带软件</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dpkg --list   # 查看自带已安装程序</span><br><span class="line">sudo apt-get --purge remove &lt;programname&gt;      # 卸载程序和所有配置文件</span><br><span class="line">sudo apt-get remove &lt;programname&gt;              # 只卸载程序</span><br></pre></td></tr></table></figure><p>当然也可以在<code>软件管理</code>中进行查看已安装软件，卸载软件等操作。</p><p>3、<strong><code>GTK</code>,<code>GTK+</code>,<code>Qt</code>, <code>KDE</code>,<code>GNOME</code>, <code>Unity</code>的区别与联系</strong></p><a id="more"></a><p>Linux本身没有图形界面，Linux现在的图形界面系统只是Linux下的应用程序。</p><p><code>GTK</code>,  <code>GTK+</code>, <code>Qt</code>是图形界面开发库(GUI Toolkit)，用户可以使用这些开发库编写GUI应用。</p><p><code>KDE</code>，<code>GNOME</code>，<code>Unity</code>是<code>linux</code>下的桌面环境(Desktop Environment)，其中<code>KDE</code>使用<code>Qt</code>开发，<code>GNOME</code>使用<code>GTK+</code>开发，<code>Unity</code>是基于<code>GNOME</code>开发的一个桌面环境。</p><p>从 <code>Ubuntu 16.04 LTS</code> 到<code>Ubuntu 18.04 LTS</code> 最显著的变化是 Unity 用户界面被替换为了GNOME 桌面环境。</p><p>4、<strong>安装美化主题</strong></p><p><a href="https://www.cnblogs.com/feipeng8848/p/8970556.html" target="_blank" rel="noopener">参考博客</a>，本文用到的主题工具包<a href="/download/Ubuntu美化.rar">下载</a></p><p>美化过程中涉及的两个目录：<code>/usr/share/themes</code> 和 <code>/usr/share/icons</code>。</p><p>1）安装 <code>TweakTool</code> 工具：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install gnome-tweak-tool</span><br><span class="line">sudo apt-get install gnome-shell-extensions   # 解决Tweaks中shell无法设置的问题</span><br></pre></td></tr></table></figure><p>2）安装<code>GTK</code>主题，修改图标，更改桌面<code>shell</code>，<a href="https://www.opendesktop.org/" target="_blank" rel="noopener">下载网址</a>，将主题和桌面shell放到<code>/usr/share/themes/</code>目录下，图标包放到<code>/usr/share/icons/</code>文件夹下，之后在<code>Tweaks</code>工具中，即可选择使用它们</p><p><img src="/2019/04/20/Ubuntu个性美化/tweaks.png" alt=""></p><p>效果图如下：</p><p><img src="/2019/04/20/Ubuntu个性美化/macos.png" alt=""></p><p>3）更改开机动画，<a href="https://www.gnome-look.org/" target="_blank" rel="noopener">下载网址</a></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">将下载的开机动画解压并拷贝到： usr/share/plymouth/themes</span><br><span class="line">sudo update-alternatives --install /usr/share/plymouth/themes/default.plymouth default.plymouth /usr/share/plymouth/themes/***/***.plymouth 100</span><br><span class="line">sudo update-alternatives --config default.plymouth  # 选择对应序号即可，*号代表当前使用</span><br><span class="line">sudo update-initramfs -u</span><br></pre></td></tr></table></figure><p>4）更改<a href="https://github.com/taeven/Ocean-blue-GDM3" target="_blank" rel="noopener">登录界面的背景</a>（也可只修改<code>css</code>文件中对应的图片链接即可）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">cp 下载的登录界面.jpg /usr/share/backgrounds/</span><br><span class="line"><span class="meta">#</span> 备份自带登录css文件</span><br><span class="line">cp /usr/share/gnome-shell/theme/ubuntu.css /usr/share/gnome-shell/theme/ubuntu.css.bak</span><br><span class="line">cp 下载的并更名为ubuntu.css的文件 /usr/share/gnome-shell/theme/</span><br><span class="line">reboot</span><br></pre></td></tr></table></figure><p>效果图：</p><p><img src="/2019/04/20/Ubuntu个性美化/login.png" alt=""></p><p>4）修改桌面<code>shell</code>的宽度和字体等。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;1、&lt;strong&gt;安装&lt;code&gt;VMware Tools&lt;/code&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在&lt;code&gt;VMware&lt;/code&gt;中安装虚拟机后，记得安装&lt;code&gt;VMware Tools&lt;/code&gt;。在虚拟机中找到名为&lt;code&gt;VMwareTools…tar.gz&lt;/code&gt;的压缩包（一般在&lt;code&gt;media&lt;/code&gt;文件夹中），复制到某个文件夹中后执行：&lt;code&gt;tar -xvzf VMwareTools…tar.gz&lt;/code&gt;进行解压。之后会看到一个 &lt;code&gt;./vmware-install.pl&lt;/code&gt;的执行程序，执行后安装，一路默认即可，安装完成后，重启虚拟机。&lt;/p&gt;
&lt;p&gt;2、&lt;strong&gt;卸载自带软件&lt;/strong&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight shell&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;dpkg --list   # 查看自带已安装程序&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;sudo apt-get --purge remove &amp;lt;programname&amp;gt;      # 卸载程序和所有配置文件&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;sudo apt-get remove &amp;lt;programname&amp;gt;              # 只卸载程序&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;当然也可以在&lt;code&gt;软件管理&lt;/code&gt;中进行查看已安装软件，卸载软件等操作。&lt;/p&gt;
&lt;p&gt;3、&lt;strong&gt;&lt;code&gt;GTK&lt;/code&gt;,&lt;code&gt;GTK+&lt;/code&gt;,&lt;code&gt;Qt&lt;/code&gt;, &lt;code&gt;KDE&lt;/code&gt;,&lt;code&gt;GNOME&lt;/code&gt;, &lt;code&gt;Unity&lt;/code&gt;的区别与联系&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="笔记" scheme="https://wangjibao.com.cn/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="笔记" scheme="https://wangjibao.com.cn/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>Ubuntu官方源和PPA源简介</title>
    <link href="https://wangjibao.com.cn/2019/04/20/Ubuntu%E5%AE%98%E6%96%B9%E6%BA%90%E5%92%8CPPA%E6%BA%90%E7%AE%80%E4%BB%8B/"/>
    <id>https://wangjibao.com.cn/2019/04/20/Ubuntu官方源和PPA源简介/</id>
    <published>2019-04-20T08:12:10.000Z</published>
    <updated>2019-04-20T08:25:32.475Z</updated>
    
    <content type="html"><![CDATA[<p>在<code>ubuntu</code>中，软件的安装主要有3种方式：</p><ul><li><p>通过<code>apt</code>包管理工具从官方软件源安装</p></li><li><p>通过<code>deb</code>格式的软件包安装，以安装<code>搜狗输入法</code>为例：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">下载 sogou.deb</span><br><span class="line">sudo dpkg -i sogou.deb       #出现安装不成功，需要依赖</span><br><span class="line">sudo apt-get install -f      #安装依赖</span><br><span class="line">sudo dpkg -i sogou.deb</span><br></pre></td></tr></table></figure></li><li><p>使用软件的源码手动编译安装</p></li></ul><p>下面我们主要介绍第一种安装方式，即<code>apt</code>命令从软件源安装。软件源分为 <code>Ubuntu官方软件源</code> 和 <code>PPA软件源</code> 两种。</p><a id="more"></a><p>1）<code>Ubuntu</code> 官方软件源，其中包含了系统中绝大多数的软件，对应的目录为 <code>/etc/apt/sources.list</code>，如下所示：</p><p><img src="/2019/04/20/Ubuntu官方源和PPA源简介/sources_list.png" alt=""></p><p>一般情况下，我们会将其改成国内的镜像源，因为访问国外的资源太慢了，<a href="https://segmentfault.com/a/1190000000375848" target="_blank" rel="noopener">国内开源镜像站点汇总</a>。</p><p>安装和卸载软件也非常的简单：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install &lt;package-name&gt;    # 安装</span><br><span class="line">sudo apt-get remove &lt;package-name&gt;     # 卸载</span><br></pre></td></tr></table></figure><p>每当通过 <code>install</code> 命令去安装一个软件时，apt 包管理工具就会从系统中的<code>/etc/apt/sources.list</code>文件或<code>/etc/apt/sources.list.d</code>文件夹中去读取软件源的网址信息，查找可以包含该软件的软件源的网址，然后就从这个网址上把指定的软件给下载下来，然后由 apt 包管理工具在本地进行一些解压和安装的其他操作。</p><p>2）<code>PPA(Personal Package Archives)</code>个人软件包集，它出现的原因是：系统自带的源是非常有限的 ，如果通过<code>deb</code>直接安装其他软件的话，得不到更新和维护，所以此时<code>PPA</code>软件源就应运而生。它其实是一个<a href="https://launchpad.net/" target="_blank" rel="noopener">网站</a>，开发者们在上面建立自己的仓库，上传开发的软件供用户安装。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo add-apt-repository ppa:user/ppa-name    # 添加ppa软件源</span><br><span class="line">sudo add-apt-repository --remove ppa:user/ppa-name    # 删除ppa软件源</span><br></pre></td></tr></table></figure><p>当添加完某个<code>ppa</code>软件源后，会在系统的 <code>/etc/apt/sources.list.d</code> 目录下生成对应的源文件：</p><p><img src="/2019/04/20/Ubuntu官方源和PPA源简介/sources_list_d.png" alt=""></p><p>可见，此操作就是在文件里添加了一个和软件源一模一样的东西，以 <code>notepad++</code> 的使用为例：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> 安装</span><br><span class="line">sudo add-apt-repository ppa:notepadqq-team/notepadqq</span><br><span class="line">sudo apt-get update   # 记得此时要更新一下软件源</span><br><span class="line">sudo apt-get install notepadqq</span><br><span class="line"><span class="meta">#</span> 卸载</span><br><span class="line">sudo apt-get remove notepadqq</span><br><span class="line">sudo add-apt-repository --remove ppa:notepadqq-team/notepadqq</span><br></pre></td></tr></table></figure><p>3）上面两个东西，其实要实现的功能是一样的，之所以在系统中存在<code>/etc/apt/sources.list</code>和<code>/etc/apt/sources.list.d</code>两套东西，是系统为了区分官方源与第三方源，毕竟第三方源存在安全问题的可能性比较大。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在&lt;code&gt;ubuntu&lt;/code&gt;中，软件的安装主要有3种方式：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;通过&lt;code&gt;apt&lt;/code&gt;包管理工具从官方软件源安装&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;通过&lt;code&gt;deb&lt;/code&gt;格式的软件包安装，以安装&lt;code&gt;搜狗输入法&lt;/code&gt;为例：&lt;/p&gt;
&lt;figure class=&quot;highlight shell&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;下载 sogou.deb&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;sudo dpkg -i sogou.deb       #出现安装不成功，需要依赖&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;sudo apt-get install -f      #安装依赖&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;sudo dpkg -i sogou.deb&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;使用软件的源码手动编译安装&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;下面我们主要介绍第一种安装方式，即&lt;code&gt;apt&lt;/code&gt;命令从软件源安装。软件源分为 &lt;code&gt;Ubuntu官方软件源&lt;/code&gt; 和 &lt;code&gt;PPA软件源&lt;/code&gt; 两种。&lt;/p&gt;
    
    </summary>
    
      <category term="笔记" scheme="https://wangjibao.com.cn/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="笔记" scheme="https://wangjibao.com.cn/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>HTTP抓包实战</title>
    <link href="https://wangjibao.com.cn/2018/11/13/HTTP%E6%8A%93%E5%8C%85%E5%AE%9E%E6%88%98/"/>
    <id>https://wangjibao.com.cn/2018/11/13/HTTP抓包实战/</id>
    <published>2018-11-13T15:39:06.000Z</published>
    <updated>2018-11-16T16:33:47.860Z</updated>
    
    <content type="html"><![CDATA[<p>开始读《HTTP抓包实战》，在这个作业满天飞的日子里，计划1周读完，本篇博文对其中的部分知识点做一下简单的记录。</p><p>1、HTTP抓包分析使用的工具不再是wireshark（研究TCP/IP协议使用），而是使用 <a href="https://www.telerik.com/fiddler" target="_blank" rel="noopener">fiddler</a>，版本4。其实 fiddler 做HTTP数据包分析的原理就是相当于一个<strong>web代理</strong>，如下图：</p><p><img src="/2018/11/13/HTTP抓包实战/web_proxy.png" alt=""></p><p>fiddler在中间，可以记录所用的HTTP流量。fiddler启动时，会偷偷把 Internet 选项中的代理修改为 ：127.0.0.1,端口： 8888; fiddler在关闭时，会自动在Internet选项中取消代理，这样就不会对其他程序产生影响。如下图：</p><p><img src="/2018/11/13/HTTP抓包实战/127001.png" alt=""></p><a id="more"></a><p>fiddler界面如下图，使用方法请自行百度或google.</p><p><img src="/2018/11/13/HTTP抓包实战/fiddler.png" alt=""></p><p>2、在 <code>fiddler</code>中抓取 <code>https</code> 的流量，需要做如下图配置并安装证书。</p><p><img src="/2018/11/13/HTTP抓包实战/ca.png" alt=""></p><p>像 <code>IE</code>，<code>chrome</code>等浏览器都是使用<code>windows</code>证书库来验证证书，但是<code>firefox</code>浏览器是自己维护一个证书列表，所以需要在<code>firefox</code>中单独安装 <code>fiddler</code>证书。在上图中的<code>action</code>选项中可以下载<code>fiddler</code>的根证书到桌面，<code>firefox &gt;&gt; 工具 &gt;&gt; 选项 &gt;&gt; 隐私与安全 &gt;&gt; 证书 &gt;&gt; 查看证书 &gt;&gt; 证书机构</code>中可以导入证书，这里，<code>fiddler</code>的作者开了个玩笑，证书名叫<code>DO_NOT_TRUST_FiddlerRoot</code>。</p><p>3、在抓包时，我们经常能看到 <code>tunnel to</code>的握手包，这对我们分析数据包没啥作用，可以在<code>fiddler &gt;&gt; rules &gt;&gt; hide connects</code>中设置其隐藏掉。</p><p><img src="/2018/11/13/HTTP抓包实战/tunnelto.png" alt=""></p><p>4、Win+R输入<code>certmgr.msc</code>查看<code>windows</code>证书管理库</p><p><img src="/2018/11/13/HTTP抓包实战/certmgr.png" alt=""></p><p>5、<code>https://www.wangjibao.com.cn/2018/11/13/HTTP%E6%8A%93%E5%8C%85%E5%AE%9E%E6%88%98/#more</code></p><p>上面是个<code>url</code>的例子，<code>https</code>协议，<code>www.wangjibao.com.cn</code>为域名，这里使用的是默认<code>80</code>端口，所以省略端口显示，后面的<code>/2018/11/13/HTTP%E6%8A%93%E5%8C%85%E5%AE%9E%E6%88%98/</code>代表资源的路径，后面的<code>#</code>号代表啥呢，其实这是个 <code>锚点(anchor)</code>，我们知道，当一个页面非常长的时候，我们可以在页面中根据锚点直接定位到我们需要的地方。</p><p>6、HTTP的状态码，200类是成功，300类代表重定向，400类代表客户端错误，500类错误代表服务器错误。</p><p>其中的<code>206(Partial Content)</code>代表的是部分内容，迅雷、HTTP下载工具就是使用<code>206</code>状态码来实现的断点续传。</p><p>当遇到<code>301 或 302</code>的响应时，浏览器会自动根据<code>response</code>中的重定向<code>url</code>重新访问资源地址。如下图（京东之前叫<code>360buy</code>)：</p><p><img src="/2018/11/13/HTTP抓包实战/location.png" alt=""></p><p>先访问<code>www.360buy.com</code>返回<code>301</code>说这个网址已经<code>move permanently</code>了，给了个<code>http://www.jd.com</code>，然后，浏览器就是访问这个网址，但是服务器说<code>302</code>，代表说，这次对了，但是为了安全，去访问另一个网址吧<code>https://www.jd.com</code>吧，接着就会发现，129号中显示了<code>tunnel to</code>，代表开始握手协商了。</p><p>其实，这里<code>301或302</code>还是有区别的，<code>301</code>代表旧<code>url</code>已经永久移除了，搜索引擎会把权重计算到新的<code>url</code>上。但<code>302</code>代表旧<code>url</code>还在，只是临时重定向到新<code>url</code>上，搜索引擎会把权重计算到旧<code>url</code>上。</p><p>7、常用的HTTP请求方法就是 <code>get</code>和<code>post</code>。</p><p><img src="/2018/11/13/HTTP抓包实战/post.png" alt=""></p><p>我们登录国科大的选课网站，在 <code>fildder</code>中，可以清楚的看到，用户名和密码被包含在<code>post</code>请求的<code>body</code>中，发送给了服务器。同样，如果是<code>get</code>请求，包含在<code>url</code>中<code>?</code>后面的字段可以在<code>QueryString</code>中看到对应的<code>Name--Value</code>字段。</p><p>8、可以在<code>fiddler &gt;&gt; tools &gt;&gt; user-agent</code>中修改<code>User-Agent</code>字段的值，如下图，再浏览某些网页时，就变成了对应的显示模式。</p><p><img src="/2018/11/13/HTTP抓包实战/user-agent.png" alt=""></p><p>9、Ajax (<strong>A</strong>synchronous  <strong>J</strong>avascript  <strong>A</strong>nd  <strong>X</strong>ML”: 异步 JavaScript 和 XML）,是一种在无需重新加载整个网页的情况下，能够更新部分网页的技术。</p><p>10、在 <code>Rules &gt;&gt; Automatic Breakpoint &gt;&gt; after/before Response</code>中可以设置拦截<code>HTTP</code>请求。比如，我可以设置拦击HTTP的响应，然后在<code>raw</code>中修改页面的<code>title</code>字段，点击<code>Run to Completion</code>发成修改后的发送。</p><p><img src="/2018/11/13/HTTP抓包实战/breakpoint.png" alt=""></p><p>1号包中的红色代表拦截到了，这时别忘了，<strong>之前设置的全局断点给取消掉</strong>，不然会影响其他请求的发送和接收。效果如下图：</p><p><img src="/2018/11/13/HTTP抓包实战/modifyresponse.png" alt=""></p><p>注意：修改操作必须在<code>raw</code>选项框里。当然，也可以设置局部断点，<code>bpu www.baidu.com</code>设置只拦截百度的请求，取消拦截在页面左下角的命令框中输入<code>bpu</code>即可；<code>bpafter www.baidu.com</code>拦截响应，<code>bpafter</code>取消拦截响应。</p><p>11、浏览器中的缓存</p><p>如下图，浏览器想请求某个资源的时候，先检查本地缓存，如果本地缓存存在这个文件的时候，直接获取该文件的最后修改时间等信息，构造数据包发送请求（内含有<code>If-Modified-Since</code>字段和<code>If-None-Match</code>字段）给服务器，服务器根据这两个值，结合自身的<code>Last-Modified</code>字段和<code>Etag</code>字段来判断需不需要发送数据给浏览器，如果不需要（1、Request中的If-Modified-Since的时间大于或等于Resonse中的Last-Modified的时间；2、ETag值和If-None-Match相匹配，说明hash值不变文档没改变），则服务器发送 <code>304 Response</code>给浏览器，告诉它，直接使用缓存就行了，节省时间加快网页加载速度。</p><p><img src="/2018/11/13/HTTP抓包实战/lastmodify.png" alt=""></p><p>当然，我们也可以 <code>ctrl + F5</code>强制刷新浏览器，告诉服务器，我不使用缓存，请发送最新的数据资源给我。</p><p><img src="/2018/11/13/HTTP抓包实战/nocache.png" alt=""></p><p>其中的<code>pragma</code>是HTTP1.0中使用的，<code>Cache-Control</code>是现在HTTP1.1用的，同时存在这两个字段，完全是为了兼容。</p><p>12、<code>URL</code>只能使用英文字母、数字或者某些标点符号，URL Encode(URL 编码)就是把所有非英文字母、数字字符都替换成百分号（%）后加两位十六进制数。如：</p><p><code>https://www.wangjibao.com.cn/2018/11/13/HTTP抓包实战</code> 编码后变成了如下模式，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://www.wangjibao.com.cn/2018/11/13/HTTP%E6%8A%93%E5%8C%85%E5%AE%9E%E6%88%98/</span><br></pre></td></tr></table></figure><p>13、<code>Fiddler</code>提供了丰富的插件，可以在<a href="https://www.telerik.com/fiddler/add-ons中下载安装使用，如`Java" target="_blank" rel="noopener">https://www.telerik.com/fiddler/add-ons中下载安装使用，如`Java</a> Script Formatter<code>、</code>Gallery<code>、</code>WinDiff`（比较两个session的不同）等等。</p><p>14、 <code>Fiddler</code>中可以在线调试 <code>JavaScript</code>文件，使用的是<code>AutoResponder</code>功能，如下图，其原理就是当命中某个文件时，自动替换成我们设置的文件返回给客户端，就不去服务器索取了。</p><p><img src="/2018/11/13/HTTP抓包实战/js.png" alt=""></p><p>当然，不仅可以替换 <code>JS</code> 文件，还可以替换网页中的图片为本地我们设置的图片。</p><p>15、我们还可以直接编辑<code>Fiddler Script</code>来修改HTTP请求或者响应，并且不中断程序（之前介绍的设置断点的方式，会使得程序中断）。<code>Rules &gt;&gt; Coustomize Rules</code>中，打开<code>Fiddler ScriptEditor</code>来编辑<code>CustomRules.js</code>文件，如图：</p><p><img src="/2018/11/13/HTTP抓包实战/scripteditor.png" alt=""></p><p>16、HTTP的<code>Cookie</code>机制</p><p>因为<code>HTTP</code>协议是无状态的，可以通过<code>Cookie</code>来维持会话。登录 <code>http://piaoweb.sstm.org.cn</code>，可以在<code>fiddler</code>中看到<code>cookie</code>的运行机制，如下图：</p><p><img src="/2018/11/13/HTTP抓包实战/cookie.png" alt=""></p><p>浏览器把<code>Cookie</code>通过HTTP请求中的<code>Header</code>发送给服务器，同时，服务器通过HTTP响应中的<code>Header</code>(Set-Cookie机制)把<code>Cookie</code>发送给浏览器。</p><p>上图中的 <code>HttpOnly</code>字段是说通过<code>JavaScript</code>脚本无法读取到<code>Cookie</code>信息，可以有效防止<code>XSS</code>攻击。</p><p>浏览器根据服务器返回的<code>Set-Cookie</code>设置好本地<code>Cookie</code>以后，浏览器每次请求服务器的资源时，就在<code>Header</code>中将<code>Cookie</code>附加上，这样，服务器就认为浏览器是登录状态。</p><p>17、Cookie劫持攻击</p><p>这里我们使用<code>豆瓣</code>网为例，演示一下<code>Cookie</code>劫持攻击。</p><p>（1）登录<a href="https://www.douban.com/" target="_blank" rel="noopener">豆瓣网</a>，用<code>Fiddler</code>抓取登录过程产生的数据包，可以看到一个如下图中的包，里面含有我们需要的<code>cookie</code>。</p><p><img src="/2018/11/13/HTTP抓包实战/doubanaccount.png" alt=""></p><p>（2）我们打开这个会话的<code>session</code>，可以看到用户的<code>cookie</code>，其中的<code>dbcl2</code>是和用户登录相关的。</p><p><img src="/2018/11/13/HTTP抓包实战/accounts.png" alt=""></p><p>（3）我们在该会话上右键，<code>replay &gt;&gt; Reissue and Edit</code>，将cookie中的此字段删除，然后<code>Run to Completion</code>放行，可以看到此时我们现在是非登录状态，并且跳转到了登录界面，服务器返回<code>302</code>。</p><p><img src="/2018/11/13/HTTP抓包实战/relocation.png" alt=""></p><p>（4）现在我们知道，这个<code>cookie</code>字段就是和用户登录相关的，并且已经劫持到了，那么如何利用它呢？可以利用之前提到的<code>Fiddler Script</code>，编写脚本，每次发送数据包的时候，自动加上这个cookie不就行了，并且这个操作不会有任何中断。</p><p>在 <code>Fiddler Script</code>中的<code>OnBeforeRequest</code>函数中添加如下代码段：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(oSession.uriContains(<span class="string">"douban.com"</span>))&#123;</span><br><span class="line"><span class="keyword">var</span> sCookie = <span class="string">"dbcl2=\"170842457:NW8ZWiZHFUU\""</span>;</span><br><span class="line">oSession.oRequest[<span class="string">"Cookie"</span>] = sCookie;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再次访问豆瓣网，发现自己已经处于登录状态了。</p><p>18、<code>HTTP</code>基本验证</p><p>把<code>用户名+冒号+密码</code>用<code>Base64</code>编码后生成字符串，放在<code>header</code>中的<code>Authorization</code>字段中，发送给服务器。</p><p>19、手机<code>Fiddler</code>抓包</p><p>手机和电脑处于同一局域网中，在<code>fiddler &gt;&gt; Tools &gt;&gt; Options &gt;&gt; Connections</code>中将<code>allow remote computers to connect</code>勾选上，同时在手机的<code>wlan</code>设置中，将其代理设置成电脑，<code>IP</code>为电脑IP，端口为<code>8888</code>；同时，在手机的安全设置中可以安装之前下载的<code>fiddler root</code>根证书，这样，就可以捕获到手机的<code>https</code>数据包了。</p><p>20、<code>Replay</code>菜单的详细说明：</p><p><code>Reissue Requests</code>：重新发送请求，和菜单栏上的<code>Replay</code>按钮是一样的功能。</p><p><code>Reissue Unconditionally</code>：无条件反复发送选中的请求。</p><p><code>Reissue and Edit</code>：把选中的请求以原来的形式重新发送，在每个新的<code>Session</code>中设置断点，在请求发送给服务器之前，可以修改请求。</p><p><code>Reissue and Verify</code>：重新发送请求，检查响应，如果响应和上一个请求一样，就会变成绿色。</p><p><code>Reissue Sequentially</code>：选中多个<code>Session</code>会按顺序一个一个重新发送请求，是单线程模式。</p><p><code>Reissue from Composer</code>：在<code>Composer</code>中编辑该请求。</p><p><code>Revisit in IE</code>：在<code>IE</code>浏览器中用<code>Get</code>方法访问这个请求。</p><p>21、重放攻击，在<code>Fiddler</code>中，可以使用<code>Composer</code>编辑数据包并进行发送。</p><p><img src="/2018/11/13/HTTP抓包实战/composer.png" alt=""></p><p>其实，重放攻击危害很大，比如说，某网站的投票或者点赞功能，当我们抓取到某个点赞的包时，我们可以重复发送这个数据包来进行刷票。再比如说，某些软件的注册，当我们抓取到某个注册请求包的时候，我们进行大量重复发送，对<code>app</code>造成的损失还是很大的。</p><p>解决方案：在<code>HTTP</code>请求中，添加时间戳<code>stamp</code>和数字签名<code>sign</code>。数字签名保证有效性，时间戳保证时效性。</p><p>22、后面的3–4个章节是使用<code>JMeter</code>对网站做自动化测试和压力测试的，在此略过。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;开始读《HTTP抓包实战》，在这个作业满天飞的日子里，计划1周读完，本篇博文对其中的部分知识点做一下简单的记录。&lt;/p&gt;
&lt;p&gt;1、HTTP抓包分析使用的工具不再是wireshark（研究TCP/IP协议使用），而是使用 &lt;a href=&quot;https://www.telerik.com/fiddler&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;fiddler&lt;/a&gt;，版本4。其实 fiddler 做HTTP数据包分析的原理就是相当于一个&lt;strong&gt;web代理&lt;/strong&gt;，如下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/2018/11/13/HTTP抓包实战/web_proxy.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;fiddler在中间，可以记录所用的HTTP流量。fiddler启动时，会偷偷把 Internet 选项中的代理修改为 ：127.0.0.1,端口： 8888; fiddler在关闭时，会自动在Internet选项中取消代理，这样就不会对其他程序产生影响。如下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/2018/11/13/HTTP抓包实战/127001.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="笔记" scheme="https://wangjibao.com.cn/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="笔记" scheme="https://wangjibao.com.cn/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>小知识科普</title>
    <link href="https://wangjibao.com.cn/2018/11/12/%E5%B0%8F%E7%9F%A5%E8%AF%86%E7%A7%91%E6%99%AE/"/>
    <id>https://wangjibao.com.cn/2018/11/12/小知识科普/</id>
    <published>2018-11-12T15:52:28.000Z</published>
    <updated>2018-11-12T16:26:51.535Z</updated>
    
    <content type="html"><![CDATA[<p>本篇博文记录一下平时生活中遇到的小知识，不定期更新。</p><h4 id="1、判断USB接口类型"><a href="#1、判断USB接口类型" class="headerlink" title="1、判断USB接口类型"></a>1、判断USB接口类型</h4><p>晚上同学过来借扩展坞，看了眼USB接口的颜色，问，这是2.0的口吗？很明显，本渣渣耗费 199大洋 采购的东东，怎么能不是 3.0 的口呢。其实凭借USB接口的颜色能够一定程度上判断接口类型，但并不一定准确。</p><p>准确的做法是：看<strong>接口的针脚数</strong> ，<code>USB2.0</code> 的针脚数目是 <strong>4</strong> 个，<code>USB3.0</code> 的针脚数目是 <strong>9</strong> 个。如下图：</p><p><img src="/2018/11/12/小知识科普/usb2.png" alt=""></p><p>上图是本渣18年从青大毕业时，学院发的纪念U盘，4个引脚，USB2.0的接口。为啥发U盘呢，18年在青岛开上合峰会的时候正值毕业季，各种大型活动统统不让搞，往年的毕业歌会也被无情的取消，那么办晚会的钱就拿来每人发个U盘吧，反正大家都是搞计算机的，以后也用得到，话说要发好歹也发个3.0口的u盘呗，吐槽一下。不过，当时每个U盘里都拷了毕业纪念视频，还是挺走心的，这个得表扬一波。</p><a id="more"></a><p>多说一句，<strong>信息安全班</strong>里当时毕业没有毕业聚餐你敢相信！？？其实知道现在想起来，还是耿耿于怀，原因大家也都心知肚明，怎么说，无愧于心就好！</p><p><img src="/2018/11/12/小知识科普/usb3.png" alt=""></p><p>上图是<strong>3.0</strong> 的口，<strong>9</strong>个引脚能看清不，外面 <strong>5</strong> 个，里面 <strong>4</strong> 个。想一下，为啥2.0的东西插到3.0的口也能正常使用，是不就是使用的里面那<strong>4</strong>个引脚，外面那<strong>5</strong>个是闲着的，当插入3.0的东西时，这9个引脚会全部起作用。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本篇博文记录一下平时生活中遇到的小知识，不定期更新。&lt;/p&gt;
&lt;h4 id=&quot;1、判断USB接口类型&quot;&gt;&lt;a href=&quot;#1、判断USB接口类型&quot; class=&quot;headerlink&quot; title=&quot;1、判断USB接口类型&quot;&gt;&lt;/a&gt;1、判断USB接口类型&lt;/h4&gt;&lt;p&gt;晚上同学过来借扩展坞，看了眼USB接口的颜色，问，这是2.0的口吗？很明显，本渣渣耗费 199大洋 采购的东东，怎么能不是 3.0 的口呢。其实凭借USB接口的颜色能够一定程度上判断接口类型，但并不一定准确。&lt;/p&gt;
&lt;p&gt;准确的做法是：看&lt;strong&gt;接口的针脚数&lt;/strong&gt; ，&lt;code&gt;USB2.0&lt;/code&gt; 的针脚数目是 &lt;strong&gt;4&lt;/strong&gt; 个，&lt;code&gt;USB3.0&lt;/code&gt; 的针脚数目是 &lt;strong&gt;9&lt;/strong&gt; 个。如下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/2018/11/12/小知识科普/usb2.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;上图是本渣18年从青大毕业时，学院发的纪念U盘，4个引脚，USB2.0的接口。为啥发U盘呢，18年在青岛开上合峰会的时候正值毕业季，各种大型活动统统不让搞，往年的毕业歌会也被无情的取消，那么办晚会的钱就拿来每人发个U盘吧，反正大家都是搞计算机的，以后也用得到，话说要发好歹也发个3.0口的u盘呗，吐槽一下。不过，当时每个U盘里都拷了毕业纪念视频，还是挺走心的，这个得表扬一波。&lt;/p&gt;
    
    </summary>
    
      <category term="笔记" scheme="https://wangjibao.com.cn/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="笔记" scheme="https://wangjibao.com.cn/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>树莓派搭建智能路由器</title>
    <link href="https://wangjibao.com.cn/2018/11/12/%E6%A0%91%E8%8E%93%E6%B4%BE%E6%90%AD%E5%BB%BA%E6%99%BA%E8%83%BD%E8%B7%AF%E7%94%B1%E5%99%A8/"/>
    <id>https://wangjibao.com.cn/2018/11/12/树莓派搭建智能路由器/</id>
    <published>2018-11-12T15:40:44.000Z</published>
    <updated>2018-11-12T17:14:51.290Z</updated>
    
    <content type="html"><![CDATA[<p>使用树莓派搭建一个小智能路由器，文档为当年做本科毕业设计时写的，单纯的一个环境搭建记录，放出来，喜欢玩的小伙伴说不定可以参考一下。</p><a id="more"></a><div class="row">    <embed src="树莓派搭建智能路由器.pdf" width="100%" height="550" type="application/pdf"></div>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;使用树莓派搭建一个小智能路由器，文档为当年做本科毕业设计时写的，单纯的一个环境搭建记录，放出来，喜欢玩的小伙伴说不定可以参考一下。&lt;/p&gt;
    
    </summary>
    
      <category term="资料" scheme="https://wangjibao.com.cn/categories/%E8%B5%84%E6%96%99/"/>
    
    
      <category term="资料" scheme="https://wangjibao.com.cn/tags/%E8%B5%84%E6%96%99/"/>
    
  </entry>
  
  <entry>
    <title>算法课第三次作业</title>
    <link href="https://wangjibao.com.cn/2018/11/12/%E7%AE%97%E6%B3%95%E8%AF%BE%E7%AC%AC%E4%B8%89%E6%AC%A1%E4%BD%9C%E4%B8%9A/"/>
    <id>https://wangjibao.com.cn/2018/11/12/算法课第三次作业/</id>
    <published>2018-11-12T15:39:55.000Z</published>
    <updated>2018-11-13T17:17:47.819Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1、书面作业"><a href="#1、书面作业" class="headerlink" title="1、书面作业"></a>1、书面作业</h3><p>懒得将 latex 转成 markdown了，直接传个PDF得了。</p><a id="more"></a><div class="row">    <embed src="Algorithm3-Greedy.pdf" width="100%" height="550" type="application/pdf"></div><h3 id="5、Cross-the-river"><a href="#5、Cross-the-river" class="headerlink" title="5、Cross the river"></a>5、<a href="http://theory.ict.ac.cn/grad_oj/contest/4/problem/31" target="_blank" rel="noopener">Cross the river</a></h3><p>贪心的基本思想：最重的人和最轻的人如果不超载重，就一起过河，如何超重，就最重的人自己一条船单独过河。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> n,l;</span><br><span class="line">    <span class="keyword">int</span> weight[<span class="number">50005</span>];</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; l;</span><br><span class="line">    <span class="keyword">for</span>( <span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; i++ )&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>,weight+i);</span><br><span class="line">    &#125;</span><br><span class="line">    sort(weight,weight+n);</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>, left = <span class="number">0</span>, right = n<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span>( left&lt;=right )&#123;</span><br><span class="line">        ans++;</span><br><span class="line">        <span class="keyword">if</span>( weight[right]+weight[left] &lt;= l )&#123;</span><br><span class="line">            left++;</span><br><span class="line">            right--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            right--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6、Assign-banana-to-monkeys"><a href="#6、Assign-banana-to-monkeys" class="headerlink" title="6、Assign banana to monkeys"></a>6、<a href="http://theory.ict.ac.cn/grad_oj/contest/4/problem/32" target="_blank" rel="noopener">Assign banana to monkeys</a></h3><p>贪心的基本思路：先按照位置排序，位于第 i 个位置的猴子就拿第 i 个位置的香蕉就好。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> monkey[<span class="number">5000005</span>];</span><br><span class="line"><span class="keyword">int</span> banana[<span class="number">5000005</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">char</span> ch;</span><br><span class="line">    <span class="keyword">do</span>&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>,monkey+n);</span><br><span class="line">        n++;</span><br><span class="line">    &#125;<span class="keyword">while</span>( (ch=getchar())!=<span class="string">'\n'</span> );</span><br><span class="line">    sort(monkey, monkey+n);</span><br><span class="line"></span><br><span class="line">    n=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">do</span>&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>,banana+n);</span><br><span class="line">        n++;</span><br><span class="line">    &#125;<span class="keyword">while</span>( (ch=getchar())!=<span class="string">'\n'</span> );</span><br><span class="line">    sort( banana, banana+n );</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>( <span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; i++ )&#123;</span><br><span class="line">        ans = max( ans, <span class="built_in">abs</span>(monkey[i] - banana[i]) );</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;1、书面作业&quot;&gt;&lt;a href=&quot;#1、书面作业&quot; class=&quot;headerlink&quot; title=&quot;1、书面作业&quot;&gt;&lt;/a&gt;1、书面作业&lt;/h3&gt;&lt;p&gt;懒得将 latex 转成 markdown了，直接传个PDF得了。&lt;/p&gt;
    
    </summary>
    
      <category term="作业" scheme="https://wangjibao.com.cn/categories/%E4%BD%9C%E4%B8%9A/"/>
    
      <category term="算法课第一次作业" scheme="https://wangjibao.com.cn/categories/%E4%BD%9C%E4%B8%9A/%E7%AE%97%E6%B3%95%E8%AF%BE%E7%AC%AC%E4%B8%80%E6%AC%A1%E4%BD%9C%E4%B8%9A/"/>
    
    
      <category term="作业" scheme="https://wangjibao.com.cn/tags/%E4%BD%9C%E4%B8%9A/"/>
    
  </entry>
  
  <entry>
    <title>wireshark网络分析的艺术</title>
    <link href="https://wangjibao.com.cn/2018/11/07/wireshark%E7%BD%91%E7%BB%9C%E5%88%86%E6%9E%90%E7%9A%84%E8%89%BA%E6%9C%AF/"/>
    <id>https://wangjibao.com.cn/2018/11/07/wireshark网络分析的艺术/</id>
    <published>2018-11-07T08:21:17.000Z</published>
    <updated>2018-11-12T03:38:29.334Z</updated>
    
    <content type="html"><![CDATA[<p>1、Linux服务器在收到 SSH 访问请求时，会先查询该客户端 IP 所对应的 PTR 记录（ IP 反向解析，由 IP 地址 获得对应的DNS，常用在垃圾邮件过滤）。假如经过5秒钟还没有收到回复，就再发一次查询。如果第二次查询还是等了5秒还没回复，就彻底放弃查询。</p><p>解决方式： <code>cat /etc/ssh/sshd_config | grep -i usedns</code> ，如果显示 <code>usedns yes</code> ,将其设置成 <code>no</code>即可。</p><p> 其中 <code>grep</code>是文本处理工具，同 <code>sed</code>、<code>awk</code>被称为文本处理三剑客。<code>-i</code> 代表忽略大小写的区别（ignore)。</p><p>2、启用 <code>TCP SACK</code>（ selective acknowledgement) 功能，在大量丢包时，不需要每个重传包都确认一次。可以在 <code>ack</code> 数据包中，告知对方哪些包我已经收到了，比如说，当前 <code>ack = 100</code> ，包中的 <code>sack 字段等于 107--120</code>，那么可以一次性完成 <code>100--106</code> 号包的重传，节约时间。</p><p>3、延迟确认</p><p>当要发送一个 <code>ack</code> 数据包的时候，因为纯粹的ack数据包只是单纯的确认，不含有其他有用信息。启用延迟确认，当收到一个 <code>seq</code>时，不立即发送 <code>ack</code>，而是稍等一会，当本地有数据要发送时，将信息加在 <code>ack</code>数据包里，就一起带过去了，节省带宽。</p><p>4、数据接收方可以积累一些包才对发送方 <code>ack</code> 一次。</p><p>5、愚笨窗口综合症（silly window syndrome)—“小包问题“</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">纳格（Nagle)算法:</span><br><span class="line">if 有新数据要发送</span><br><span class="line">if 数据量超过 MSS (即一个 TCP 包所能携带的最大数据量，通常为 1500-20tcp头-20ip头)</span><br><span class="line">立即发送</span><br><span class="line">else</span><br><span class="line">if 之前发出去的数据尚未确认</span><br><span class="line">把新数据缓存起来，凑够 MSS 或等确认到达再发送</span><br><span class="line">else</span><br><span class="line">立即发送</span><br><span class="line">end if</span><br><span class="line">end if</span><br><span class="line">end if</span><br></pre></td></tr></table></figure><a id="more"></a><p>6、延迟确认和 nagle 算法不能一起用，容易造成网络延迟大的要命</p><p>7、虽然说是 TCP 的三次握手，四次挥手，但是有时候，四次挥手，并不一定就是4个数据包，有可能是3个，即中间的 2号包的 <code>ACK</code> 和3号包的 <code>FIN</code> 结合在一起，形成一个数据包。</p><p>8、NTLM（ NT LAN Manager）,一种身份认证协议</p><p><img src="/2018/11/07/wireshark网络分析的艺术/NTLM.png" alt=""></p><ul><li>客户端向服务器发送一个 NTLM 协商请求，然后服务器立即回复一个随机字符串作为 challenge。</li><li>客户端收到 challenge 之后，向服务器回复 用户名，以及两个 response(用hash过的用户密码对 challenge加密得到的)</li><li>服务器不知道如何验证真假，所以将 <code>challenge</code> 和 两个<code>response</code> 都转发给 域控<code>Domain Controller</code> ，让域控去帮忙验证真假。</li><li>域控收到后，也用 <code>hash</code>过的用户密码对 <code>challenge</code>进行加密。如果加密结果和 <code>reponse</code>一样，说明密码正确，身份验证通过。</li></ul><p>由于从数据包里就能看到 <code>challenge</code> 和 <code>response</code> ，算法也是固定的，所以并不安全。</p><p>9、Kerberos（安全认证协议）</p><p>认证过程如下图，<code>kerberos</code> 认证是个双向的过程，即<code>client</code>可以验证<code>server</code>，<code>server</code> 也可以认证 <code>client</code>。</p><p><img src="/2018/11/07/wireshark网络分析的艺术/kerberos.png" alt=""></p><p>$\blacksquare$ <strong>相关名词解释</strong></p><ul><li>KDC ( key distributed center ): 整个安全认证过程的票据生成管理服务，包括 AS 和 TGS 服务。</li><li>AS ( authentication service ): 为 client 生成TGT的服务。</li><li>TGS( ticket granting service ): 为 client 生成某个服务器的 ticket。</li><li>TGT ( ticket-granting ticket ): 用于获取 ticket 的票据。  </li></ul><p>$\blacksquare$ <strong>认证过程</strong></p><p>(1) client 向 KDC 中的 AS  发送数据，表明自己的身份，AS对client的身份进行验证，验证通过后返给 client一个 TGT.</p><p>(2) client 拿着这个 TGT，给TGS发送数据，说我想访问某个 server。然后TGS会将会话密钥$K_{client-server}$用 client master key加密后传送给client；与此同时，TGS也会将会话密钥$K_{client-server}$连同client的基本信息打包用server master key加密也发client，并经client转发给server，至此client与KDC的交互完成。</p><p>(3) client用自己的 master key 解密 TGS 传过来的第一个包，解密后获得会话密钥$K_{client-server}$，并用这个密钥加密自己的的信息和时间戳打包后传送给server。</p><p>(4) server会收到两个数据包，一个用会话密钥加密，一个用自己的master key加密，server先用自己的master<br>key解密获取会话密钥和一份关于client的信息，然后server拿到解密后获取到的会话密钥再解开另外一个数据包，获得另一份关于client的信息和时间戳，对比一下这两份数据，一样即可验证通过。</p><p>详细过程请参照：<a href="https://blog.csdn.net/yangyang19920306/article/details/51673460" target="_blank" rel="noopener">https://blog.csdn.net/yangyang19920306/article/details/51673460</a></p><p>10、<code>TCP Fast Retransmission</code> ，当发送方收到3个及以上 <code>[TCP Dup ACK]</code> 时，就立刻重传它。</p><p><code>[TCP window Full]</code> 和 <code>[TCP zerowindow]</code> ，前者表示这个包的发送方暂时没办法再发送数据了（比如说接收方之前告诉我，接收窗口是100，我把100个数据发送过去了，但是都没有收到回复，可能在去的途中，所以为了保险起见，我不能再接着发送了）。后者表示这个包的发送方没办法再接收数据了（告诉对方，我的接收窗口满了，别再发了）。</p><p>11、LSO（ large segment offload）</p><p>传统的网络工作方式是这样的：应用层把产生的数据交给TCP层，TCP层再根据MSS大小进行分段（有CPU负责）,然后再交给网卡。而启用LSO之后，TCP层就可以把大于MSS的数据块直接传给网卡，让网卡来负责分段的工作。其实在数据量较大时，数据分段计算校验和等简单操作也挺浪费CPU资源的。在计算机的网卡，高级设置里可以启用这一功能，如下图：</p><p><img src="/2018/11/07/wireshark网络分析的艺术/lso.png" alt=""></p><p>详细说明：<a href="https://www.cnblogs.com/tcicy/p/8442225.html" target="_blank" rel="noopener">https://www.cnblogs.com/tcicy/p/8442225.html</a></p><p>12、TCP中的拥塞控制机制</p><p><img src="/2018/11/07/wireshark网络分析的艺术/cwnd.png" alt=""></p><p>了解其中的 慢开始、拥塞避免、快重传、快恢复机制。</p><p>详细说明：<a href="https://blog.csdn.net/jtracydy/article/details/52366461" target="_blank" rel="noopener">https://blog.csdn.net/jtracydy/article/details/52366461</a></p><p>13、有一种 拥塞窗口的计算方式： $ cwnd = cwnd + MSS*\frac{n \times MSS}{cwnd} $ .  n 代表当前接收到的 ack 的个数，当每个数据片返回一个 ack的时候，这个算法是没问题的，即 $\frac{n \times MSS}{cwnd} = 1$ , 每次拥塞窗口增大一个，如上图中的“拥塞避免”状态。但是，我们之前说过，并不是每个数据片都会返回一个 ack 的，有可能攒了好几个才 ack 一次，所以，这种计算方法存在问题，解决方法是关掉网卡中的 <code>Large Receive Offload</code>。</p><p>14、前面逼逼了辣么多，真实环境抓几个包说道说道。</p><p><img src="/2018/11/07/wireshark网络分析的艺术/tcppcap.png" alt=""></p><p>就拿上面截图的数据包说事吧，数据包<a href="/download/tcppcap.pcap">下载链接</a></p><center>185.199.109.153 为服务器端，192.168.199.160 为 客户端。</center><p>(1) 通信过程详解</p><p>首先，<strong>1203号</strong>包服务器端发送了seq = 939400，len = 1460。</p><p>紧接着客户端回复 <strong>1204号包</strong>，说我已经收到了 ack = 939400+1460 = 940860号包。</p><p>正常情况下，服务器接着应该发送 seq = 940860的包给客户端，但是，在 <strong>1205号</strong>包中，客户端却收到了 seq = 942320 , len = 1460 的数据包，wireshark显示 [ TCP Previous segment not captured ]，说明前一个包（seq = 940860的数据包）可能丢了。</p><p>既然数据包丢了，客户端就得发送 ack 接着请求，所以，在<strong>1206号</strong>包中，客户端第二次要求服务器端发送 seq = 940860 的数据，wireshark显示 [ TCP Dup ACK 1204#1 ]，代表这是1204号包的再一次请求。</p><p>接着，<strong>1207号</strong>包，客户端收到了 seq = 943780，len = 1460 的数据包（ 942320 + 1460 = 943780） 。</p><p><strong>1208号</strong>包，还没收到 seq = 940860  的数据包，客户端那个气啊，妹的，我再一次重复要求服务器重发 ack = 940860，出现了[ TCP Dup ACK 1204#2 ].</p><p>在<strong>1209号</strong>包中，客户端收到了 seq = 946700 ， len = 1460 的数据包，现在问题比较大了，两个应该收到的数据包却没有收到，分别是 seq = 940860, seq = 945240 (1207中：943780+1460 = 945240）。同样的，wireshark显示 [ TCP Previous segment not captured  ]。</p><p>接着，问题得到了改善，在<strong>1210号</strong>包中，客户端收到了本应该早收到的 seq = 945240, len = 1460 的数据包。wireshark显示 [ TCP Out-Of-Order ]，这也说明了，在真实的网络环境中，数据包并不一定是按序到达的。</p><p>客户端收到了 seq = 945240 ，seq = 946700(945240+1460) 的数据包，应该发送确认，直到此时，那个 seq = 940860 的包还是没给我发来，丫丫的，在<strong>1211号</strong>包 和 <strong>1212号</strong>包中客户端再一次发送 ack = 940860，要求服务器发送 seq = 940860号包给我，wireshark显示[ TCP Dup ACK 1204#3 ]，[TCP Dup ACK 1204#4 ]。</p><p>在下面的<strong>1213</strong> ( seq = 946700+1460 = 948160 )、<strong>1214</strong>、<strong>1215</strong> (seq = 948160+1460 = 949620 )、<strong>1216</strong>、<strong>1217</strong> ( seq = 949620+1460 = 951080 )、<strong>1218</strong>号，6个数据包还是重演之前的画面，客户端收到的是后面的数据包，每收到一个包，就重复确认一次 ack = 940860, 于是出现了图中的 [ TCP Dup ACK 1204#5 ] 、 [ TCP Dup ACK 1204#6 ]、 [ TCP Dup ACK 1204#7 ] 。</p><p>最终，好现象终于出现，<strong>1219号</strong>包，服务器终于发来了盼望已久的 seq = 940860， len = 1460 。一起顺利，所有问题已经解决。由于是乱序到达的，wireshark显示 [ TCP Out-Of-Order ]。</p><p>在 <strong>1220号</strong>包中，客户端发送对 seq = 940860 的确认，因为之前已经接收到了 seq = 951080+1460 = 952540，所以此时就显示的 ack = 952540 。</p><p>接下来，一切正常。</p><p>(2) SACK字段展示</p><p><img src="/2018/11/07/wireshark网络分析的艺术/sackshow.png" alt=""></p><p>拿 1211 号数据包详细说一下之前提到的 <code>SACK</code> 字段。1211数据包是 ack 1209号数据包的吧。有个事实是：我本应该收到 seq = 940860 的，但是，从1205和1207号包中，我收到的是 seq = 942320, seq = 943780 ，所以此时，1211的TCP头部可选字段的 <code>sack : 942320---945240</code> (943780+1460 = 955240)。从1209号数据包中我收到的是 seq = 946700，所以 1211数据包的TCP头部字段记录第二个 <code>sack : 946700---948160</code> (946700+1460 = 948160) 。</p><p>在TCP的头部可选字段记录这个两个字段值，花掉了 20 字节，所以TCP的头部长度变成了 20 + 20 = 40 Bytes.</p><p>同样的，当客户端收到了 1210 号数据包的时候，是不是就把这两个字段中间空缺的那 1460 ( 946700-945240 = 1460 ) 字节给补上了。所以，在 <strong>1212号</strong> ack 数据包中，<code>sack : 942320---948160</code> ,如上图所示。</p><p>那么当之前没收到的 seq = 940860 也收到的时候，这个 sack字段就没啥意义了，直接没有了，如 1220号ack包展示的那样。到此，一切那么的完美。</p><p>sack字段在变化，同样的，ack 数据包的头部长度也在变化，如上图中： 74 &gt;&gt; 66 &gt;&gt; 54。每次 ack 都会 <del>浪费</del> 一定的带宽，所以，出现了下面的收到多个 seq ，客户端才 ack 一次。</p><p>(3) 之前说过，真实的环境中，并不会每个数据包都 ack 一次，如下图，在这里是每收到 2 个数据包才发送一个 ack。</p><p><img src="/2018/11/07/wireshark网络分析的艺术/tcppack.png" alt=""></p><p> 15、TCP在三次握手的时候，客户端与服务器之间会协商 MSS 的大小，防止应用层发送的数据在 IP 层被分片。虽然，分片有时候是不可控的，比如数据包中间经过路由器时，也有可能被路由器分片。</p><p>协商过程如下图：</p><p><img src="/2018/11/07/wireshark网络分析的艺术/MSS.png" alt=""></p><p>客户端说我的 MSS = 1460， 但是服务器说他的 MSS = 1370，所以，在接下来的数据包中，应用层的数据按照 MSS= 1370 的大小来传输。</p><p>16、通过如下命令构造分片的包</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ping &lt;ip&gt; -l 9000 -n 4</span><br></pre></td></tr></table></figure><p>其中的 <code>-l</code> 参数指定发送的 ping 包的大小，9000 Bytes，所以会被分片处理，如下图所示。 <code>-n</code>指定发送的包的个数，还可以使用 <code>-f</code>    参数，指定发送的包不允许分片，即 <code>DF = 1</code>。</p><p><img src="/2018/11/07/wireshark网络分析的艺术/ICMP.png" alt=""></p><p>可以看到，分片数据包的 <code>off</code> 偏移字段，客户端可以根据 <code>ID</code> 字段，识别这是属于哪一个数据的分片包。那么，客户端如何确定什么时候开始重组这些分片的数据包？可以根据分片数据包的 <code>MF</code> 字段，最后一个分片包的 <code>MF = 0</code> ，代表这是最后一个数据包了，后面没有数据了，这时，客户端就可以重组这些分片的数据包了。</p><p>有一种网络的攻击方式： 往客户端持续发送 <code>MF = 1</code> 的数据包，导致客户端一直缓存分片，导致内存耗尽。</p><p>17、TCP中避免拥塞的方式有： 接收端通过<strong>接收窗口</strong>的大小来通知发送端，告知其数据接收能力。同时，发送端</p><p>通过<strong>拥塞控制</strong>算法来动态调整自己的数据发送量。其中：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">当前数据发送量 = min( 接收窗口大小， 拥塞控制值大小 )</span><br></pre></td></tr></table></figure><p>18、因为TCP头中只给接收窗口预留了16个比特（因为当时设计的时候，全世界的带宽都很小）,这就意味着它最大只能表示$2^{16} - 1 = 65535$ 字节，网络发展到今天明显不够用啊。后来，想到了一个解决方案，在TCP三次握手的时候，在可选字段中告知对方一个叫 <code>window scale</code> 的值，对方将这个值当做 2 的指数，算出来的值再作为接收窗口的系数。有了这个系数，就可以把接收窗口扩展好多倍了。</p><p><img src="/2018/11/07/wireshark网络分析的艺术/WS.png" alt=""></p><p>从上图中可以看出，客户端告诉服务器，自己的 Win = 65535,放大倍数为 2 倍；接着服务器告诉客户端，自己的 Win = 13600, 放大倍数为 WS = 128 倍。</p><p>数据包详情如下图：</p><p><img src="/2018/11/07/wireshark网络分析的艺术/windowscale.png" alt=""></p><p>19、思考：一个服务器是如何使用 80 端口同时为多个客户端提供服务的？根据连接建立时创建的<strong>五元组</strong>区分。详细点可以看 <strong>多路 I/O复用 epoll</strong>。</p><p>20、在网络层，也就是IP层头部，有那么几个字段：<code>identification</code>、<code>flags</code>、<code>offset</code> 。因为IP层是无连接的，每产生一个数据报，<code>identification</code>就加 1 ，如果中途的路由器将其分片后，接收端可以根据 <code>flags</code> 中的 <code>MF</code>、<code>DF</code>字段以及<code>片偏移</code>字段，将同一个 <code>identification</code> 的数据报重新组装起来。</p><p>21、一种流量劫持的手段如下图所示：</p><p><img src="/2018/11/07/wireshark网络分析的艺术/dns.png" alt=""></p><p>实线代表真实的流量，虚线代表劫持的流量。实现的原理就是，我假的服务比你真的服务先响应客户端，这样，等到真的数据来的时候，就会被用户无情的丢弃掉了。</p><p>可以通过查看数据包中的 <code>TTL</code> 值，分析流量是否存在被劫持的可能性。</p><p>22、HTTP &gt;&gt; HTTP1.1 &gt;&gt; SPDY &gt;&gt; HTTP2.0     QUIC(基于UDP)</p><p>23、<code>[ TCP zerowindow ]</code> 表示这个包的发送方已经没有办法再<strong>接收</strong>数据了，对应包中显示 <code>win = 0</code> 。</p><p><code>[ TCP window Full ]</code> 表示这个包的发送方暂时没有办法再<strong>发送</strong>数据了，已经把对方声称的接收窗口已经发满了确没收到ack，只能先暂停。<del>计算在途字节数</del></p><p>24、书上午看完了，总得来说，作业没有在刻意的讲述知识点，通过一个个案例，真实的说明网络知识是如何应用到现实生活的，内容比较基础，对初学者来说不错的书！</p><p>屁股后面跟着一堆作业，就这样吧。找个时间，读一下 <code>tshark</code> 的官方文档，感觉功能很强，用得好的话可以省很多事。<a href="https://www.wireshark.org/docs/man-pages/tshark.html" target="_blank" rel="noopener">https://www.wireshark.org/docs/man-pages/tshark.html</a></p><p>之前当当搞活动，加上双十一，买了好多书，下一本：《python黑帽子 黑客与渗透测试编程之道》。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;1、Linux服务器在收到 SSH 访问请求时，会先查询该客户端 IP 所对应的 PTR 记录（ IP 反向解析，由 IP 地址 获得对应的DNS，常用在垃圾邮件过滤）。假如经过5秒钟还没有收到回复，就再发一次查询。如果第二次查询还是等了5秒还没回复，就彻底放弃查询。&lt;/p&gt;
&lt;p&gt;解决方式： &lt;code&gt;cat /etc/ssh/sshd_config | grep -i usedns&lt;/code&gt; ，如果显示 &lt;code&gt;usedns yes&lt;/code&gt; ,将其设置成 &lt;code&gt;no&lt;/code&gt;即可。&lt;/p&gt;
&lt;p&gt; 其中 &lt;code&gt;grep&lt;/code&gt;是文本处理工具，同 &lt;code&gt;sed&lt;/code&gt;、&lt;code&gt;awk&lt;/code&gt;被称为文本处理三剑客。&lt;code&gt;-i&lt;/code&gt; 代表忽略大小写的区别（ignore)。&lt;/p&gt;
&lt;p&gt;2、启用 &lt;code&gt;TCP SACK&lt;/code&gt;（ selective acknowledgement) 功能，在大量丢包时，不需要每个重传包都确认一次。可以在 &lt;code&gt;ack&lt;/code&gt; 数据包中，告知对方哪些包我已经收到了，比如说，当前 &lt;code&gt;ack = 100&lt;/code&gt; ，包中的 &lt;code&gt;sack 字段等于 107--120&lt;/code&gt;，那么可以一次性完成 &lt;code&gt;100--106&lt;/code&gt; 号包的重传，节约时间。&lt;/p&gt;
&lt;p&gt;3、延迟确认&lt;/p&gt;
&lt;p&gt;当要发送一个 &lt;code&gt;ack&lt;/code&gt; 数据包的时候，因为纯粹的ack数据包只是单纯的确认，不含有其他有用信息。启用延迟确认，当收到一个 &lt;code&gt;seq&lt;/code&gt;时，不立即发送 &lt;code&gt;ack&lt;/code&gt;，而是稍等一会，当本地有数据要发送时，将信息加在 &lt;code&gt;ack&lt;/code&gt;数据包里，就一起带过去了，节省带宽。&lt;/p&gt;
&lt;p&gt;4、数据接收方可以积累一些包才对发送方 &lt;code&gt;ack&lt;/code&gt; 一次。&lt;/p&gt;
&lt;p&gt;5、愚笨窗口综合症（silly window syndrome)—“小包问题“&lt;/p&gt;
&lt;figure class=&quot;highlight shell&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;纳格（Nagle)算法:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;if 有新数据要发送&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	if 数据量超过 MSS (即一个 TCP 包所能携带的最大数据量，通常为 1500-20tcp头-20ip头)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		立即发送&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	else&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		if 之前发出去的数据尚未确认&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;			把新数据缓存起来，凑够 MSS 或等确认到达再发送&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		else&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;			立即发送&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		end if&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	end if&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;end if&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="笔记" scheme="https://wangjibao.com.cn/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="笔记" scheme="https://wangjibao.com.cn/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>VSCode配置Latex</title>
    <link href="https://wangjibao.com.cn/2018/11/05/VSCode%E9%85%8D%E7%BD%AELatex/"/>
    <id>https://wangjibao.com.cn/2018/11/05/VSCode配置Latex/</id>
    <published>2018-11-05T01:40:31.000Z</published>
    <updated>2018-11-05T02:44:26.521Z</updated>
    
    <content type="html"><![CDATA[<p>因为CTeX套装自带WinEdt编辑器难用、收费且不能实时编译显示pdf效果，本笔记主要记录如何在VSCode中编辑Tex文件，实现代码自动补全及实时查看文本编辑效果等功能。</p><h4 id="1、软件下载"><a href="#1、软件下载" class="headerlink" title="1、软件下载"></a>1、软件下载</h4><p>CTEX下载地址：<a href="http://www.ctex.org/HomePage，建议下载完整版套装。" target="_blank" rel="noopener">http://www.ctex.org/HomePage，建议下载完整版套装。</a></p><p>VSCode下载地址：<a href="https://code.visualstudio.com/" target="_blank" rel="noopener">https://code.visualstudio.com/</a></p><h4 id="2、软件配置"><a href="#2、软件配置" class="headerlink" title="2、软件配置"></a>2、软件配置</h4><h5 id="在VSCode中安装对应的插件"><a href="#在VSCode中安装对应的插件" class="headerlink" title="在VSCode中安装对应的插件"></a>在VSCode中安装对应的插件</h5><p><img src="/2018/11/05/VSCode配置Latex/plugin.png" alt=""></p><h5 id="更改配置文件"><a href="#更改配置文件" class="headerlink" title="更改配置文件"></a>更改配置文件</h5><p>在<code>file &gt;&gt; preferences &gt;&gt; setting &gt;&gt; User Setting &gt;&gt; Extensions &gt;&gt; LaTex Workshop configuration &gt;&gt; active</code> 中，打开 <code>Edit in setting.json</code> 文件。在文件中添加如下字段：</p><a id="more"></a><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">"latex-workshop.latex.recipes": [&#123;</span><br><span class="line">"name": "xelatex",</span><br><span class="line">"tools": ["xelatex"]</span><br><span class="line">&#125;, &#123;</span><br><span class="line">"name": "latexmk",</span><br><span class="line">"tools": ["latexmk"]</span><br><span class="line">&#125;, &#123;</span><br><span class="line">"name": "pdflatex -&gt; bibtex -&gt; pdflatex*2",</span><br><span class="line">"tools": ["pdflatex", "bibtex", "pdflatex", "pdflatex"]</span><br><span class="line">&#125;],</span><br></pre></td></tr></table></figure><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">"latex-workshop.latex.tools": [&#123;</span><br><span class="line">"name": "latexmk",</span><br><span class="line">"command": "latexmk",</span><br><span class="line">"args": ["-synctex=1", "-interaction=nonstopmode", "-file-line-error", "-pdf", "%DOC%"]</span><br><span class="line">&#125;, &#123;</span><br><span class="line">"name": "xelatex",</span><br><span class="line">"command": "xelatex",</span><br><span class="line">"args": ["-synctex=1", "-interaction=nonstopmode", "-file-line-error", "%DOC%"]</span><br><span class="line">&#125;, &#123;</span><br><span class="line">"name": "pdflatex",</span><br><span class="line">"command": "pdflatex",</span><br><span class="line">"args": ["-synctex=1", "-interaction=nonstopmode", "-file-line-error", "%DOC%"]</span><br><span class="line">&#125;, &#123;</span><br><span class="line">"name": "bibtex",</span><br><span class="line">"command": "bibtex",</span><br><span class="line">"args": ["%DOCFILE%"]</span><br><span class="line">&#125;],</span><br></pre></td></tr></table></figure><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">"latex-workshop.view.pdf.viewer": "tab",</span><br></pre></td></tr></table></figure><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">"latex-workshop.latex.clean.fileTypes": ["*.aux", "*.bbl", "*.blg", "*.idx", "*.ind", "*.lof", "*.lot", "*.out", "*.toc", "*.acn", "*.acr", "*.alg", "*.glg", "*.glo", "*.gls", "*.ist", "*.fls", "*.log", "*.fdb_latexmk"],</span><br></pre></td></tr></table></figure><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">"latex-workshop.latex.clean.enabled": false,</span><br></pre></td></tr></table></figure><p>添加后的效果如下图所示：</p><p><img src="/2018/11/05/VSCode配置Latex/jsoncode.png" alt=""></p><h4 id="3、开启自动保存，实时查看编辑效果"><a href="#3、开启自动保存，实时查看编辑效果" class="headerlink" title="3、开启自动保存，实时查看编辑效果"></a>3、开启自动保存，实时查看编辑效果</h4><p>在 <code>file</code>中将 <code>auto saved</code>勾选上即可。效果如下图：</p><p><img src="/2018/11/05/VSCode配置Latex/show.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;因为CTeX套装自带WinEdt编辑器难用、收费且不能实时编译显示pdf效果，本笔记主要记录如何在VSCode中编辑Tex文件，实现代码自动补全及实时查看文本编辑效果等功能。&lt;/p&gt;
&lt;h4 id=&quot;1、软件下载&quot;&gt;&lt;a href=&quot;#1、软件下载&quot; class=&quot;headerlink&quot; title=&quot;1、软件下载&quot;&gt;&lt;/a&gt;1、软件下载&lt;/h4&gt;&lt;p&gt;CTEX下载地址：&lt;a href=&quot;http://www.ctex.org/HomePage，建议下载完整版套装。&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://www.ctex.org/HomePage，建议下载完整版套装。&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;VSCode下载地址：&lt;a href=&quot;https://code.visualstudio.com/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://code.visualstudio.com/&lt;/a&gt;&lt;/p&gt;
&lt;h4 id=&quot;2、软件配置&quot;&gt;&lt;a href=&quot;#2、软件配置&quot; class=&quot;headerlink&quot; title=&quot;2、软件配置&quot;&gt;&lt;/a&gt;2、软件配置&lt;/h4&gt;&lt;h5 id=&quot;在VSCode中安装对应的插件&quot;&gt;&lt;a href=&quot;#在VSCode中安装对应的插件&quot; class=&quot;headerlink&quot; title=&quot;在VSCode中安装对应的插件&quot;&gt;&lt;/a&gt;在VSCode中安装对应的插件&lt;/h5&gt;&lt;p&gt;&lt;img src=&quot;/2018/11/05/VSCode配置Latex/plugin.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h5 id=&quot;更改配置文件&quot;&gt;&lt;a href=&quot;#更改配置文件&quot; class=&quot;headerlink&quot; title=&quot;更改配置文件&quot;&gt;&lt;/a&gt;更改配置文件&lt;/h5&gt;&lt;p&gt;在&lt;code&gt;file &amp;gt;&amp;gt; preferences &amp;gt;&amp;gt; setting &amp;gt;&amp;gt; User Setting &amp;gt;&amp;gt; Extensions &amp;gt;&amp;gt; LaTex Workshop configuration &amp;gt;&amp;gt; active&lt;/code&gt; 中，打开 &lt;code&gt;Edit in setting.json&lt;/code&gt; 文件。在文件中添加如下字段：&lt;/p&gt;
    
    </summary>
    
      <category term="笔记" scheme="https://wangjibao.com.cn/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="笔记" scheme="https://wangjibao.com.cn/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>数据科学导论作业</title>
    <link href="https://wangjibao.com.cn/2018/11/04/%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E5%AF%BC%E8%AE%BA%E4%BD%9C%E4%B8%9A/"/>
    <id>https://wangjibao.com.cn/2018/11/04/数据科学导论作业/</id>
    <published>2018-11-04T07:56:57.000Z</published>
    <updated>2018-11-19T13:24:18.626Z</updated>
    
    <content type="html"><![CDATA[<p>第一次作业：<a href="/download/数据科学导论第一次作业.rar">点击下载</a></p><p>怎么说，对这门课就是默默告诉自己，习惯就好。默默贴个 github 地址：</p><p><a href="https://github.com/justmarkham/DAT8" target="_blank" rel="noopener">https://github.com/justmarkham/DAT8</a></p><p>第二次作业：<a href="/download/数据科学导论第二次作业.rar">点击下载</a></p><p>同样，还是贴几个<code>github</code>链接地址：</p><p><a href="https://github.com/lamalor/ds100/blob/182feda62685b0988f4b4afb52c85256f4ac7d92/hw6/hw6.ipynb" target="_blank" rel="noopener">https://github.com/lamalor/ds100/blob/182feda62685b0988f4b4afb52c85256f4ac7d92/hw6/hw6.ipynb</a></p><p><a href="https://github.com/Dhanush123/data100/blob/master/hw6/hw6.ipynb" target="_blank" rel="noopener">https://github.com/Dhanush123/data100/blob/master/hw6/hw6.ipynb</a></p><p><a href="https://github.com/iewaij/introDataScience/blob/1eb96b44721ed6cc40761a7e3003f11a5c243cc3/legacy/material/homework/DS100%20SP17/hw5/hw5_solution.ipynb" target="_blank" rel="noopener">https://github.com/iewaij/introDataScience/blob/1eb96b44721ed6cc40761a7e3003f11a5c243cc3/legacy/material/homework/DS100%20SP17/hw5/hw5_solution.ipynb</a></p><p><a href="https://github.com/dovahcrow/ds100/blob/30d629246c87f2fafbf10c155545c30344be23e6/sp17/hw/hw5/hw5_solution.ipynb" target="_blank" rel="noopener">https://github.com/dovahcrow/ds100/blob/30d629246c87f2fafbf10c155545c30344be23e6/sp17/hw/hw5/hw5_solution.ipynb</a></p><h4 id="1、更改juypter默认工作路径"><a href="#1、更改juypter默认工作路径" class="headerlink" title="1、更改juypter默认工作路径"></a>1、更改juypter默认工作路径</h4><p>在 <code>anaconda prompt</code> 中执行命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jupyter notebook --generate-config</span><br></pre></td></tr></table></figure><p>即可查看 <code>jupyter_notebook_config.py</code> 配置文件的位置，打开配置文件 <code>jupyter_notebook_config.py</code>，搜索关键字 <code>notebook_dir</code> ，将值设置为自己想要的工作目录并取消注释即可（注意路径中不能有中文）；</p><p><img src="/2018/11/04/数据科学导论作业/juypter.png" alt=""></p><p>然后右击 <code>jupyter notebook</code> 快捷方式，将属性中的 “目标” 字段的值，去掉末尾的 <code>%USERPROFILE%</code> ，点击 <code>应用</code>，<code>确定</code>即可。</p><a id="more"></a><h4 id="2、jupyter使用anaconda虚拟python环境"><a href="#2、jupyter使用anaconda虚拟python环境" class="headerlink" title="2、jupyter使用anaconda虚拟python环境"></a>2、jupyter使用anaconda虚拟python环境</h4><p>打开 <code>anaconda prompt</code>，激活之前创建的某个python虚拟环境，在<strong>当前虚拟环境</strong>中执行 <code>conda install nb_conda</code>。重启 <code>juypter notebook</code> 服务器即可出现想要的虚拟环境 <code>kernal</code> 。</p><h4 id="3、jupyter两种工作模式及其快捷键"><a href="#3、jupyter两种工作模式及其快捷键" class="headerlink" title="3、jupyter两种工作模式及其快捷键"></a>3、jupyter两种工作模式及其快捷键</h4><ul><li>分为命令模式（边框蓝色) 和 编辑模式(边框绿色)</li><li>命令模式中， <code>M</code> 进入markdown编辑模式， <code>Y</code> 进入代码编辑模式</li></ul><h4 id="4、代码自动补全"><a href="#4、代码自动补全" class="headerlink" title="4、代码自动补全"></a>4、代码自动补全</h4><p>注意，下面的所有操作是在 <code>base</code> 环境中安装的，在其他虚拟环境中安装好像并不起作用。</p><p>安装<strong>nbextensions</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pip install jupyter_contrib_nbextensions</span><br><span class="line">jupyter contrib nbextension install --user</span><br></pre></td></tr></table></figure><p>安装<strong>nbextensions_configurator</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pip install jupyter_nbextensions_configurator</span><br><span class="line">jupyter nbextensions_configurator enable --user</span><br></pre></td></tr></table></figure><p>重启 jupyter，在弹出的主页面里，能看到增加了一个Nbextensions标签页，在这个页面里，勾选Hinterland即启用了代码自动补全。</p><h4 id="5、pandas教程-pan-el-da-ta-s"><a href="#5、pandas教程-pan-el-da-ta-s" class="headerlink" title="5、pandas教程[pan(el)-da(ta)-s]"></a>5、pandas教程[pan(el)-da(ta)-s]</h4><p>1、pandas中的数据分为三种： 一维数据 Series、二维数据 DataFrame、以及三维数据 Panel。</p><ul><li><p>Series相当于一个字典。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">data = np.random.randn(<span class="number">5</span>) <span class="comment"># 一维随机数</span></span><br><span class="line">index = [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>, <span class="string">'d'</span>, <span class="string">'e'</span>] <span class="comment"># 指定索引</span></span><br><span class="line">s = pd.Series(data, index)</span><br></pre></td></tr></table></figure></li><li><p>二维数据，1. 带Series的字典  2.列表构成的字典   3.带字典的列表</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">d = &#123;<span class="string">'one'</span> : pd.Series([<span class="number">1.</span>, <span class="number">2.</span>, <span class="number">3.</span>], index=[<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>]),<span class="string">'two'</span> : pd.Series([<span class="number">1.</span>, <span class="number">2.</span>, <span class="number">3.</span>, <span class="number">4.</span>], index=[<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>, <span class="string">'d'</span>])&#125;  <span class="comment">#one做列</span></span><br><span class="line">d = &#123;<span class="string">'one'</span> : [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>], <span class="string">'two'</span> : [<span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>]&#125;   <span class="comment">#one做列</span></span><br><span class="line">d = [&#123;<span class="string">'a'</span>: <span class="number">1</span>, <span class="string">'b'</span>: <span class="number">2</span>&#125;, &#123;<span class="string">'a'</span>: <span class="number">5</span>, <span class="string">'b'</span>: <span class="number">10</span>, <span class="string">'c'</span>: <span class="number">20</span>&#125;]  <span class="comment">#a,b,c做列</span></span><br><span class="line">df = pd.DataFrame(d)  <span class="comment"># 新建 DataFrame</span></span><br><span class="line">print(df）</span><br></pre></td></tr></table></figure></li></ul><p>列的选择，添加与删除</p><p>​    df[‘列名’]      df.pop(‘列名’)      df.insert(添加列位置索引序号, ‘添加列名’, 数值)</p><p>行的选取，列的选取，块的选取</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">df.index    df.columns   df.values   df.values    df.describes()   df.T    df.dtypes</span><br><span class="line">df.sort_index()    df.sort_values()</span><br><span class="line">df.head()   df.tail()</span><br><span class="line">df[行选取]   df[列名]   df.loc[[行选取],[列选取]]</span><br><span class="line">#df.iloc   df.iat</span><br><span class="line">df.drop(&apos;行名&apos;)</span><br><span class="line">df.append()</span><br><span class="line">df.shape   df.size   df.ndim    </span><br><span class="line">df.sum(axis=1 =0 =default)     df.mean()  df.std()</span><br><span class="line">表明智函数应用：pipe()   #对所有元素起作用</span><br><span class="line">行或列函数应用：apply()  #对行或者列起作用</span><br><span class="line">元素函数应用：applymap() #对某一个元素起作用</span><br></pre></td></tr></table></figure><p>python中使用  <code>type(var)</code> 查看变量的数据类型</p><h4 id="6、juypter显示行号"><a href="#6、juypter显示行号" class="headerlink" title="6、juypter显示行号"></a>6、juypter显示行号</h4><p><code>view &gt;&gt; toggle line numbers</code></p><h4 id="7、juypter中matplotlib画图中文显示乱码"><a href="#7、juypter中matplotlib画图中文显示乱码" class="headerlink" title="7、juypter中matplotlib画图中文显示乱码"></a>7、juypter中matplotlib画图中文显示乱码</h4><p><a href="https://blog.csdn.net/u014465934/article/details/80377470" target="_blank" rel="noopener">https://blog.csdn.net/u014465934/article/details/80377470</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;第一次作业：&lt;a href=&quot;/download/数据科学导论第一次作业.rar&quot;&gt;点击下载&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;怎么说，对这门课就是默默告诉自己，习惯就好。默默贴个 github 地址：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/justmarkham/DAT8&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/justmarkham/DAT8&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;第二次作业：&lt;a href=&quot;/download/数据科学导论第二次作业.rar&quot;&gt;点击下载&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;同样，还是贴几个&lt;code&gt;github&lt;/code&gt;链接地址：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/lamalor/ds100/blob/182feda62685b0988f4b4afb52c85256f4ac7d92/hw6/hw6.ipynb&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/lamalor/ds100/blob/182feda62685b0988f4b4afb52c85256f4ac7d92/hw6/hw6.ipynb&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/Dhanush123/data100/blob/master/hw6/hw6.ipynb&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/Dhanush123/data100/blob/master/hw6/hw6.ipynb&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/iewaij/introDataScience/blob/1eb96b44721ed6cc40761a7e3003f11a5c243cc3/legacy/material/homework/DS100%20SP17/hw5/hw5_solution.ipynb&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/iewaij/introDataScience/blob/1eb96b44721ed6cc40761a7e3003f11a5c243cc3/legacy/material/homework/DS100%20SP17/hw5/hw5_solution.ipynb&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/dovahcrow/ds100/blob/30d629246c87f2fafbf10c155545c30344be23e6/sp17/hw/hw5/hw5_solution.ipynb&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/dovahcrow/ds100/blob/30d629246c87f2fafbf10c155545c30344be23e6/sp17/hw/hw5/hw5_solution.ipynb&lt;/a&gt;&lt;/p&gt;
&lt;h4 id=&quot;1、更改juypter默认工作路径&quot;&gt;&lt;a href=&quot;#1、更改juypter默认工作路径&quot; class=&quot;headerlink&quot; title=&quot;1、更改juypter默认工作路径&quot;&gt;&lt;/a&gt;1、更改juypter默认工作路径&lt;/h4&gt;&lt;p&gt;在 &lt;code&gt;anaconda prompt&lt;/code&gt; 中执行命令：&lt;/p&gt;
&lt;figure class=&quot;highlight shell&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;jupyter notebook --generate-config&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;即可查看 &lt;code&gt;jupyter_notebook_config.py&lt;/code&gt; 配置文件的位置，打开配置文件 &lt;code&gt;jupyter_notebook_config.py&lt;/code&gt;，搜索关键字 &lt;code&gt;notebook_dir&lt;/code&gt; ，将值设置为自己想要的工作目录并取消注释即可（注意路径中不能有中文）；&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/2018/11/04/数据科学导论作业/juypter.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;然后右击 &lt;code&gt;jupyter notebook&lt;/code&gt; 快捷方式，将属性中的 “目标” 字段的值，去掉末尾的 &lt;code&gt;%USERPROFILE%&lt;/code&gt; ，点击 &lt;code&gt;应用&lt;/code&gt;，&lt;code&gt;确定&lt;/code&gt;即可。&lt;/p&gt;
    
    </summary>
    
      <category term="作业" scheme="https://wangjibao.com.cn/categories/%E4%BD%9C%E4%B8%9A/"/>
    
      <category term="数据科学导论大作业" scheme="https://wangjibao.com.cn/categories/%E4%BD%9C%E4%B8%9A/%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E5%AF%BC%E8%AE%BA%E5%A4%A7%E4%BD%9C%E4%B8%9A/"/>
    
    
      <category term="作业" scheme="https://wangjibao.com.cn/tags/%E4%BD%9C%E4%B8%9A/"/>
    
  </entry>
  
  <entry>
    <title>网络数据挖掘作业</title>
    <link href="https://wangjibao.com.cn/2018/10/31/%E7%BD%91%E7%BB%9C%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98%E4%BD%9C%E4%B8%9A/"/>
    <id>https://wangjibao.com.cn/2018/10/31/网络数据挖掘作业/</id>
    <published>2018-10-30T16:53:35.000Z</published>
    <updated>2018-11-04T17:02:33.423Z</updated>
    
    <content type="html"><![CDATA[<p>NMF(非负矩阵分解)，nature论文原文：</p><a id="more"></a><div class="row">    <embed src="1861-algorithms-for-non-negative-matrix-factorization.pdf" width="100%" height="550" type="application/pdf"></div><p>个人理解PPT：</p><div class="row">    <embed src="网络数据挖掘.pdf" width="100%" height="550" type="application/pdf"></div>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;NMF(非负矩阵分解)，nature论文原文：&lt;/p&gt;
    
    </summary>
    
      <category term="作业" scheme="https://wangjibao.com.cn/categories/%E4%BD%9C%E4%B8%9A/"/>
    
      <category term="网络数据挖掘作业" scheme="https://wangjibao.com.cn/categories/%E4%BD%9C%E4%B8%9A/%E7%BD%91%E7%BB%9C%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98%E4%BD%9C%E4%B8%9A/"/>
    
    
      <category term="作业" scheme="https://wangjibao.com.cn/tags/%E4%BD%9C%E4%B8%9A/"/>
    
  </entry>
  
  <entry>
    <title>算法课第二次作业</title>
    <link href="https://wangjibao.com.cn/2018/10/28/%E7%AE%97%E6%B3%95%E8%AF%BE%E7%AC%AC%E4%BA%8C%E6%AC%A1%E4%BD%9C%E4%B8%9A/"/>
    <id>https://wangjibao.com.cn/2018/10/28/算法课第二次作业/</id>
    <published>2018-10-27T16:22:15.000Z</published>
    <updated>2018-11-04T16:58:50.558Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一、Money-robbing"><a href="#一、Money-robbing" class="headerlink" title="一、Money robbing"></a>一、Money robbing</h3><h4 id="1、optimal-substructure-and-DP-equation"><a href="#1、optimal-substructure-and-DP-equation" class="headerlink" title="1、optimal substructure and DP equation"></a>1、optimal substructure and DP equation</h4><p>对于第 i 家，有两种选择，抢或者不抢。如果抢第 i 家，那么最大收益为：value[i] + 抢前 i-2 家的最优收益； 如果第 i 家不抢，那么最大收益为：抢前 i-1 家的最优收益。</p><p>状态转移方程可写为：<br>$$<br>dp[i] = max( dp[i-1], dp[i-2]+value[i] )<br>$$</p><h4 id="2、-pseudo-code"><a href="#2、-pseudo-code" class="headerlink" title="2、 pseudo-code"></a>2、 pseudo-code</h4><p><a href="https://leetcode-cn.com/problems/house-robber/description/" target="_blank" rel="noopener">LeetCode 198题</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">rob</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>( nums.size()==<span class="number">0</span> )</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>( nums.size()==<span class="number">1</span> )</span><br><span class="line">            <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; dp(nums.size(),<span class="number">0</span>);</span><br><span class="line">        dp[<span class="number">0</span>] = nums[<span class="number">0</span>];</span><br><span class="line">        dp[<span class="number">1</span>] = max( nums[<span class="number">0</span>], nums[<span class="number">1</span>] );</span><br><span class="line">        <span class="keyword">for</span>( <span class="keyword">int</span> i=<span class="number">2</span>; i&lt;nums.size(); i++ )&#123;</span><br><span class="line">            dp[i] = max( dp[i<span class="number">-1</span>], dp[i<span class="number">-2</span>]+nums[i] );</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[nums.size()<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><a id="more"></a><h4 id="3、-correctness-of-algorithm"><a href="#3、-correctness-of-algorithm" class="headerlink" title="3、 correctness of algorithm"></a>3、 correctness of algorithm</h4><p>如果暴力求解的话，每一家都有可能抢或者不抢，枚举每一种可能性，那么总的时间复杂度为 $O(2^n)$ ，且最后算出来的最优解一定是正确的。现在，我们采用动态规划思想中的 memory 数组，记录前 i-1 家的最优值，当计算第 i 家最优值时，其依赖的 <code>OPT[i-1]</code> 和 <code>OPT[i-2]</code> 已经求出，可直接计算当前最优值，故算法是正确的。</p><h4 id="4、-complexity-of-algorithm"><a href="#4、-complexity-of-algorithm" class="headerlink" title="4、 complexity of algorithm"></a>4、 complexity of algorithm</h4><p>代码中的 dp 数组，每个元素只计算了一遍，故算法的时间复杂度为 $ O(n) $。</p><p>注：</p><p>当房屋变成一个环的时候，也就是相当于在原有问题上添加了一个限制条件：第<code>1</code>家和第<code>n</code>家不能同时抢。那么，分别计算抢第二家到最后一家与抢第一家到倒数第二家的最大值，取两个值中更大的那个就是结果。</p><p><a href="https://leetcode-cn.com/problems/house-robber-ii/description/" target="_blank" rel="noopener">LeetCode 213题</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">rob</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>( nums.size()==<span class="number">0</span> )</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>( nums.size()==<span class="number">1</span> )</span><br><span class="line">            <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">return</span> max( func(nums, <span class="number">0</span>), func(nums, nums.size()<span class="number">-1</span> ));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">func</span><span class="params">( <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; nums, <span class="keyword">int</span> pos )</span></span>&#123;</span><br><span class="line">        nums.erase(nums.begin()+pos);</span><br><span class="line">        <span class="keyword">if</span>( nums.size()==<span class="number">0</span> )</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>( nums.size()==<span class="number">1</span> )</span><br><span class="line">            <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; dp(nums.size(),<span class="number">0</span>);</span><br><span class="line">        dp[<span class="number">0</span>] = nums[<span class="number">0</span>];</span><br><span class="line">        dp[<span class="number">1</span>] = max( nums[<span class="number">0</span>], nums[<span class="number">1</span>] );</span><br><span class="line">        <span class="keyword">for</span>( <span class="keyword">int</span> i=<span class="number">2</span>; i&lt;nums.size(); i++ )&#123;</span><br><span class="line">            dp[i] = max( dp[i<span class="number">-1</span>], dp[i<span class="number">-2</span>]+nums[i] );</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[nums.size()<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="二、Node-selection"><a href="#二、Node-selection" class="headerlink" title="二、Node selection"></a>二、Node selection</h3><h4 id="1、optimal-substructure-and-DP-equation-1"><a href="#1、optimal-substructure-and-DP-equation-1" class="headerlink" title="1、optimal substructure and DP equation"></a>1、optimal substructure and DP equation</h4><p>对于当前根节点，有两种可能性，选取或者不选取。如果选取了当前的根节点，那么其孩子节点就不能选取，即最优值变为：root-&gt;value + 4个孙子的最优值之和； 如果当前根节点没有选取，最优值变为：两个孩子节点最优值之和。</p><p>给定任意一个根，假设我们能够得到当前根选取与不选取的最优值，结果保存在一个长度为2的数组里，array[0]代表根节点不选取，array[1]代表根节点选取，那么最优解为：</p><p><img src="/2018/10/28/算法课第二次作业/form1.png" alt=""></p><h4 id="2、-pseudo-code-1"><a href="#2、-pseudo-code-1" class="headerlink" title="2、 pseudo-code"></a>2、 pseudo-code</h4><p><a href="https://leetcode-cn.com/problems/house-robber-iii/description/" target="_blank" rel="noopener">LeetCode 337题</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">rob</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ans = solve( root );</span><br><span class="line">        <span class="keyword">return</span> max( ans[<span class="number">0</span>], ans[<span class="number">1</span>] );</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; solve( TreeNode* root )&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ans(<span class="number">2</span>,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span>( !root )</span><br><span class="line">            <span class="keyword">return</span> ans;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; left_ans = solve( root-&gt;left);</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; right_ans = solve( root-&gt;right );</span><br><span class="line">        ans[<span class="number">0</span>] = max( left_ans[<span class="number">0</span>], left_ans[<span class="number">1</span>] ) + max( right_ans[<span class="number">0</span>], right_ans[<span class="number">1</span>] ); <span class="comment">//根节点不选</span></span><br><span class="line">        ans[<span class="number">1</span>] = root-&gt;val + left_ans[<span class="number">0</span>] + right_ans[<span class="number">0</span>]; <span class="comment">//选择根节点</span></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="3、correctness-of-algorithm"><a href="#3、correctness-of-algorithm" class="headerlink" title="3、correctness of algorithm"></a>3、correctness of algorithm</h4><p>当前节点的最优值，依赖于其儿子节点的最优值（当前节点没选，最优值等于选其左孩子节点最优值+选其右孩子节点最优值）或其孙子节点的最优值（选取了当前节点，最优值等于根节点值+其左孩子不选左根的最优值+右孩子不选右根的最优值），由此可知算法的正确性。</p><h4 id="4、complexity-of-algorithm"><a href="#4、complexity-of-algorithm" class="headerlink" title="4、complexity of algorithm"></a>4、complexity of algorithm</h4><p>整个算法相当于一个深度优先搜索（DFS），树中的每个节点都会遍历一次，故算法的时间复杂度为$O(n)$。</p><h3 id="三、Decoding"><a href="#三、Decoding" class="headerlink" title="三、Decoding"></a>三、Decoding</h3><h4 id="1、optimal-substructure-and-DP-equation-2"><a href="#1、optimal-substructure-and-DP-equation-2" class="headerlink" title="1、optimal substructure and DP equation"></a>1、optimal substructure and DP equation</h4><p><code>dp[i]</code>表示从字符<code>0~i</code>的字符串包含最多的编码种数。不考虑特殊情况，该题的递推式是$dp[i]=dp[i-1]+dp[i-2]$，因为一个数字可以表示一个编码，两个数字也有可能表示一个编码，所以<code>dp[i]</code>应该等于<code>0~i-1</code>的字符串包含的最多编码种数加上<code>0~i-2</code>的字符串包含的最多编码种数。但是考虑到一共只有26种基础编码加上特殊情况0，所以递推式可以表示为：</p><p><img src="/2018/10/28/算法课第二次作业/form2.png" alt=""></p><h4 id="2、-pseudo-code-2"><a href="#2、-pseudo-code-2" class="headerlink" title="2、 pseudo-code"></a>2、 pseudo-code</h4><p><a href="https://leetcode-cn.com/problems/decode-ways/description/" target="_blank" rel="noopener">LeetCode 91题</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numDecodings</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>( s.length()==<span class="number">0</span> || s[<span class="number">0</span>]==<span class="string">'0'</span> ) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; dp(s.length()+<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">        dp[<span class="number">0</span>] = dp[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>( <span class="keyword">int</span> i=<span class="number">1</span>; i&lt;s.length(); i++ )&#123;</span><br><span class="line">            <span class="keyword">if</span>( s[i]!=<span class="string">'0'</span> )</span><br><span class="line">                dp[i+<span class="number">1</span>] += dp[i];</span><br><span class="line">            <span class="keyword">if</span>( s[i<span class="number">-1</span>]!=<span class="string">'0'</span> &amp;&amp; (s[i<span class="number">-1</span>]-<span class="string">'0'</span>)*<span class="number">10</span>+(s[i]-<span class="string">'0'</span>)&lt;=<span class="number">26</span> )</span><br><span class="line">                dp[i+<span class="number">1</span>] += dp[i<span class="number">-1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[s.length()];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="3、correctness-of-algorithm-1"><a href="#3、correctness-of-algorithm-1" class="headerlink" title="3、correctness of algorithm"></a>3、correctness of algorithm</h4><p>首先该问题包含最优子结构的性质，求<code>0~n</code>的字符串包含最多的编码种数包含了求<code>0~n-1</code>的字符串包含最多的编码种数或<code>0~n-2</code>的字符串包含最多的编码种数。其次该问题包含重叠子性质，大量子问题会重复计算，如求dp[5]需要计算dp[4]或dp[3],求dp[4]需要求dp[3]或dp[2]，因此dp[3]被重复计算。综上该问题可以用动态规划方法解且求解方程正确。</p><h4 id="4、complexity-of-algorithm-1"><a href="#4、complexity-of-algorithm-1" class="headerlink" title="4、complexity of algorithm"></a>4、complexity of algorithm</h4><p>整个求解过程只遍历了一遍字符串，故算法时间复杂度为$O(n)$。</p><h3 id="六、OJ第一题"><a href="#六、OJ第一题" class="headerlink" title="六、OJ第一题"></a>六、OJ第一题</h3><p>LIS，DP入门第一题，没啥好说的，只要想清楚为啥每次将新来的数据往 <code>ans</code> 数组里插入，最后出来的就一定是最长的就可以了。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> num, T, N;</span><br><span class="line">    <span class="keyword">int</span> length, index;</span><br><span class="line">    <span class="keyword">int</span> ans[<span class="number">100005</span>];</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; T;</span><br><span class="line">    <span class="keyword">for</span>( <span class="keyword">int</span> t = <span class="number">0</span>; t&lt;T; t++ )&#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; N;</span><br><span class="line">        length = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">memset</span>(ans, <span class="number">-1</span>, <span class="keyword">sizeof</span>(ans));</span><br><span class="line">        <span class="keyword">for</span>( <span class="keyword">int</span> i=<span class="number">0</span>; i&lt;N; i++ )&#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;num);</span><br><span class="line">            index = lower_bound( ans, ans+length, num ) - ans;</span><br><span class="line">            ans[index] = num;</span><br><span class="line">            <span class="keyword">if</span>( index==length )</span><br><span class="line">                length++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; length &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="七、OJ第二题"><a href="#七、OJ第二题" class="headerlink" title="七、OJ第二题"></a>七、OJ第二题</h3><p>入门级题目外加了求 <code>K</code> 个最优值的条件，昨晚1点多打开题目，感觉随便码一码随便A掉，于是上床 睡觉，躺床上拍脑袋理论AC。仔细一想，K个最优值的状态转移，有点问题啊，带着疑问入睡不咋舒坦，大半夜将题目发到<code>315</code>群，杨老师帅气得给出了解决方案，顺带嘲笑了一波数据；炸老师看了数据量也嘲讽了一波；早上起来交了一发，发现 <code>0 ms</code>的时候，也疯狂鄙视一波，数据真的弱得不行。</p><p>想起来当年 <code>ycb</code> 的誓言：</p><p><img src="/2018/10/28/算法课第二次作业/ycb.jpeg" alt=""></p><p><img src="/2018/10/28/算法课第二次作业/dp1.png" alt=""></p><p><img src="/2018/10/28/算法课第二次作业/dp2.png" alt=""></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> m, n, k;</span><br><span class="line"><span class="keyword">int</span> num;</span><br><span class="line">priority_queue&lt;<span class="keyword">int</span>&gt; ans[<span class="number">105</span>], cur_ans, tmp_ans;<span class="comment">//默认大堆</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ans[<span class="number">1</span>].push(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; m &gt;&gt; n &gt;&gt; k;</span><br><span class="line">    <span class="keyword">for</span>( <span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=m; i++ )&#123;</span><br><span class="line">        <span class="keyword">for</span>( <span class="keyword">int</span> j=<span class="number">1</span>; j&lt;=n; j++ )&#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;num);</span><br><span class="line">            <span class="keyword">while</span>( !cur_ans.empty() )&#123;  <span class="comment">//清空cur_ans</span></span><br><span class="line">                cur_ans.pop();</span><br><span class="line">            &#125;</span><br><span class="line">            tmp_ans = ans[j<span class="number">-1</span>];</span><br><span class="line">            <span class="keyword">while</span>( !ans[j<span class="number">-1</span>].empty() )&#123;</span><br><span class="line">                cur_ans.push(ans[j<span class="number">-1</span>].top()+num);</span><br><span class="line">                ans[j<span class="number">-1</span>].pop();</span><br><span class="line">            &#125;</span><br><span class="line">            ans[j<span class="number">-1</span>] = tmp_ans;</span><br><span class="line">            <span class="keyword">while</span>( !ans[j].empty() )&#123;</span><br><span class="line">                cur_ans.push(ans[j].top()+num);</span><br><span class="line">                ans[j].pop();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span>( ans[j].size()&lt;k &amp;&amp; !cur_ans.empty() )&#123;</span><br><span class="line">                ans[j].push(cur_ans.top());</span><br><span class="line">                cur_ans.pop();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; ans[n].top();</span><br><span class="line">    ans[n].pop();</span><br><span class="line">    <span class="keyword">while</span>( !ans[n].empty() )&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">" "</span> &lt;&lt; ans[n].top();</span><br><span class="line">        ans[n].pop();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;一、Money-robbing&quot;&gt;&lt;a href=&quot;#一、Money-robbing&quot; class=&quot;headerlink&quot; title=&quot;一、Money robbing&quot;&gt;&lt;/a&gt;一、Money robbing&lt;/h3&gt;&lt;h4 id=&quot;1、optimal-substructure-and-DP-equation&quot;&gt;&lt;a href=&quot;#1、optimal-substructure-and-DP-equation&quot; class=&quot;headerlink&quot; title=&quot;1、optimal substructure and DP equation&quot;&gt;&lt;/a&gt;1、optimal substructure and DP equation&lt;/h4&gt;&lt;p&gt;对于第 i 家，有两种选择，抢或者不抢。如果抢第 i 家，那么最大收益为：value[i] + 抢前 i-2 家的最优收益； 如果第 i 家不抢，那么最大收益为：抢前 i-1 家的最优收益。&lt;/p&gt;
&lt;p&gt;状态转移方程可写为：&lt;br&gt;$$&lt;br&gt;dp[i] = max( dp[i-1], dp[i-2]+value[i] )&lt;br&gt;$$&lt;/p&gt;
&lt;h4 id=&quot;2、-pseudo-code&quot;&gt;&lt;a href=&quot;#2、-pseudo-code&quot; class=&quot;headerlink&quot; title=&quot;2、 pseudo-code&quot;&gt;&lt;/a&gt;2、 pseudo-code&lt;/h4&gt;&lt;p&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/house-robber/description/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;LeetCode 198题&lt;/a&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight c++&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Solution&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt;:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;rob&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;built_in&quot;&gt;vector&lt;/span&gt;&amp;lt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt;&amp;gt;&amp;amp; nums)&lt;/span&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;( nums.size()==&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt; )&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;( nums.size()==&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt; )&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; nums[&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;built_in&quot;&gt;vector&lt;/span&gt;&amp;lt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt;&amp;gt; dp(nums.size(),&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        dp[&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;] = nums[&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        dp[&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;] = max( nums[&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;], nums[&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;] );&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt;( &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; i=&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;; i&amp;lt;nums.size(); i++ )&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            dp[i] = max( dp[i&lt;span class=&quot;number&quot;&gt;-1&lt;/span&gt;], dp[i&lt;span class=&quot;number&quot;&gt;-2&lt;/span&gt;]+nums[i] );&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; dp[nums.size()&lt;span class=&quot;number&quot;&gt;-1&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="作业" scheme="https://wangjibao.com.cn/categories/%E4%BD%9C%E4%B8%9A/"/>
    
      <category term="算法课第二次作业" scheme="https://wangjibao.com.cn/categories/%E4%BD%9C%E4%B8%9A/%E7%AE%97%E6%B3%95%E8%AF%BE%E7%AC%AC%E4%BA%8C%E6%AC%A1%E4%BD%9C%E4%B8%9A/"/>
    
    
      <category term="作业" scheme="https://wangjibao.com.cn/tags/%E4%BD%9C%E4%B8%9A/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode21-30</title>
    <link href="https://wangjibao.com.cn/2018/10/20/LeetCode21-30/"/>
    <id>https://wangjibao.com.cn/2018/10/20/LeetCode21-30/</id>
    <published>2018-10-20T11:51:57.000Z</published>
    <updated>2019-05-08T16:19:34.492Z</updated>
    
    <content type="html"><![CDATA[<h2 id="21、合并两个有序链表"><a href="#21、合并两个有序链表" class="headerlink" title="21、合并两个有序链表"></a>21、<a href="https://leetcode-cn.com/problems/merge-two-sorted-lists" target="_blank" rel="noopener">合并两个有序链表</a></h2><p>两个有序链表的合并，本渣代码充分利用原有空间，没开辟新的内存存储新链。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">mergeTwoLists</span><span class="params">(ListNode* l1, ListNode* l2)</span> </span>&#123;</span><br><span class="line">        ListNode *ans = (ListNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(ListNode)), *tmp = ans;</span><br><span class="line">        ans-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">while</span>( l1&amp;&amp;l2 )&#123;</span><br><span class="line">            <span class="keyword">if</span>( l1-&gt;val &gt; l2-&gt;val )&#123;</span><br><span class="line">                tmp-&gt;next = l2;</span><br><span class="line">                l2 = l2-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                tmp-&gt;next = l1;</span><br><span class="line">                l1 = l1-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            tmp = tmp-&gt;next;</span><br><span class="line">            tmp-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>( l1 )</span><br><span class="line">            tmp-&gt;next = l1;</span><br><span class="line">        <span class="keyword">if</span>( l2 )</span><br><span class="line">            tmp-&gt;next = l2;</span><br><span class="line">        <span class="keyword">return</span> ans-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="22、括号生成"><a href="#22、括号生成" class="headerlink" title="22、括号生成"></a>22、<a href="https://leetcode-cn.com/problems/generate-parentheses" target="_blank" rel="noopener">括号生成</a></h2><p>生成的种类数是个卡特兰数，因此 n 的值不会太大。卡特兰数在计算机中是个特别重要的数串，像：三角剖分、n个叶节点树的种类、n个数字的进出栈、括号匹配、矩阵链乘等等都有卡特兰数的应用。</p><p>卡特兰数的通项公式：<br>$$<br>h(n) = C_{2n}^n - C_{2n}^{n-1}<br>$$<br>递推公式为：<br>$$<br>h(n) = h(n-1)*\frac{4n-2}{n+1}<br>$$<br>其实，求组合数时，当 n 很大的时候，计算也是个问题，好在有 <a href="https://blog.csdn.net/arrowlll/article/details/53064748" target="_blank" rel="noopener">Lucas定理</a> 可以解决这事，当然以上这些与解决本题没啥关系。</p><p>本题做法是直接递归一下即可，每次放左括号（第16行）或右括号（第17行），递归的退出条件是放了n个左括号和n个右括号（第9行），剪枝条件是放的右括号数量大于左括号数量了，明显会造成非法串，直接返回退出（第13行）。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; generateParenthesis(<span class="keyword">int</span> n) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; ans;</span><br><span class="line">        func(ans, <span class="string">""</span>, n, n);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; ans, <span class="built_in">string</span> tmp_ans, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>( left==<span class="number">0</span> &amp;&amp; right==<span class="number">0</span> )&#123;</span><br><span class="line">            ans.push_back(tmp_ans);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>( right&lt;left )  <span class="comment">//相当于剪枝，2^n剪到katalan(n)</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span>( left&gt;<span class="number">0</span> )</span><br><span class="line">            func( ans, tmp_ans+<span class="string">'('</span>, left<span class="number">-1</span>, right );</span><br><span class="line">        func( ans, tmp_ans+<span class="string">')'</span>, left, right<span class="number">-1</span> );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="23、合并K个排序链表"><a href="#23、合并K个排序链表" class="headerlink" title="23、合并K个排序链表"></a>23、<a href="https://leetcode-cn.com/problems/merge-k-sorted-lists" target="_blank" rel="noopener">合并K个排序链表</a></h2><p>合并的关键点在于如何快速找到当前最小值，最小堆可以帮我们快速实现这一点。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> <span class="class"><span class="keyword">struct</span> <span class="title">cmp</span>&#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(ListNode* a, ListNode* b)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a-&gt;val &gt; b-&gt;val;</span><br><span class="line">    &#125;</span><br><span class="line"> &#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">mergeKLists</span><span class="params">(<span class="built_in">vector</span>&lt;ListNode*&gt;&amp; lists)</span> </span>&#123;</span><br><span class="line">        ListNode *ans = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        ListNode *p = ans, *tmp;</span><br><span class="line">        priority_queue&lt;ListNode*, <span class="built_in">vector</span>&lt;ListNode*&gt;, cmp&gt; pq;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;lists.size(); i++)&#123;</span><br><span class="line">           <span class="keyword">if</span>(lists[i])</span><br><span class="line">                pq.push(lists[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(pq.size()&gt;<span class="number">1</span>)&#123;</span><br><span class="line">            tmp = pq.top();</span><br><span class="line">            pq.pop();</span><br><span class="line">            p-&gt;next = tmp;</span><br><span class="line">            <span class="keyword">if</span>(tmp-&gt;next)</span><br><span class="line">                pq.push(tmp-&gt;next);</span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">            p-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(pq.size()==<span class="number">1</span>)</span><br><span class="line">            p-&gt;next = pq.top();</span><br><span class="line">        <span class="keyword">return</span> ans-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="24、两两交换链表中的节点"><a href="#24、两两交换链表中的节点" class="headerlink" title="24、两两交换链表中的节点"></a>24、<a href="https://leetcode-cn.com/problems/swap-nodes-in-pairs" target="_blank" rel="noopener">两两交换链表中的节点</a></h2><p>处理好两个指针之间的关系即可。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">swapPairs</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>( head==<span class="literal">NULL</span> || head-&gt;next==<span class="literal">NULL</span> )</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        ListNode *p1=head, *p2=head-&gt;next, *tmp;</span><br><span class="line">        head = head-&gt;next;</span><br><span class="line">        <span class="keyword">while</span>( p1 &amp;&amp; p2)&#123;</span><br><span class="line">            tmp = p1;</span><br><span class="line">            p1-&gt;next = p2-&gt;next==<span class="literal">NULL</span>? <span class="literal">NULL</span>:p2-&gt;next-&gt;next==<span class="literal">NULL</span>? p2-&gt;next:p2-&gt;next-&gt;next;</span><br><span class="line">            p1 = p2-&gt;next;</span><br><span class="line">            p2-&gt;next = tmp;</span><br><span class="line">            p2 = p1==<span class="literal">NULL</span>? <span class="literal">NULL</span>:p1-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="25、k个一组翻转链表"><a href="#25、k个一组翻转链表" class="headerlink" title="25、k个一组翻转链表"></a>25、<a href="https://leetcode-cn.com/problems/reverse-nodes-in-k-group" target="_blank" rel="noopener">k个一组翻转链表</a></h2><p>采用一个大小为 <code>k</code> 的栈来实现翻转。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">reverseKGroup</span><span class="params">(ListNode* head, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">        ListNode *tmp_head = head, *ans, *cur_ans;</span><br><span class="line">        <span class="keyword">while</span>(tmp_head)&#123;</span><br><span class="line">            len++;</span><br><span class="line">            tmp_head = tmp_head-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> num_roll = len / k;</span><br><span class="line">        ans = <span class="keyword">new</span> ListNode(<span class="number">-1</span>);</span><br><span class="line">        cur_ans = ans;</span><br><span class="line">        <span class="built_in">stack</span>&lt;ListNode*&gt; s;</span><br><span class="line">        tmp_head = head;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;num_roll; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;k; j++)&#123;</span><br><span class="line">                s.push(tmp_head);</span><br><span class="line">                tmp_head = tmp_head-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;k; j++)&#123;</span><br><span class="line">                cur_ans-&gt;next = s.top();</span><br><span class="line">                s.pop();</span><br><span class="line">                cur_ans = cur_ans-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        cur_ans-&gt;next = tmp_head;</span><br><span class="line">        <span class="keyword">return</span> ans-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="26、删除排序数组中的重复项"><a href="#26、删除排序数组中的重复项" class="headerlink" title="26、删除排序数组中的重复项"></a>26、<a href="https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array" target="_blank" rel="noopener">删除排序数组中的重复项</a></h2><p>直接使用 <code>STL</code> 中的 <code>unique</code> 函数即可，<code>unique</code> 函数的具体说明如下：</p><p><code>iterator unique(iterator it_1,iterator it_2);</code></p><p>两个参数表示对容器中[it_1，it_2)范围的元素进行去重(<strong>注：区间是前闭后开，即不包含it_2所指的元素</strong>),返回值是一个迭代器，<strong>它指向的是去重后容器中不重复序列的最后一个元素的下一个元素</strong>。注意，<code>unique</code>函数的去重过程实际上就是<strong>不停的把后面不重复的元素移到前面来，也可以说是用不重复的元素占领重复元素的位置</strong>，而不是将重复的元素往后移动。</p><p><img src="/2018/10/20/LeetCode21-30/unique.png" alt=""></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">removeDuplicates</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> unique(nums.begin(), nums.end()) - nums.begin();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="27、移除元素"><a href="#27、移除元素" class="headerlink" title="27、移除元素"></a>27、<a href="https://leetcode-cn.com/problems/remove-element" target="_blank" rel="noopener">移除元素</a></h2><p>双指针，执行调换过程即可，注意，如果前后调换后，<code>nums[pFront]</code> 可能依然等于 <code>val</code>，通过第<code>11</code>行的 <code>continue</code>语句巧妙的解决该问题。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">removeElement</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.size()==<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> pFront=<span class="number">0</span>, pEnd = nums.size()<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(pEnd&gt;pFront)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[pFront]==val)&#123;</span><br><span class="line">                swap(nums[pFront], nums[pEnd]);</span><br><span class="line">                pEnd--;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            pFront++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums[pFront]==val? pFront:pFront+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="28、实现strStr"><a href="#28、实现strStr" class="headerlink" title="28、实现strStr()"></a>28、<a href="https://leetcode-cn.com/problems/implement-strstr" target="_blank" rel="noopener">实现strStr()</a></h2><p>可以直接暴力，时间复杂度为$O(n^2)$。线性时间复杂度算法为 <a href="https://www.cnblogs.com/ZuoAndFutureGirl/p/9028287.html" target="_blank" rel="noopener">KMP</a> 算法或  BM 算法。KMP 算法的关键是理解 <code>next</code> 数组的求解过程。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> next[<span class="number">100000</span>];</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">solve_next</span><span class="params">(<span class="built_in">string</span> needle)</span></span>&#123;</span><br><span class="line">        <span class="built_in">memset</span>(next, <span class="number">-1</span>, <span class="keyword">sizeof</span>(next));</span><br><span class="line">        <span class="keyword">int</span> len = needle.size();</span><br><span class="line">        <span class="keyword">int</span> k = <span class="number">-1</span>, j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(j&lt;len<span class="number">-1</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>( k==<span class="number">-1</span> || needle[j]==needle[k] )</span><br><span class="line">                next[++j] = ++k;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                k = next[k];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">strStr</span><span class="params">(<span class="built_in">string</span> haystack, <span class="built_in">string</span> needle)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(needle.size()==<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        solve_next(needle);</span><br><span class="line">        <span class="keyword">int</span> len_haystack = haystack.size();</span><br><span class="line">        <span class="keyword">int</span> len_needle = needle.size();</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>( i&lt;len_haystack &amp;&amp; j&lt;len_needle)&#123;</span><br><span class="line">            <span class="keyword">if</span>(j==<span class="number">-1</span> || haystack[i]==needle[j])&#123;</span><br><span class="line">                i++;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                j = next[j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(j==len_needle)</span><br><span class="line">            <span class="keyword">return</span> i-j;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="29、两数相除"><a href="#29、两数相除" class="headerlink" title="29、两数相除"></a>29、<a href="https://leetcode-cn.com/problems/divide-two-integers" target="_blank" rel="noopener">两数相除</a></h2><p>使用移位操作模拟乘法，用减法代替除法。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">divide</span><span class="params">(<span class="keyword">int</span> dividend, <span class="keyword">int</span> divisor)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>( dividend==INT_MIN &amp;&amp; divisor==<span class="number">-1</span> )</span><br><span class="line">            <span class="keyword">return</span> INT_MAX;</span><br><span class="line">        <span class="keyword">int</span> flag1 = dividend&gt;<span class="number">0</span>? <span class="number">1</span>:<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">int</span> flag2 = divisor&gt;<span class="number">0</span>? <span class="number">1</span>:<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> _dividend = <span class="built_in">abs</span>((<span class="keyword">long</span> <span class="keyword">long</span>)dividend);</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> _divisor = <span class="built_in">abs</span>((<span class="keyword">long</span> <span class="keyword">long</span>)divisor);</span><br><span class="line">        <span class="keyword">int</span> n = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(_divisor&lt;&lt;(n+<span class="number">1</span>) &lt;= _dividend &amp;&amp; _divisor&lt;&lt;(n+<span class="number">1</span>) &gt;= <span class="number">0</span>)</span><br><span class="line">            n++;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=n; i&gt;=<span class="number">0</span>; i--)&#123;</span><br><span class="line">            <span class="keyword">if</span>( _dividend &gt;= _divisor&lt;&lt;i )&#123;</span><br><span class="line">                ans += (<span class="keyword">long</span> <span class="keyword">long</span>)<span class="number">1</span>&lt;&lt;i;</span><br><span class="line">                _dividend -= _divisor&lt;&lt;i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(flag1+flag2==<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> -ans&gt;=INT_MAX? INT_MAX:<span class="keyword">int</span>(-ans);</span><br><span class="line">        <span class="keyword">return</span> ans&gt;=INT_MAX? INT_MAX:ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="30、串联所有单词的子串"><a href="#30、串联所有单词的子串" class="headerlink" title="30、串联所有单词的子串"></a>30、<a href="https://leetcode-cn.com/problems/substring-with-concatenation-of-all-words" target="_blank" rel="noopener">串联所有单词的子串</a></h2><p><code>words</code>中单词长度固定，将<code>s</code>串按照固定长度切分保存进<code>vector&lt;string&gt;</code>中，之后使用两个<code>map</code>和滑动窗口实现匹配过程，详见代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; findSubstring(<span class="built_in">string</span> s, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; words) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line">        <span class="keyword">if</span>(s.size()==<span class="number">0</span> || words.size()==<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> ans;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt; mp1;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> str : words)</span><br><span class="line">            mp1[str] = mp1.find(str)==mp1.end()? <span class="number">1</span>:mp1[str]+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> str_len = words[<span class="number">0</span>].length();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;str_len; i++)&#123;</span><br><span class="line">            <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; word_vec;</span><br><span class="line">            <span class="keyword">int</span> position = i;</span><br><span class="line">            <span class="keyword">while</span>( position + str_len &lt;= s.length() )&#123;</span><br><span class="line">                word_vec.push_back(s.substr(position, str_len));</span><br><span class="line">                position += str_len;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">unordered_map</span>&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt; mp2;</span><br><span class="line">            <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;word_vec.size(); j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(mp1.find(word_vec[j])==mp1.end())&#123;</span><br><span class="line">                    mp2.clear();</span><br><span class="line">                    left = j+<span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                mp2[word_vec[j]] = mp2.find(word_vec[j])==mp2.end()? <span class="number">1</span>:mp2[word_vec[j]]+<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">while</span>(mp2[word_vec[j]] &gt; mp1[word_vec[j]])</span><br><span class="line">                    mp2[word_vec[left++]] -= <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span>( j-left+<span class="number">1</span> == words.size() )&#123;</span><br><span class="line">                    ans.push_back(left*str_len+i);</span><br><span class="line">                    mp2[word_vec[left]] -= <span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">if</span>(mp2[word_vec[left]]==<span class="number">0</span>)</span><br><span class="line">                        mp2.erase(word_vec[left]);</span><br><span class="line">                    left++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;21、合并两个有序链表&quot;&gt;&lt;a href=&quot;#21、合并两个有序链表&quot; class=&quot;headerlink&quot; title=&quot;21、合并两个有序链表&quot;&gt;&lt;/a&gt;21、&lt;a href=&quot;https://leetcode-cn.com/problems/merge-two-sorted-lists&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;合并两个有序链表&lt;/a&gt;&lt;/h2&gt;&lt;p&gt;两个有序链表的合并，本渣代码充分利用原有空间，没开辟新的内存存储新链。&lt;/p&gt;
&lt;figure class=&quot;highlight c++&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;31&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;32&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;/**&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt; * Definition for singly-linked list.&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt; * struct ListNode &amp;#123;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt; *     int val;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt; *     ListNode *next;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt; *     ListNode(int x) : val(x), next(NULL) &amp;#123;&amp;#125;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt; * &amp;#125;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt; */&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Solution&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt;:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;ListNode* &lt;span class=&quot;title&quot;&gt;mergeTwoLists&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(ListNode* l1, ListNode* l2)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        ListNode *ans = (ListNode*)&lt;span class=&quot;built_in&quot;&gt;malloc&lt;/span&gt;(&lt;span class=&quot;keyword&quot;&gt;sizeof&lt;/span&gt;(ListNode)), *tmp = ans;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        ans-&amp;gt;next = &lt;span class=&quot;literal&quot;&gt;NULL&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;while&lt;/span&gt;( l1&amp;amp;&amp;amp;l2 )&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;( l1-&amp;gt;val &amp;gt; l2-&amp;gt;val )&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                tmp-&amp;gt;next = l2;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                l2 = l2-&amp;gt;next;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                tmp-&amp;gt;next = l1;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                l1 = l1-&amp;gt;next;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            tmp = tmp-&amp;gt;next;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            tmp-&amp;gt;next = &lt;span class=&quot;literal&quot;&gt;NULL&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;( l1 )&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            tmp-&amp;gt;next = l1;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;( l2 )&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            tmp-&amp;gt;next = l2;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; ans-&amp;gt;next;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="LeetCode" scheme="https://wangjibao.com.cn/categories/LeetCode/"/>
    
      <category term="LeetCode21-30" scheme="https://wangjibao.com.cn/categories/LeetCode/LeetCode21-30/"/>
    
    
      <category term="LeetCode" scheme="https://wangjibao.com.cn/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>背包九讲</title>
    <link href="https://wangjibao.com.cn/2018/10/17/%E8%83%8C%E5%8C%85%E4%B9%9D%E8%AE%B2/"/>
    <id>https://wangjibao.com.cn/2018/10/17/背包九讲/</id>
    <published>2018-10-17T08:51:14.000Z</published>
    <updated>2018-11-04T17:18:37.235Z</updated>
    
    <content type="html"><![CDATA[<p>大二入门动态规划时，最先学得就是 <code>LCS</code> , <code>LIS</code> 和各种背包问题，后来接触二维DP和各种无厘头DP（数位DP啊，插头DP啊，状压DP啊，树状DP啊等等），以我这种智商水平，听听名字就好了。最近的算法课讲到了 <code>DP</code> 专题，找出了之前看的 <code>背包九讲</code>看了看，放出来，纪念一发当年的岁月吧。</p><a id="more"></a><div class="row">    <embed src="背包九讲.pdf" width="100%" height="550" type="application/pdf"></div>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;大二入门动态规划时，最先学得就是 &lt;code&gt;LCS&lt;/code&gt; , &lt;code&gt;LIS&lt;/code&gt; 和各种背包问题，后来接触二维DP和各种无厘头DP（数位DP啊，插头DP啊，状压DP啊，树状DP啊等等），以我这种智商水平，听听名字就好了。最近的算法课讲到了 &lt;code&gt;DP&lt;/code&gt; 专题，找出了之前看的 &lt;code&gt;背包九讲&lt;/code&gt;看了看，放出来，纪念一发当年的岁月吧。&lt;/p&gt;
    
    </summary>
    
      <category term="资料" scheme="https://wangjibao.com.cn/categories/%E8%B5%84%E6%96%99/"/>
    
    
      <category term="资料" scheme="https://wangjibao.com.cn/tags/%E8%B5%84%E6%96%99/"/>
    
  </entry>
  
  <entry>
    <title>Ubuntu中配置SS多用户模式并限制每个用户的流量</title>
    <link href="https://wangjibao.com.cn/2018/10/12/Ubuntu%E4%B8%AD%E9%85%8D%E7%BD%AESS%E5%A4%9A%E7%94%A8%E6%88%B7%E6%A8%A1%E5%BC%8F%E5%B9%B6%E9%99%90%E5%88%B6%E6%AF%8F%E4%B8%AA%E7%94%A8%E6%88%B7%E7%9A%84%E6%B5%81%E9%87%8F/"/>
    <id>https://wangjibao.com.cn/2018/10/12/Ubuntu中配置SS多用户模式并限制每个用户的流量/</id>
    <published>2018-10-12T12:40:14.000Z</published>
    <updated>2018-10-12T13:05:44.919Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1、更新软件并安装vim"><a href="#1、更新软件并安装vim" class="headerlink" title="1、更新软件并安装vim"></a>1、更新软件并安装vim</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get upgrade</span><br><span class="line">sudo apt-get install vim</span><br></pre></td></tr></table></figure><h3 id="2、更改-SSH-默认端口"><a href="#2、更改-SSH-默认端口" class="headerlink" title="2、更改 SSH 默认端口"></a>2、更改 SSH 默认端口</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sudo vim /etc/ssh/sshd_config</span><br><span class="line">找到 Port 字段，将其修改为自己想要的端口值</span><br><span class="line">sudo service ssh restart         #重启ssh服务</span><br><span class="line">sudo netstat -tunlp | grep ssh   #查看ssh服务监听的端口</span><br></pre></td></tr></table></figure><p>这里将ssh端口改成了22222，如下图（PS:不要问我为啥强行改22号端口，就是任性，额，其实有点其他用途，青大校友表示当年我就是靠这个强行免费使用校园网）：</p><p><img src="/2018/10/12/Ubuntu中配置SS多用户模式并限制每个用户的流量/ssh.png" alt=""></p><h3 id="3、安装shadowsocks-python版本"><a href="#3、安装shadowsocks-python版本" class="headerlink" title="3、安装shadowsocks-python版本"></a>3、安装shadowsocks-python版本</h3><a id="more"></a><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install python-pip</span><br><span class="line"><span class="meta">#</span>在ubuntu16.04中，可以通过pip安装pyhon版的shadowsocks，但是好像已经不维护更新了，停留在了2.8.2版本</span><br><span class="line">sudo pip install shadowsocks</span><br></pre></td></tr></table></figure><p>然后创建一个 <code>json</code> 文件并在其中填写个人配置信息即可，比如在 <code>/home/my_ss_config.json</code> 中，填写如下信息：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">"server" : "your_server_ip",     #自己服务器的IP</span><br><span class="line">"server_port" : 8388,            #服务器端口</span><br><span class="line">"local_address" : "127.0.0.1", </span><br><span class="line">"local_port" : 1080, </span><br><span class="line">"password" : "yourpassword",     #密码</span><br><span class="line">"timeout" : 300, </span><br><span class="line">"method" : "aes-256-cfb"         #加密方式</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>只要更改后面带 <code>#</code> 号的一些字段值即可，如果想多用户的话，可以将 <code>password</code> 字段改成如下模式（ss使用端口值识别不同的用户）：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">"port_password": &#123;</span><br><span class="line">"端口1": "密码1",</span><br><span class="line">"端口2": "密码2"</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p>一切准备就绪，接下来使用如下命令即可运行 SS 服务，实现 <code>Cross the Great Fire Wall</code> 。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo ssserver -c /home/my_ss_config.json -d start</span><br></pre></td></tr></table></figure><h3 id="4、多用户模式流量统计"><a href="#4、多用户模式流量统计" class="headerlink" title="4、多用户模式流量统计"></a>4、多用户模式流量统计</h3><p>说一下我为啥要搞这么个功能，前天，我TM大半夜的正嗨呢，突然，网断了！于是乎，打开4G，还是无法操作，这。。。。<del>我手纸都准备好了</del>，竟然发生这样的事？（开玩笑，哈哈，根正苗红的科研知识分子，油管看科研视频的好吧，为科研奉献全身！）收到邮件，告诉我流量用完了，呵。。。</p><p><img src="/2018/10/12/Ubuntu中配置SS多用户模式并限制每个用户的流量/bandwidth.png" alt=""></p><p>于是乎，大家公用的情况下，私开个个人账号，每到月末的时候应急用。于是乎用到了上面讲到的多用户模式，但是这样还不行，为每个用户限制流量使用上限才能达到目的。</p><p>找了找，发现国内的某度关于这方面是真的干净，上某歌，查到可以使用 <code>ss-bash</code> 实现，<a href="https://github.com/hellofwy/ss-bash" target="_blank" rel="noopener">github上有</a>，实现的原理就是：<code>不同的用户分配不同端口，使用iptables规则获取各端口的流量，脚本循环运行，在固定时间间隔根据iptables结果统计流量使用情况，并在流量超过限制时，添加对应端口的iptables reject规则以禁用端口。</code></p><p>安装shadowsocks与ss-bash之后，shadowsocks就不用做任何配置了，省去了上面的步骤，由ss-bash管理shadowsocks，包括配置的文件等等。有个缺点就是，ss-bash目前只支持python版Shadowsocks，只支持统计ipv4流量，但这问题影响不大。</p><p>执行如下指令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">apt-get install unzip       #下载解压工具</span><br><span class="line">apt-get install bc          #安装计算器，后面统计流量用</span><br><span class="line">wget https://github.com/hellofwy/ss-bash/archive/master.zip   #下载软件包</span><br><span class="line">unzip master.zip</span><br><span class="line">cd ss-bash-master/</span><br></pre></td></tr></table></figure><p>现在就可以使用相关命令配置 SS 了，具体操作指令如下（可通过 <code>./ssadmin.sh</code> 命令查看）：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">用法：</span><br><span class="line">    显示版本：</span><br><span class="line">        ssadmin.sh -v|v|version</span><br><span class="line">    显示帮助：</span><br><span class="line">        ssadmin.sh [-h|h|help]</span><br><span class="line">    启动ss:</span><br><span class="line">        ssadmin.sh start</span><br><span class="line">    停止ss：</span><br><span class="line">        ssadmin.sh stop</span><br><span class="line">    查看ss状态：</span><br><span class="line">        ssadmin.sh status</span><br><span class="line">    重启ss：</span><br><span class="line">        ssadmin.sh restart</span><br><span class="line">    软重启ss：</span><br><span class="line">        ssadmin.sh soft_restart</span><br><span class="line">        在不影响现有连接的情况下重启ss服务。用于ss服务参数修改，</span><br><span class="line">        和手动直接修改配置文件后，重启ss服务。</span><br><span class="line">    添加用户：</span><br><span class="line">        ssadmin.sh add port passwd limit</span><br><span class="line">            port：端口号, 0&lt;port&lt;=65535</span><br><span class="line">            passwd：密码, 不能有空格，引号等字符</span><br><span class="line">            limit：流量限制，可以用K/M/G/T、KB/MB/GB/TB等（不区</span><br><span class="line">                   分大小写）。支持小数。比如10.5G、10.5GB等。</span><br><span class="line">                   1KB=1024 bytes，以此类推。</span><br><span class="line">        示例： ssadmin.sh add 3333 abcde 10.5G</span><br><span class="line">    显示用户流量信息：</span><br><span class="line">        ssadmin.sh show port</span><br><span class="line">    显示所有用户流量信息：</span><br><span class="line">        ssadmin.sh show</span><br><span class="line">    显示用户密码信息：</span><br><span class="line">        ssadmin.sh showpw port</span><br><span class="line">    显示所有用户密码信息：</span><br><span class="line">        ssadmin.sh showpw</span><br><span class="line">    删除用户：</span><br><span class="line">        ssadmin.sh del port</span><br><span class="line">    修改用户：</span><br><span class="line">        ssadmin.sh change port passwd limit</span><br><span class="line">    修改用户密码：</span><br><span class="line">        ssadmin.sh cpw port passwd</span><br><span class="line">    修改用户流量限制：</span><br><span class="line">        ssadmin.sh clim port limit</span><br><span class="line">    修改所有用户流量限制：</span><br><span class="line">        ssadmin.sh change_all_limit limit</span><br><span class="line">    用户流量使用量置零：</span><br><span class="line">        ssadmin.sh rused limit</span><br><span class="line">    所有用户流量使用量置零：</span><br><span class="line">        ssadmin.sh reset_all_used</span><br><span class="line">    用户流量限制置零：</span><br><span class="line">        ssadmin.sh rlim port</span><br><span class="line">    全部用户流量限制置零：</span><br><span class="line">        ssadmin.sh reset_all_limit</span><br><span class="line">    显示已添加的iptables规则：</span><br><span class="line">        ssadmin.sh lrules</span><br></pre></td></tr></table></figure><p>添加完账户后，<code>./ssadmin.sh start</code>启动后，<code>./ssadmin.sh show</code> 即可查看每个用户的当前流量使用情况。如下图：</p><p><img src="/2018/10/12/Ubuntu中配置SS多用户模式并限制每个用户的流量/show.png" alt=""></p><p><code>ssadmin</code>文件夹中的各个文件的含义如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">ssadmin.sh      #管理程序，所有命令通过该程序执行</span><br><span class="line">sscounter.sh    #流量统计程序。由ssadmin.sh自动调用执行，注意：不要手动运行该程序</span><br><span class="line">sshelp</span><br><span class="line">sslib.sh        #包含一些参数配置和流量统计函数。由ssadmin.sh自动调用执行，注意：不要手动运行该程序</span><br><span class="line">ssmlt.json      #根据用户列表和ssmlt.template生成的ssserver实际使用的配置文件</span><br><span class="line">ssmlt.template  #ssserver的配置文件</span><br><span class="line">sstraffic       #用户流量使用情况，包括流量限制，已用流量，剩余流量等。ssadmin.sh show 命令，显示该文件内容。</span><br><span class="line">ssusers         #用户列表</span><br><span class="line">traffic.log     #用户流量记录，供程序内部使用。</span><br></pre></td></tr></table></figure><p>备注：</p><p>1、默认的流量采样间隔为5分钟，流量间隔可根据实际需求调整，但最好不要太小，比如小于10秒。可打开文件<code>sslib.sh</code> ，修改<code>INTERVEL</code> 的值，单位为秒。</p><p>2、如果shadowsocks不是使用apt-get或者pip安装，无法自动找到 <code>ssserver</code> 文件时，请手动指定程序的具体位置。打开文件 <code>sslib.sh</code> ，修改 <code>SSSERVER</code> 的值，比如 <code>ssserver</code> 的路径为 <code>/usr/local/bin/ssserver</code> 时，修改为:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SSSERVER=/usr/local/bin/ssserver</span><br></pre></td></tr></table></figure><h3 id="5、To-Do-List"><a href="#5、To-Do-List" class="headerlink" title="5、To Do List"></a>5、To Do List</h3><p>既然身为抓包组里的一员，就要干点抓包相关的事，是不是。比如说，十分好奇为啥大家流量用得那么多呢，肯定看视频了，看啥视频了呢，<code>奥特曼大战葫芦娃.avi</code> ？初步打算在服务器上进行流量采样，比如万分之一的采样率，然后记录下对应账户的 <code>DNS</code>请求的 <code>query</code> 字段值，<code>client hello</code>中的<code>SNI</code>字段等。</p><p>最近比较忙（<del>其实就是懒</del>），回头抽空搞一发。。。嘻嘻</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;1、更新软件并安装vim&quot;&gt;&lt;a href=&quot;#1、更新软件并安装vim&quot; class=&quot;headerlink&quot; title=&quot;1、更新软件并安装vim&quot;&gt;&lt;/a&gt;1、更新软件并安装vim&lt;/h3&gt;&lt;figure class=&quot;highlight shell&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;sudo apt-get update&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;sudo apt-get upgrade&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;sudo apt-get install vim&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h3 id=&quot;2、更改-SSH-默认端口&quot;&gt;&lt;a href=&quot;#2、更改-SSH-默认端口&quot; class=&quot;headerlink&quot; title=&quot;2、更改 SSH 默认端口&quot;&gt;&lt;/a&gt;2、更改 SSH 默认端口&lt;/h3&gt;&lt;figure class=&quot;highlight shell&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;sudo vim /etc/ssh/sshd_config&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;找到 Port 字段，将其修改为自己想要的端口值&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;sudo service ssh restart         #重启ssh服务&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;sudo netstat -tunlp | grep ssh   #查看ssh服务监听的端口&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;这里将ssh端口改成了22222，如下图（PS:不要问我为啥强行改22号端口，就是任性，额，其实有点其他用途，青大校友表示当年我就是靠这个强行免费使用校园网）：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/2018/10/12/Ubuntu中配置SS多用户模式并限制每个用户的流量/ssh.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h3 id=&quot;3、安装shadowsocks-python版本&quot;&gt;&lt;a href=&quot;#3、安装shadowsocks-python版本&quot; class=&quot;headerlink&quot; title=&quot;3、安装shadowsocks-python版本&quot;&gt;&lt;/a&gt;3、安装shadowsocks-python版本&lt;/h3&gt;
    
    </summary>
    
      <category term="笔记" scheme="https://wangjibao.com.cn/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="笔记" scheme="https://wangjibao.com.cn/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode11-20</title>
    <link href="https://wangjibao.com.cn/2018/10/09/LeetCode11-20/"/>
    <id>https://wangjibao.com.cn/2018/10/09/LeetCode11-20/</id>
    <published>2018-10-09T12:45:18.000Z</published>
    <updated>2018-10-20T11:50:02.502Z</updated>
    
    <content type="html"><![CDATA[<h2 id="11、盛最多水的容器"><a href="#11、盛最多水的容器" class="headerlink" title="11、盛最多水的容器"></a>11、<a href="https://leetcode-cn.com/problems/container-with-most-water" target="_blank" rel="noopener">盛最多水的容器</a></h2><p>双指针，算法中一个很重要的技巧，之前的三数求和就用到了双指针的技巧。</p><p>我们在由线段长度构成的数组中使用两个指针，一个放在开始，一个置于末尾。 此外，我们会使用变量 <code>maxArea</code> 来持续存储到目前为止所获得的最大面积。 在每一步中，我们会找出指针所指向的两条线段形成的区域，更新 <code>maxArea</code>，并将指向较短线段的指针向较长线段那端移动一步。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxArea</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; height)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> maxArea = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> frontPoint = <span class="number">0</span>, endPoint = height.size()<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>( frontPoint&lt;endPoint )&#123;</span><br><span class="line">            maxArea = max( maxArea, (endPoint-frontPoint)*min(height[frontPoint], height[endPoint]) );</span><br><span class="line">            <span class="keyword">if</span>( height[frontPoint]&lt;height[endPoint] )</span><br><span class="line">                frontPoint++;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                endPoint--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxArea;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="12、整数转罗马数字"><a href="#12、整数转罗马数字" class="headerlink" title="12、整数转罗马数字"></a>12、<a href="https://leetcode-cn.com/problems/integer-to-roman" target="_blank" rel="noopener">整数转罗马数字</a></h2><p>水题一个，模拟一下即可。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">intToRoman</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt; pair&lt;<span class="keyword">int</span>,<span class="built_in">string</span>&gt; &gt; mp;</span><br><span class="line">        mp.push_back( make_pair(<span class="number">1000</span>,<span class="string">"M"</span>) );</span><br><span class="line">        mp.push_back( make_pair(<span class="number">900</span>,<span class="string">"CM"</span>) );</span><br><span class="line">        mp.push_back( make_pair(<span class="number">500</span>,<span class="string">"D"</span>) );</span><br><span class="line">        mp.push_back( make_pair(<span class="number">400</span>,<span class="string">"CD"</span>) );</span><br><span class="line">        mp.push_back( make_pair(<span class="number">100</span>,<span class="string">"C"</span>) );</span><br><span class="line">        mp.push_back( make_pair(<span class="number">90</span>,<span class="string">"XC"</span>) );</span><br><span class="line">        mp.push_back( make_pair(<span class="number">50</span>,<span class="string">"L"</span>) );</span><br><span class="line">        mp.push_back( make_pair(<span class="number">40</span>,<span class="string">"XL"</span>) );</span><br><span class="line">        mp.push_back( make_pair(<span class="number">10</span>,<span class="string">"X"</span>) );</span><br><span class="line">        mp.push_back( make_pair(<span class="number">9</span>,<span class="string">"IX"</span>) );</span><br><span class="line">        mp.push_back( make_pair(<span class="number">5</span>,<span class="string">"V"</span>) );</span><br><span class="line">        mp.push_back( make_pair(<span class="number">4</span>,<span class="string">"IV"</span>) );</span><br><span class="line">        mp.push_back( make_pair(<span class="number">1</span>,<span class="string">"I"</span>) );</span><br><span class="line">        <span class="built_in">string</span> ans = <span class="string">""</span>;</span><br><span class="line">        <span class="keyword">for</span>( <span class="built_in">vector</span>&lt; pair&lt;<span class="keyword">int</span>,<span class="built_in">string</span>&gt; &gt;:: iterator it = mp.begin(); it!=mp.end(); it++ )&#123;</span><br><span class="line">            <span class="keyword">while</span>( num&gt;=(*it).first )&#123;</span><br><span class="line">                ans += (*it).second;</span><br><span class="line">                num -= (*it).first;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="13、罗马数字转整数"><a href="#13、罗马数字转整数" class="headerlink" title="13、罗马数字转整数"></a>13、<a href="https://leetcode-cn.com/problems/roman-to-integer" target="_blank" rel="noopener">罗马数字转整数</a></h2><p>水题，直接模拟</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">romanToInt</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">map</span>&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt; mp;</span><br><span class="line">        mp[<span class="string">'I'</span>] = <span class="number">1</span>, mp[<span class="string">'V'</span>] = <span class="number">5</span>, mp[<span class="string">'X'</span>] = <span class="number">10</span>, mp[<span class="string">'L'</span>] = <span class="number">50</span>;</span><br><span class="line">        mp[<span class="string">'C'</span>] = <span class="number">100</span>, mp[<span class="string">'D'</span>] = <span class="number">500</span>, mp[<span class="string">'M'</span>] = <span class="number">1000</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; nums;</span><br><span class="line">        <span class="keyword">for</span>( <span class="keyword">int</span> i=<span class="number">0</span>; i&lt;s.length(); i++ )</span><br><span class="line">            nums.push_back( mp[s[i]] );</span><br><span class="line">        nums.push_back(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>( <span class="keyword">int</span> i=<span class="number">0</span>; i&lt;nums.size()<span class="number">-1</span>; i++ )&#123;</span><br><span class="line">            <span class="keyword">if</span>( nums[i]&lt;nums[i+<span class="number">1</span>] )&#123;</span><br><span class="line">                ans += nums[i+<span class="number">1</span>]-nums[i];</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                ans += nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="14、最长公共前缀"><a href="#14、最长公共前缀" class="headerlink" title="14、最长公共前缀"></a>14、<a href="https://leetcode-cn.com/problems/longest-common-prefix" target="_blank" rel="noopener">最长公共前缀</a></h2><p>没啥好方案，直接暴力即可。暴力的方式有多种，一种像这里直接每次一个字符一个字符的得出 <code>ans</code> ，也可以挨个字符串直接与 <code>ans（初值为字符串strs[0]）</code> 比较，逐渐缩小 <code>ans</code> 的长度，直到最后得出结果。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">longestCommonPrefix</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; strs)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>( strs.size()==<span class="number">0</span> )</span><br><span class="line">            <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">        <span class="keyword">int</span> lens = <span class="number">0</span>, i = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">string</span> ans = <span class="string">""</span>;</span><br><span class="line">        <span class="keyword">char</span> ch;</span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>( strs[<span class="number">0</span>].length() &gt; lens )</span><br><span class="line">                ch = strs[<span class="number">0</span>][lens];</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">return</span> ans;</span><br><span class="line">            <span class="keyword">for</span>( i=<span class="number">1</span>; i&lt;strs.size(); i++ )&#123;</span><br><span class="line">                <span class="keyword">if</span>( strs[i][lens]!=ch )</span><br><span class="line">                    <span class="keyword">return</span> ans;</span><br><span class="line">            &#125;</span><br><span class="line">            ans += ch;</span><br><span class="line">            lens++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="15、三数之和"><a href="#15、三数之和" class="headerlink" title="15、三数之和"></a>15、<a href="https://leetcode-cn.com/problems/3sum" target="_blank" rel="noopener">三数之和</a></h2><p>三数之和其实和前面的两数之和原理一样，都是使用的双指针。这里的三数，其实可以直接固定一数，然后调用前面写的两数之和的代码。唯一的一点 <code>trick</code> 可能就是在去重上。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; threeSum(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt; <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; ans;</span><br><span class="line">        <span class="keyword">if</span>( nums.size()&lt;<span class="number">3</span> )</span><br><span class="line">            <span class="keyword">return</span> ans;</span><br><span class="line">        <span class="comment">//对 nums 进行排序并去重(此处去重不合适)</span></span><br><span class="line">        sort( nums.begin(), nums.end() );</span><br><span class="line">        <span class="comment">//vector&lt;int&gt;:: iterator it = unique( nums.begin(), nums.end() );</span></span><br><span class="line">        <span class="comment">//nums.erase( it, nums.end() );</span></span><br><span class="line">        <span class="keyword">for</span>( <span class="keyword">int</span> i=<span class="number">0</span>; i&lt;nums.size()<span class="number">-2</span>; i++ )&#123;</span><br><span class="line">            <span class="keyword">if</span>( i&gt;<span class="number">0</span> &amp;&amp; nums[i<span class="number">-1</span>]==nums[i] )</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            findTwoSum( nums, i+<span class="number">1</span>, nums.size()<span class="number">-1</span>, i, ans );</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">findTwoSum</span><span class="params">( <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> s, <span class="keyword">int</span> e, <span class="keyword">int</span> target, <span class="built_in">vector</span>&lt; <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt;&amp; ans )</span></span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; step_ans;</span><br><span class="line">        <span class="keyword">while</span>( s&lt;e )&#123;</span><br><span class="line">            <span class="keyword">if</span>( nums[s]+nums[e] == -nums[target] )&#123;</span><br><span class="line">                step_ans.clear();</span><br><span class="line">                step_ans.push_back(nums[target]);</span><br><span class="line">                step_ans.push_back(nums[s]);</span><br><span class="line">                step_ans.push_back(nums[e]);</span><br><span class="line">                ans.push_back(step_ans);</span><br><span class="line">                s++;</span><br><span class="line">                e--;</span><br><span class="line">                <span class="keyword">while</span>( s &lt; e &amp;&amp; nums[s]==nums[s<span class="number">-1</span>] )</span><br><span class="line">                    s++;</span><br><span class="line">                <span class="keyword">while</span>( e &gt; s &amp;&amp; nums[e]==nums[e+<span class="number">1</span>] )</span><br><span class="line">                    e--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>( nums[s]+nums[e] &gt; -nums[target] )</span><br><span class="line">                e--;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                s++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="16、最接近的三数之和"><a href="#16、最接近的三数之和" class="headerlink" title="16、最接近的三数之和"></a>16、<a href="https://leetcode-cn.com/problems/3sum-closest" target="_blank" rel="noopener">最接近的三数之和</a></h2><p>和三数之和的原理一样，排序后使用双指针遍历找最优解。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">threeSumClosest</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        sort( nums.begin(), nums.end() );</span><br><span class="line">        <span class="keyword">int</span> nearest = nums[<span class="number">0</span>]+nums[<span class="number">1</span>]+nums[<span class="number">2</span>], tmpSum;</span><br><span class="line">        <span class="keyword">for</span>( <span class="keyword">int</span> i=<span class="number">0</span>; i&lt;nums.size()<span class="number">-2</span>; i++ )&#123;</span><br><span class="line">            <span class="keyword">int</span> f = i+<span class="number">1</span>, e = nums.size()<span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">while</span>( f&lt;e )&#123;</span><br><span class="line">                tmpSum = nums[f] + nums[e] + nums[i];</span><br><span class="line">                nearest = <span class="built_in">abs</span>(target-nearest)&gt;<span class="built_in">abs</span>(target-tmpSum)? tmpSum:nearest;</span><br><span class="line">                <span class="keyword">if</span>( tmpSum==target )</span><br><span class="line">                    <span class="keyword">return</span> target;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>( tmpSum &gt; target )</span><br><span class="line">                    e--;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    f++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nearest;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="17、电话号码的字母组合"><a href="#17、电话号码的字母组合" class="headerlink" title="17、电话号码的字母组合"></a>17、<a href="https://leetcode-cn.com/problems/letter-combinations-of-a-phone-number" target="_blank" rel="noopener">电话号码的字母组合</a></h2><p>一行深搜代码解决，2年没写搜索了，敲的时候好生疏。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; letterCombinations(<span class="built_in">string</span> digits) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; mp,ans;</span><br><span class="line">        <span class="built_in">string</span> cur_ans;</span><br><span class="line">        mp.push_back(<span class="string">""</span>);</span><br><span class="line">        mp.push_back(<span class="string">""</span>);</span><br><span class="line">        mp.push_back(<span class="string">"abc"</span>);</span><br><span class="line">        mp.push_back(<span class="string">"def"</span>);</span><br><span class="line">        mp.push_back(<span class="string">"ghi"</span>);</span><br><span class="line">        mp.push_back(<span class="string">"jkl"</span>);</span><br><span class="line">        mp.push_back(<span class="string">"mno"</span>);</span><br><span class="line">        mp.push_back(<span class="string">"pqrs"</span>);</span><br><span class="line">        mp.push_back(<span class="string">"tuv"</span>);</span><br><span class="line">        mp.push_back(<span class="string">"wxyz"</span>);</span><br><span class="line">        <span class="keyword">if</span>( digits.length() )</span><br><span class="line">            digitsToString( mp, digits, ans, cur_ans );</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">digitsToString</span><span class="params">( <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; mp, <span class="built_in">string</span> digits, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; ans, <span class="built_in">string</span> cur_ans )</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>( digits.length()==<span class="number">0</span> )&#123;</span><br><span class="line">            ans.push_back( cur_ans );</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>( <span class="keyword">int</span> i=<span class="number">0</span>; i&lt;mp[digits[<span class="number">0</span>]-<span class="string">'0'</span>].length(); i++ )&#123;</span><br><span class="line">            digitsToString( mp, digits.substr(<span class="number">1</span>), ans, cur_ans+mp[digits[<span class="number">0</span>]-<span class="string">'0'</span>][i] );</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="18、四数之和"><a href="#18、四数之和" class="headerlink" title="18、四数之和"></a>18、<a href="https://leetcode-cn.com/problems/4sum" target="_blank" rel="noopener">四数之和</a></h2><p>还是双指针操作（发现一个规律就是，前面这些和双指针操作相关的题目，一个典型的特点就是数组要先排个序），算法复杂度 $  O(n^3) $ ，其实有很多种解题方式。</p><p>第一种：双指针操作，先固定两个位置，然后 $ O(n) $ 的时间复杂度遍历剩下的元素，找解的过程中就去除可能存在的重复解，体现在代码中就是一片形式相同的<code>while</code>循环。</p><p>第二种：还是双指针操作，在求解的过程中，我不管解是否存在重复，一一加到<code>ans</code>里面，最后再进行一个去重处理。优点是编码简单，缺点是空间复杂度高，最坏情况下为$n^4$的空间复杂度（nums全为0，target也为0）。</p><p>第三种：以空间换时间，利用$ O(n^2) $的空间先求出两个数字的和，然后变成 <code>两数之和</code>  问题。</p><p>第四种：使用深搜操作，理论上来讲，此种方法可以求 <code>m</code> 数之和，时间复杂度为 $ O(n^{m-1}) $。</p><p>方案一代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; fourSum(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt; <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; ans;</span><br><span class="line">        <span class="keyword">if</span>( nums.size()&lt;<span class="number">4</span> )</span><br><span class="line">            <span class="keyword">return</span> ans;</span><br><span class="line">        sort( nums.begin(), nums.end() );</span><br><span class="line">        <span class="keyword">for</span>( <span class="keyword">int</span> i=<span class="number">0</span>; i&lt;nums.size()<span class="number">-3</span>; i++ )&#123;</span><br><span class="line">            <span class="keyword">for</span>( <span class="keyword">int</span> j=i+<span class="number">1</span>; j&lt;nums.size()<span class="number">-2</span>; j++ )&#123;</span><br><span class="line">                <span class="keyword">int</span> f = j+<span class="number">1</span>, e = nums.size()<span class="number">-1</span>;</span><br><span class="line">                <span class="keyword">while</span>( f&lt;e )&#123;</span><br><span class="line">                    <span class="keyword">int</span> sum = nums[i]+nums[j]+nums[f]+nums[e];</span><br><span class="line">                    <span class="keyword">if</span>( sum==target )&#123;</span><br><span class="line">                        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; tmp_ans;</span><br><span class="line">                        tmp_ans.push_back(nums[i]);</span><br><span class="line">                        tmp_ans.push_back(nums[j]);</span><br><span class="line">                        tmp_ans.push_back(nums[f]);</span><br><span class="line">                        tmp_ans.push_back(nums[e]);</span><br><span class="line">                        ans.push_back( tmp_ans );</span><br><span class="line">                        f++;</span><br><span class="line">                        <span class="keyword">while</span>( f&lt;e &amp;&amp; nums[f<span class="number">-1</span>]==nums[f] )&#123;</span><br><span class="line">                            f++;</span><br><span class="line">                        &#125;</span><br><span class="line">                        e--;</span><br><span class="line">                        <span class="keyword">while</span>( e&gt;f &amp;&amp; nums[e+<span class="number">1</span>]==nums[e] )&#123;</span><br><span class="line">                            e--;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span>( sum&gt;target )&#123;</span><br><span class="line">                        e--;</span><br><span class="line">                        <span class="keyword">while</span>( e&gt;f &amp;&amp; nums[e+<span class="number">1</span>]==nums[e] )&#123;</span><br><span class="line">                            e--;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span>&#123;</span><br><span class="line">                        f++;</span><br><span class="line">                        <span class="keyword">while</span>( f&lt;e &amp;&amp; nums[f<span class="number">-1</span>]==nums[f] )&#123;</span><br><span class="line">                            f++;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">while</span>( j+<span class="number">1</span>&lt;nums.size()<span class="number">-2</span> &amp;&amp; nums[j+<span class="number">1</span>]==nums[j] )&#123;</span><br><span class="line">                    j++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span>( i+<span class="number">1</span>&lt;nums.size()<span class="number">-3</span> &amp;&amp; nums[i+<span class="number">1</span>]==nums[i] )&#123;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="19、删除链表的倒数第N个节点"><a href="#19、删除链表的倒数第N个节点" class="headerlink" title="19、删除链表的倒数第N个节点"></a>19、<a href="https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list" target="_blank" rel="noopener">删除链表的倒数第N个节点</a></h2><p>一遍遍历即可，其实也是双指针的思想.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">removeNthFromEnd</span><span class="params">(ListNode* head, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        ListNode *dummy = (ListNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(ListNode));</span><br><span class="line">        dummy-&gt;next = head;</span><br><span class="line">        ListNode *f = dummy, *e = dummy;</span><br><span class="line">        <span class="keyword">for</span>( <span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++ )</span><br><span class="line">            e = e-&gt;next;</span><br><span class="line">        <span class="keyword">while</span>( e-&gt;next )&#123;</span><br><span class="line">            f = f-&gt;next;</span><br><span class="line">            e = e-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        f-&gt;next = f-&gt;next-&gt;next;</span><br><span class="line">        <span class="keyword">return</span> dummy-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="20、有效的括号"><a href="#20、有效的括号" class="headerlink" title="20、有效的括号"></a>20、<a href="https://leetcode-cn.com/problems/valid-parentheses" target="_blank" rel="noopener">有效的括号</a></h2><p>水题，使用栈匹配一下即可，遇到左括号进栈，遇见右括号出栈，最后判断栈是否为空。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isValid</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">stack</span>&lt;<span class="keyword">char</span>&gt; ans;</span><br><span class="line">        ans.push(<span class="string">'#'</span>); <span class="comment">//加栈底后期就不用判断空不空了</span></span><br><span class="line">        <span class="keyword">for</span>( <span class="keyword">int</span> i=<span class="number">0</span>; i&lt;s.length(); i++ )&#123;</span><br><span class="line">            <span class="keyword">if</span>( s[i]==<span class="string">'('</span> || s[i]==<span class="string">'['</span> || s[i]==<span class="string">'&#123;'</span> )</span><br><span class="line">                ans.push(s[i]);</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>( (s[i]==<span class="string">')'</span>&amp;&amp;ans.top()!=<span class="string">'('</span>) || (s[i]==<span class="string">']'</span>&amp;&amp;ans.top()!=<span class="string">'['</span>) || (s[i]==<span class="string">'&#125;'</span>&amp;&amp;ans.top()!=<span class="string">'&#123;'</span>) )</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    ans.pop();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans.top()==<span class="string">'#'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;11、盛最多水的容器&quot;&gt;&lt;a href=&quot;#11、盛最多水的容器&quot; class=&quot;headerlink&quot; title=&quot;11、盛最多水的容器&quot;&gt;&lt;/a&gt;11、&lt;a href=&quot;https://leetcode-cn.com/problems/container-with-most-water&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;盛最多水的容器&lt;/a&gt;&lt;/h2&gt;&lt;p&gt;双指针，算法中一个很重要的技巧，之前的三数求和就用到了双指针的技巧。&lt;/p&gt;
&lt;p&gt;我们在由线段长度构成的数组中使用两个指针，一个放在开始，一个置于末尾。 此外，我们会使用变量 &lt;code&gt;maxArea&lt;/code&gt; 来持续存储到目前为止所获得的最大面积。 在每一步中，我们会找出指针所指向的两条线段形成的区域，更新 &lt;code&gt;maxArea&lt;/code&gt;，并将指向较短线段的指针向较长线段那端移动一步。&lt;/p&gt;
&lt;figure class=&quot;highlight c++&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Solution&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt;:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;maxArea&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;built_in&quot;&gt;vector&lt;/span&gt;&amp;lt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt;&amp;gt;&amp;amp; height)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; maxArea = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; frontPoint = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;, endPoint = height.size()&lt;span class=&quot;number&quot;&gt;-1&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;while&lt;/span&gt;( frontPoint&amp;lt;endPoint )&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            maxArea = max( maxArea, (endPoint-frontPoint)*min(height[frontPoint], height[endPoint]) );&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;( height[frontPoint]&amp;lt;height[endPoint] )&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                frontPoint++;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                endPoint--;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; maxArea;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="LeetCode" scheme="https://wangjibao.com.cn/categories/LeetCode/"/>
    
      <category term="LeetCode11-20" scheme="https://wangjibao.com.cn/categories/LeetCode/LeetCode11-20/"/>
    
    
      <category term="LeetCode" scheme="https://wangjibao.com.cn/tags/LeetCode/"/>
    
  </entry>
  
</feed>
