<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>来呀，不服抓个包~~</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://wangjibao.com.cn/"/>
  <updated>2019-04-20T17:58:14.939Z</updated>
  <id>https://wangjibao.com.cn/</id>
  
  <author>
    <name>大宝哥spring</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>博客访问加速</title>
    <link href="https://wangjibao.com.cn/2019/04/21/%E5%8D%9A%E5%AE%A2%E8%AE%BF%E9%97%AE%E5%8A%A0%E9%80%9F/"/>
    <id>https://wangjibao.com.cn/2019/04/21/博客访问加速/</id>
    <published>2019-04-20T17:44:13.000Z</published>
    <updated>2019-04-20T17:58:14.939Z</updated>
    
    <content type="html"><![CDATA[<p>博客停更了将近半年的时间，然后近期闲着打算接着写写记录下日常学习过程，其中被同学吐槽，你这访问太慢了啊，页面好大会转不出来，怎么回事？<code>github pages</code>国内访问的话，速度还是很慢的，想要更好的提升访问速度，得将博客迁移到国内才行，幸运的是，国内的<code>coding.net</code>也提供<code>pages</code>服务。下面，我们主要讲解如何实现个人博客的<strong>双仓库</strong>部署。</p><p>#### </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;博客停更了将近半年的时间，然后近期闲着打算接着写写记录下日常学习过程，其中被同学吐槽，你这访问太慢了啊，页面好大会转不出来，怎么回事？&lt;code&gt;github pages&lt;/code&gt;国内访问的话，速度还是很慢的，想要更好的提升访问速度，得将博客迁移到国内才行，幸运的是，国
      
    
    </summary>
    
      <category term="笔记" scheme="https://wangjibao.com.cn/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="笔记" scheme="https://wangjibao.com.cn/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>Ubuntu个性美化</title>
    <link href="https://wangjibao.com.cn/2019/04/20/Ubuntu%E4%B8%AA%E6%80%A7%E7%BE%8E%E5%8C%96/"/>
    <id>https://wangjibao.com.cn/2019/04/20/Ubuntu个性美化/</id>
    <published>2019-04-20T08:26:33.000Z</published>
    <updated>2019-04-20T08:40:49.852Z</updated>
    
    <content type="html"><![CDATA[<p>1、<strong>安装<code>VMware Tools</code></strong></p><p>在<code>VMware</code>中安装虚拟机后，记得安装<code>VMware Tools</code>。在虚拟机中找到名为<code>VMwareTools…tar.gz</code>的压缩包（一般在<code>media</code>文件夹中），复制到某个文件夹中后执行：<code>tar -xvzf VMwareTools…tar.gz</code>进行解压。之后会看到一个 <code>./vmware-install.pl</code>的执行程序，执行后安装，一路默认即可，安装完成后，重启虚拟机。</p><p>2、<strong>卸载自带软件</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dpkg --list   # 查看自带已安装程序</span><br><span class="line">sudo apt-get --purge remove &lt;programname&gt;      # 卸载程序和所有配置文件</span><br><span class="line">sudo apt-get remove &lt;programname&gt;              # 只卸载程序</span><br></pre></td></tr></table></figure><p>当然也可以在<code>软件管理</code>中进行查看已安装软件，卸载软件等操作。</p><p>3、<strong><code>GTK</code>,<code>GTK+</code>,<code>Qt</code>, <code>KDE</code>,<code>GNOME</code>, <code>Unity</code>的区别与联系</strong></p><a id="more"></a><p>Linux本身没有图形界面，Linux现在的图形界面系统只是Linux下的应用程序。</p><p><code>GTK</code>,  <code>GTK+</code>, <code>Qt</code>是图形界面开发库(GUI Toolkit)，用户可以使用这些开发库编写GUI应用。</p><p><code>KDE</code>，<code>GNOME</code>，<code>Unity</code>是<code>linux</code>下的桌面环境(Desktop Environment)，其中<code>KDE</code>使用<code>Qt</code>开发，<code>GNOME</code>使用<code>GTK+</code>开发，<code>Unity</code>是基于<code>GNOME</code>开发的一个桌面环境。</p><p>从 <code>Ubuntu 16.04 LTS</code> 到<code>Ubuntu 18.04 LTS</code> 最显著的变化是 Unity 用户界面被替换为了GNOME 桌面环境。</p><p>4、<strong>安装美化主题</strong></p><p><a href="https://www.cnblogs.com/feipeng8848/p/8970556.html" target="_blank" rel="noopener">参考博客</a>，本文用到的主题工具包<a href="/download/Ubuntu美化.rar">下载</a></p><p>美化过程中涉及的两个目录：<code>/usr/share/themes</code> 和 <code>/usr/share/icons</code>。</p><p>1）安装 <code>TweakTool</code> 工具：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install gnome-tweak-tool</span><br><span class="line">sudo apt-get install gnome-shell-extensions   # 解决Tweaks中shell无法设置的问题</span><br></pre></td></tr></table></figure><p>2）安装<code>GTK</code>主题，修改图标，更改桌面<code>shell</code>，<a href="https://www.opendesktop.org/" target="_blank" rel="noopener">下载网址</a>，将主题和桌面shell放到<code>/usr/share/themes/</code>目录下，图标包放到<code>/usr/share/icons/</code>文件夹下，之后在<code>Tweaks</code>工具中，即可选择使用它们</p><p><img src="/2019/04/20/Ubuntu个性美化/tweaks.png" alt=""></p><p>效果图如下：</p><p><img src="/2019/04/20/Ubuntu个性美化/macos.png" alt=""></p><p>3）更改开机动画，<a href="https://www.gnome-look.org/" target="_blank" rel="noopener">下载网址</a></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">将下载的开机动画解压并拷贝到： usr/share/plymouth/themes</span><br><span class="line">sudo update-alternatives --install /usr/share/plymouth/themes/default.plymouth default.plymouth /usr/share/plymouth/themes/***/***.plymouth 100</span><br><span class="line">sudo update-alternatives --config default.plymouth  # 选择对应序号即可，*号代表当前使用</span><br><span class="line">sudo update-initramfs -u</span><br></pre></td></tr></table></figure><p>4）更改<a href="https://github.com/taeven/Ocean-blue-GDM3" target="_blank" rel="noopener">登录界面的背景</a>（也可只修改<code>css</code>文件中对应的图片链接即可）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">cp 下载的登录界面.jpg /usr/share/backgrounds/</span><br><span class="line"><span class="meta">#</span> 备份自带登录css文件</span><br><span class="line">cp /usr/share/gnome-shell/theme/ubuntu.css /usr/share/gnome-shell/theme/ubuntu.css.bak</span><br><span class="line">cp 下载的并更名为ubuntu.css的文件 /usr/share/gnome-shell/theme/</span><br><span class="line">reboot</span><br></pre></td></tr></table></figure><p>效果图：</p><p><img src="/2019/04/20/Ubuntu个性美化/login.png" alt=""></p><p>4）修改桌面<code>shell</code>的宽度和字体等。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;1、&lt;strong&gt;安装&lt;code&gt;VMware Tools&lt;/code&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在&lt;code&gt;VMware&lt;/code&gt;中安装虚拟机后，记得安装&lt;code&gt;VMware Tools&lt;/code&gt;。在虚拟机中找到名为&lt;code&gt;VMwareTools…tar.gz&lt;/code&gt;的压缩包（一般在&lt;code&gt;media&lt;/code&gt;文件夹中），复制到某个文件夹中后执行：&lt;code&gt;tar -xvzf VMwareTools…tar.gz&lt;/code&gt;进行解压。之后会看到一个 &lt;code&gt;./vmware-install.pl&lt;/code&gt;的执行程序，执行后安装，一路默认即可，安装完成后，重启虚拟机。&lt;/p&gt;
&lt;p&gt;2、&lt;strong&gt;卸载自带软件&lt;/strong&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight shell&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;dpkg --list   # 查看自带已安装程序&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;sudo apt-get --purge remove &amp;lt;programname&amp;gt;      # 卸载程序和所有配置文件&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;sudo apt-get remove &amp;lt;programname&amp;gt;              # 只卸载程序&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;当然也可以在&lt;code&gt;软件管理&lt;/code&gt;中进行查看已安装软件，卸载软件等操作。&lt;/p&gt;
&lt;p&gt;3、&lt;strong&gt;&lt;code&gt;GTK&lt;/code&gt;,&lt;code&gt;GTK+&lt;/code&gt;,&lt;code&gt;Qt&lt;/code&gt;, &lt;code&gt;KDE&lt;/code&gt;,&lt;code&gt;GNOME&lt;/code&gt;, &lt;code&gt;Unity&lt;/code&gt;的区别与联系&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="笔记" scheme="https://wangjibao.com.cn/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="笔记" scheme="https://wangjibao.com.cn/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>Ubuntu官方源和PPA源简介</title>
    <link href="https://wangjibao.com.cn/2019/04/20/Ubuntu%E5%AE%98%E6%96%B9%E6%BA%90%E5%92%8CPPA%E6%BA%90%E7%AE%80%E4%BB%8B/"/>
    <id>https://wangjibao.com.cn/2019/04/20/Ubuntu官方源和PPA源简介/</id>
    <published>2019-04-20T08:12:10.000Z</published>
    <updated>2019-04-20T08:25:32.475Z</updated>
    
    <content type="html"><![CDATA[<p>在<code>ubuntu</code>中，软件的安装主要有3种方式：</p><ul><li><p>通过<code>apt</code>包管理工具从官方软件源安装</p></li><li><p>通过<code>deb</code>格式的软件包安装，以安装<code>搜狗输入法</code>为例：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">下载 sogou.deb</span><br><span class="line">sudo dpkg -i sogou.deb       #出现安装不成功，需要依赖</span><br><span class="line">sudo apt-get install -f      #安装依赖</span><br><span class="line">sudo dpkg -i sogou.deb</span><br></pre></td></tr></table></figure></li><li><p>使用软件的源码手动编译安装</p></li></ul><p>下面我们主要介绍第一种安装方式，即<code>apt</code>命令从软件源安装。软件源分为 <code>Ubuntu官方软件源</code> 和 <code>PPA软件源</code> 两种。</p><a id="more"></a><p>1）<code>Ubuntu</code> 官方软件源，其中包含了系统中绝大多数的软件，对应的目录为 <code>/etc/apt/sources.list</code>，如下所示：</p><p><img src="/2019/04/20/Ubuntu官方源和PPA源简介/sources_list.png" alt=""></p><p>一般情况下，我们会将其改成国内的镜像源，因为访问国外的资源太慢了，<a href="https://segmentfault.com/a/1190000000375848" target="_blank" rel="noopener">国内开源镜像站点汇总</a>。</p><p>安装和卸载软件也非常的简单：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install &lt;package-name&gt;    # 安装</span><br><span class="line">sudo apt-get remove &lt;package-name&gt;     # 卸载</span><br></pre></td></tr></table></figure><p>每当通过 <code>install</code> 命令去安装一个软件时，apt 包管理工具就会从系统中的<code>/etc/apt/sources.list</code>文件或<code>/etc/apt/sources.list.d</code>文件夹中去读取软件源的网址信息，查找可以包含该软件的软件源的网址，然后就从这个网址上把指定的软件给下载下来，然后由 apt 包管理工具在本地进行一些解压和安装的其他操作。</p><p>2）<code>PPA(Personal Package Archives)</code>个人软件包集，它出现的原因是：系统自带的源是非常有限的 ，如果通过<code>deb</code>直接安装其他软件的话，得不到更新和维护，所以此时<code>PPA</code>软件源就应运而生。它其实是一个<a href="https://launchpad.net/" target="_blank" rel="noopener">网站</a>，开发者们在上面建立自己的仓库，上传开发的软件供用户安装。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo add-apt-repository ppa:user/ppa-name    # 添加ppa软件源</span><br><span class="line">sudo add-apt-repository --remove ppa:user/ppa-name    # 删除ppa软件源</span><br></pre></td></tr></table></figure><p>当添加完某个<code>ppa</code>软件源后，会在系统的 <code>/etc/apt/sources.list.d</code> 目录下生成对应的源文件：</p><p><img src="/2019/04/20/Ubuntu官方源和PPA源简介/sources_list_d.png" alt=""></p><p>可见，此操作就是在文件里添加了一个和软件源一模一样的东西，以 <code>notepad++</code> 的使用为例：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> 安装</span><br><span class="line">sudo add-apt-repository ppa:notepadqq-team/notepadqq</span><br><span class="line">sudo apt-get update   # 记得此时要更新一下软件源</span><br><span class="line">sudo apt-get install notepadqq</span><br><span class="line"><span class="meta">#</span> 卸载</span><br><span class="line">sudo apt-get remove notepadqq</span><br><span class="line">sudo add-apt-repository --remove ppa:notepadqq-team/notepadqq</span><br></pre></td></tr></table></figure><p>3）上面两个东西，其实要实现的功能是一样的，之所以在系统中存在<code>/etc/apt/sources.list</code>和<code>/etc/apt/sources.list.d</code>两套东西，是系统为了区分官方源与第三方源，毕竟第三方源存在安全问题的可能性比较大。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在&lt;code&gt;ubuntu&lt;/code&gt;中，软件的安装主要有3种方式：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;通过&lt;code&gt;apt&lt;/code&gt;包管理工具从官方软件源安装&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;通过&lt;code&gt;deb&lt;/code&gt;格式的软件包安装，以安装&lt;code&gt;搜狗输入法&lt;/code&gt;为例：&lt;/p&gt;
&lt;figure class=&quot;highlight shell&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;下载 sogou.deb&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;sudo dpkg -i sogou.deb       #出现安装不成功，需要依赖&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;sudo apt-get install -f      #安装依赖&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;sudo dpkg -i sogou.deb&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;使用软件的源码手动编译安装&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;下面我们主要介绍第一种安装方式，即&lt;code&gt;apt&lt;/code&gt;命令从软件源安装。软件源分为 &lt;code&gt;Ubuntu官方软件源&lt;/code&gt; 和 &lt;code&gt;PPA软件源&lt;/code&gt; 两种。&lt;/p&gt;
    
    </summary>
    
      <category term="笔记" scheme="https://wangjibao.com.cn/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="笔记" scheme="https://wangjibao.com.cn/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>HTTP抓包实战</title>
    <link href="https://wangjibao.com.cn/2018/11/13/HTTP%E6%8A%93%E5%8C%85%E5%AE%9E%E6%88%98/"/>
    <id>https://wangjibao.com.cn/2018/11/13/HTTP抓包实战/</id>
    <published>2018-11-13T15:39:06.000Z</published>
    <updated>2018-11-16T16:33:47.860Z</updated>
    
    <content type="html"><![CDATA[<p>开始读《HTTP抓包实战》，在这个作业满天飞的日子里，计划1周读完，本篇博文对其中的部分知识点做一下简单的记录。</p><p>1、HTTP抓包分析使用的工具不再是wireshark（研究TCP/IP协议使用），而是使用 <a href="https://www.telerik.com/fiddler" target="_blank" rel="noopener">fiddler</a>，版本4。其实 fiddler 做HTTP数据包分析的原理就是相当于一个<strong>web代理</strong>，如下图：</p><p><img src="/2018/11/13/HTTP抓包实战/web_proxy.png" alt=""></p><p>fiddler在中间，可以记录所用的HTTP流量。fiddler启动时，会偷偷把 Internet 选项中的代理修改为 ：127.0.0.1,端口： 8888; fiddler在关闭时，会自动在Internet选项中取消代理，这样就不会对其他程序产生影响。如下图：</p><p><img src="/2018/11/13/HTTP抓包实战/127001.png" alt=""></p><a id="more"></a><p>fiddler界面如下图，使用方法请自行百度或google.</p><p><img src="/2018/11/13/HTTP抓包实战/fiddler.png" alt=""></p><p>2、在 <code>fiddler</code>中抓取 <code>https</code> 的流量，需要做如下图配置并安装证书。</p><p><img src="/2018/11/13/HTTP抓包实战/ca.png" alt=""></p><p>像 <code>IE</code>，<code>chrome</code>等浏览器都是使用<code>windows</code>证书库来验证证书，但是<code>firefox</code>浏览器是自己维护一个证书列表，所以需要在<code>firefox</code>中单独安装 <code>fiddler</code>证书。在上图中的<code>action</code>选项中可以下载<code>fiddler</code>的根证书到桌面，<code>firefox &gt;&gt; 工具 &gt;&gt; 选项 &gt;&gt; 隐私与安全 &gt;&gt; 证书 &gt;&gt; 查看证书 &gt;&gt; 证书机构</code>中可以导入证书，这里，<code>fiddler</code>的作者开了个玩笑，证书名叫<code>DO_NOT_TRUST_FiddlerRoot</code>。</p><p>3、在抓包时，我们经常能看到 <code>tunnel to</code>的握手包，这对我们分析数据包没啥作用，可以在<code>fiddler &gt;&gt; rules &gt;&gt; hide connects</code>中设置其隐藏掉。</p><p><img src="/2018/11/13/HTTP抓包实战/tunnelto.png" alt=""></p><p>4、Win+R输入<code>certmgr.msc</code>查看<code>windows</code>证书管理库</p><p><img src="/2018/11/13/HTTP抓包实战/certmgr.png" alt=""></p><p>5、<code>https://www.wangjibao.com.cn/2018/11/13/HTTP%E6%8A%93%E5%8C%85%E5%AE%9E%E6%88%98/#more</code></p><p>上面是个<code>url</code>的例子，<code>https</code>协议，<code>www.wangjibao.com.cn</code>为域名，这里使用的是默认<code>80</code>端口，所以省略端口显示，后面的<code>/2018/11/13/HTTP%E6%8A%93%E5%8C%85%E5%AE%9E%E6%88%98/</code>代表资源的路径，后面的<code>#</code>号代表啥呢，其实这是个 <code>锚点(anchor)</code>，我们知道，当一个页面非常长的时候，我们可以在页面中根据锚点直接定位到我们需要的地方。</p><p>6、HTTP的状态码，200类是成功，300类代表重定向，400类代表客户端错误，500类错误代表服务器错误。</p><p>其中的<code>206(Partial Content)</code>代表的是部分内容，迅雷、HTTP下载工具就是使用<code>206</code>状态码来实现的断点续传。</p><p>当遇到<code>301 或 302</code>的响应时，浏览器会自动根据<code>response</code>中的重定向<code>url</code>重新访问资源地址。如下图（京东之前叫<code>360buy</code>)：</p><p><img src="/2018/11/13/HTTP抓包实战/location.png" alt=""></p><p>先访问<code>www.360buy.com</code>返回<code>301</code>说这个网址已经<code>move permanently</code>了，给了个<code>http://www.jd.com</code>，然后，浏览器就是访问这个网址，但是服务器说<code>302</code>，代表说，这次对了，但是为了安全，去访问另一个网址吧<code>https://www.jd.com</code>吧，接着就会发现，129号中显示了<code>tunnel to</code>，代表开始握手协商了。</p><p>其实，这里<code>301或302</code>还是有区别的，<code>301</code>代表旧<code>url</code>已经永久移除了，搜索引擎会把权重计算到新的<code>url</code>上。但<code>302</code>代表旧<code>url</code>还在，只是临时重定向到新<code>url</code>上，搜索引擎会把权重计算到旧<code>url</code>上。</p><p>7、常用的HTTP请求方法就是 <code>get</code>和<code>post</code>。</p><p><img src="/2018/11/13/HTTP抓包实战/post.png" alt=""></p><p>我们登录国科大的选课网站，在 <code>fildder</code>中，可以清楚的看到，用户名和密码被包含在<code>post</code>请求的<code>body</code>中，发送给了服务器。同样，如果是<code>get</code>请求，包含在<code>url</code>中<code>?</code>后面的字段可以在<code>QueryString</code>中看到对应的<code>Name--Value</code>字段。</p><p>8、可以在<code>fiddler &gt;&gt; tools &gt;&gt; user-agent</code>中修改<code>User-Agent</code>字段的值，如下图，再浏览某些网页时，就变成了对应的显示模式。</p><p><img src="/2018/11/13/HTTP抓包实战/user-agent.png" alt=""></p><p>9、Ajax (<strong>A</strong>synchronous  <strong>J</strong>avascript  <strong>A</strong>nd  <strong>X</strong>ML”: 异步 JavaScript 和 XML）,是一种在无需重新加载整个网页的情况下，能够更新部分网页的技术。</p><p>10、在 <code>Rules &gt;&gt; Automatic Breakpoint &gt;&gt; after/before Response</code>中可以设置拦截<code>HTTP</code>请求。比如，我可以设置拦击HTTP的响应，然后在<code>raw</code>中修改页面的<code>title</code>字段，点击<code>Run to Completion</code>发成修改后的发送。</p><p><img src="/2018/11/13/HTTP抓包实战/breakpoint.png" alt=""></p><p>1号包中的红色代表拦截到了，这时别忘了，<strong>之前设置的全局断点给取消掉</strong>，不然会影响其他请求的发送和接收。效果如下图：</p><p><img src="/2018/11/13/HTTP抓包实战/modifyresponse.png" alt=""></p><p>注意：修改操作必须在<code>raw</code>选项框里。当然，也可以设置局部断点，<code>bpu www.baidu.com</code>设置只拦截百度的请求，取消拦截在页面左下角的命令框中输入<code>bpu</code>即可；<code>bpafter www.baidu.com</code>拦截响应，<code>bpafter</code>取消拦截响应。</p><p>11、浏览器中的缓存</p><p>如下图，浏览器想请求某个资源的时候，先检查本地缓存，如果本地缓存存在这个文件的时候，直接获取该文件的最后修改时间等信息，构造数据包发送请求（内含有<code>If-Modified-Since</code>字段和<code>If-None-Match</code>字段）给服务器，服务器根据这两个值，结合自身的<code>Last-Modified</code>字段和<code>Etag</code>字段来判断需不需要发送数据给浏览器，如果不需要（1、Request中的If-Modified-Since的时间大于或等于Resonse中的Last-Modified的时间；2、ETag值和If-None-Match相匹配，说明hash值不变文档没改变），则服务器发送 <code>304 Response</code>给浏览器，告诉它，直接使用缓存就行了，节省时间加快网页加载速度。</p><p><img src="/2018/11/13/HTTP抓包实战/lastmodify.png" alt=""></p><p>当然，我们也可以 <code>ctrl + F5</code>强制刷新浏览器，告诉服务器，我不使用缓存，请发送最新的数据资源给我。</p><p><img src="/2018/11/13/HTTP抓包实战/nocache.png" alt=""></p><p>其中的<code>pragma</code>是HTTP1.0中使用的，<code>Cache-Control</code>是现在HTTP1.1用的，同时存在这两个字段，完全是为了兼容。</p><p>12、<code>URL</code>只能使用英文字母、数字或者某些标点符号，URL Encode(URL 编码)就是把所有非英文字母、数字字符都替换成百分号（%）后加两位十六进制数。如：</p><p><code>https://www.wangjibao.com.cn/2018/11/13/HTTP抓包实战</code> 编码后变成了如下模式，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://www.wangjibao.com.cn/2018/11/13/HTTP%E6%8A%93%E5%8C%85%E5%AE%9E%E6%88%98/</span><br></pre></td></tr></table></figure><p>13、<code>Fiddler</code>提供了丰富的插件，可以在<a href="https://www.telerik.com/fiddler/add-ons中下载安装使用，如`Java" target="_blank" rel="noopener">https://www.telerik.com/fiddler/add-ons中下载安装使用，如`Java</a> Script Formatter<code>、</code>Gallery<code>、</code>WinDiff`（比较两个session的不同）等等。</p><p>14、 <code>Fiddler</code>中可以在线调试 <code>JavaScript</code>文件，使用的是<code>AutoResponder</code>功能，如下图，其原理就是当命中某个文件时，自动替换成我们设置的文件返回给客户端，就不去服务器索取了。</p><p><img src="/2018/11/13/HTTP抓包实战/js.png" alt=""></p><p>当然，不仅可以替换 <code>JS</code> 文件，还可以替换网页中的图片为本地我们设置的图片。</p><p>15、我们还可以直接编辑<code>Fiddler Script</code>来修改HTTP请求或者响应，并且不中断程序（之前介绍的设置断点的方式，会使得程序中断）。<code>Rules &gt;&gt; Coustomize Rules</code>中，打开<code>Fiddler ScriptEditor</code>来编辑<code>CustomRules.js</code>文件，如图：</p><p><img src="/2018/11/13/HTTP抓包实战/scripteditor.png" alt=""></p><p>16、HTTP的<code>Cookie</code>机制</p><p>因为<code>HTTP</code>协议是无状态的，可以通过<code>Cookie</code>来维持会话。登录 <code>http://piaoweb.sstm.org.cn</code>，可以在<code>fiddler</code>中看到<code>cookie</code>的运行机制，如下图：</p><p><img src="/2018/11/13/HTTP抓包实战/cookie.png" alt=""></p><p>浏览器把<code>Cookie</code>通过HTTP请求中的<code>Header</code>发送给服务器，同时，服务器通过HTTP响应中的<code>Header</code>(Set-Cookie机制)把<code>Cookie</code>发送给浏览器。</p><p>上图中的 <code>HttpOnly</code>字段是说通过<code>JavaScript</code>脚本无法读取到<code>Cookie</code>信息，可以有效防止<code>XSS</code>攻击。</p><p>浏览器根据服务器返回的<code>Set-Cookie</code>设置好本地<code>Cookie</code>以后，浏览器每次请求服务器的资源时，就在<code>Header</code>中将<code>Cookie</code>附加上，这样，服务器就认为浏览器是登录状态。</p><p>17、Cookie劫持攻击</p><p>这里我们使用<code>豆瓣</code>网为例，演示一下<code>Cookie</code>劫持攻击。</p><p>（1）登录<a href="https://www.douban.com/" target="_blank" rel="noopener">豆瓣网</a>，用<code>Fiddler</code>抓取登录过程产生的数据包，可以看到一个如下图中的包，里面含有我们需要的<code>cookie</code>。</p><p><img src="/2018/11/13/HTTP抓包实战/doubanaccount.png" alt=""></p><p>（2）我们打开这个会话的<code>session</code>，可以看到用户的<code>cookie</code>，其中的<code>dbcl2</code>是和用户登录相关的。</p><p><img src="/2018/11/13/HTTP抓包实战/accounts.png" alt=""></p><p>（3）我们在该会话上右键，<code>replay &gt;&gt; Reissue and Edit</code>，将cookie中的此字段删除，然后<code>Run to Completion</code>放行，可以看到此时我们现在是非登录状态，并且跳转到了登录界面，服务器返回<code>302</code>。</p><p><img src="/2018/11/13/HTTP抓包实战/relocation.png" alt=""></p><p>（4）现在我们知道，这个<code>cookie</code>字段就是和用户登录相关的，并且已经劫持到了，那么如何利用它呢？可以利用之前提到的<code>Fiddler Script</code>，编写脚本，每次发送数据包的时候，自动加上这个cookie不就行了，并且这个操作不会有任何中断。</p><p>在 <code>Fiddler Script</code>中的<code>OnBeforeRequest</code>函数中添加如下代码段：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(oSession.uriContains(<span class="string">"douban.com"</span>))&#123;</span><br><span class="line"><span class="keyword">var</span> sCookie = <span class="string">"dbcl2=\"170842457:NW8ZWiZHFUU\""</span>;</span><br><span class="line">oSession.oRequest[<span class="string">"Cookie"</span>] = sCookie;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再次访问豆瓣网，发现自己已经处于登录状态了。</p><p>18、<code>HTTP</code>基本验证</p><p>把<code>用户名+冒号+密码</code>用<code>Base64</code>编码后生成字符串，放在<code>header</code>中的<code>Authorization</code>字段中，发送给服务器。</p><p>19、手机<code>Fiddler</code>抓包</p><p>手机和电脑处于同一局域网中，在<code>fiddler &gt;&gt; Tools &gt;&gt; Options &gt;&gt; Connections</code>中将<code>allow remote computers to connect</code>勾选上，同时在手机的<code>wlan</code>设置中，将其代理设置成电脑，<code>IP</code>为电脑IP，端口为<code>8888</code>；同时，在手机的安全设置中可以安装之前下载的<code>fiddler root</code>根证书，这样，就可以捕获到手机的<code>https</code>数据包了。</p><p>20、<code>Replay</code>菜单的详细说明：</p><p><code>Reissue Requests</code>：重新发送请求，和菜单栏上的<code>Replay</code>按钮是一样的功能。</p><p><code>Reissue Unconditionally</code>：无条件反复发送选中的请求。</p><p><code>Reissue and Edit</code>：把选中的请求以原来的形式重新发送，在每个新的<code>Session</code>中设置断点，在请求发送给服务器之前，可以修改请求。</p><p><code>Reissue and Verify</code>：重新发送请求，检查响应，如果响应和上一个请求一样，就会变成绿色。</p><p><code>Reissue Sequentially</code>：选中多个<code>Session</code>会按顺序一个一个重新发送请求，是单线程模式。</p><p><code>Reissue from Composer</code>：在<code>Composer</code>中编辑该请求。</p><p><code>Revisit in IE</code>：在<code>IE</code>浏览器中用<code>Get</code>方法访问这个请求。</p><p>21、重放攻击，在<code>Fiddler</code>中，可以使用<code>Composer</code>编辑数据包并进行发送。</p><p><img src="/2018/11/13/HTTP抓包实战/composer.png" alt=""></p><p>其实，重放攻击危害很大，比如说，某网站的投票或者点赞功能，当我们抓取到某个点赞的包时，我们可以重复发送这个数据包来进行刷票。再比如说，某些软件的注册，当我们抓取到某个注册请求包的时候，我们进行大量重复发送，对<code>app</code>造成的损失还是很大的。</p><p>解决方案：在<code>HTTP</code>请求中，添加时间戳<code>stamp</code>和数字签名<code>sign</code>。数字签名保证有效性，时间戳保证时效性。</p><p>22、后面的3–4个章节是使用<code>JMeter</code>对网站做自动化测试和压力测试的，在此略过。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;开始读《HTTP抓包实战》，在这个作业满天飞的日子里，计划1周读完，本篇博文对其中的部分知识点做一下简单的记录。&lt;/p&gt;
&lt;p&gt;1、HTTP抓包分析使用的工具不再是wireshark（研究TCP/IP协议使用），而是使用 &lt;a href=&quot;https://www.telerik.com/fiddler&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;fiddler&lt;/a&gt;，版本4。其实 fiddler 做HTTP数据包分析的原理就是相当于一个&lt;strong&gt;web代理&lt;/strong&gt;，如下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/2018/11/13/HTTP抓包实战/web_proxy.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;fiddler在中间，可以记录所用的HTTP流量。fiddler启动时，会偷偷把 Internet 选项中的代理修改为 ：127.0.0.1,端口： 8888; fiddler在关闭时，会自动在Internet选项中取消代理，这样就不会对其他程序产生影响。如下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/2018/11/13/HTTP抓包实战/127001.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="笔记" scheme="https://wangjibao.com.cn/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="笔记" scheme="https://wangjibao.com.cn/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>小知识科普</title>
    <link href="https://wangjibao.com.cn/2018/11/12/%E5%B0%8F%E7%9F%A5%E8%AF%86%E7%A7%91%E6%99%AE/"/>
    <id>https://wangjibao.com.cn/2018/11/12/小知识科普/</id>
    <published>2018-11-12T15:52:28.000Z</published>
    <updated>2018-11-12T16:26:51.535Z</updated>
    
    <content type="html"><![CDATA[<p>本篇博文记录一下平时生活中遇到的小知识，不定期更新。</p><h4 id="1、判断USB接口类型"><a href="#1、判断USB接口类型" class="headerlink" title="1、判断USB接口类型"></a>1、判断USB接口类型</h4><p>晚上同学过来借扩展坞，看了眼USB接口的颜色，问，这是2.0的口吗？很明显，本渣渣耗费 199大洋 采购的东东，怎么能不是 3.0 的口呢。其实凭借USB接口的颜色能够一定程度上判断接口类型，但并不一定准确。</p><p>准确的做法是：看<strong>接口的针脚数</strong> ，<code>USB2.0</code> 的针脚数目是 <strong>4</strong> 个，<code>USB3.0</code> 的针脚数目是 <strong>9</strong> 个。如下图：</p><p><img src="/2018/11/12/小知识科普/usb2.png" alt=""></p><p>上图是本渣18年从青大毕业时，学院发的纪念U盘，4个引脚，USB2.0的接口。为啥发U盘呢，18年在青岛开上合峰会的时候正值毕业季，各种大型活动统统不让搞，往年的毕业歌会也被无情的取消，那么办晚会的钱就拿来每人发个U盘吧，反正大家都是搞计算机的，以后也用得到，话说要发好歹也发个3.0口的u盘呗，吐槽一下。不过，当时每个U盘里都拷了毕业纪念视频，还是挺走心的，这个得表扬一波。</p><a id="more"></a><p>多说一句，<strong>信息安全班</strong>里当时毕业没有毕业聚餐你敢相信！？？其实知道现在想起来，还是耿耿于怀，原因大家也都心知肚明，怎么说，无愧于心就好！</p><p><img src="/2018/11/12/小知识科普/usb3.png" alt=""></p><p>上图是<strong>3.0</strong> 的口，<strong>9</strong>个引脚能看清不，外面 <strong>5</strong> 个，里面 <strong>4</strong> 个。想一下，为啥2.0的东西插到3.0的口也能正常使用，是不就是使用的里面那<strong>4</strong>个引脚，外面那<strong>5</strong>个是闲着的，当插入3.0的东西时，这9个引脚会全部起作用。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本篇博文记录一下平时生活中遇到的小知识，不定期更新。&lt;/p&gt;
&lt;h4 id=&quot;1、判断USB接口类型&quot;&gt;&lt;a href=&quot;#1、判断USB接口类型&quot; class=&quot;headerlink&quot; title=&quot;1、判断USB接口类型&quot;&gt;&lt;/a&gt;1、判断USB接口类型&lt;/h4&gt;&lt;p&gt;晚上同学过来借扩展坞，看了眼USB接口的颜色，问，这是2.0的口吗？很明显，本渣渣耗费 199大洋 采购的东东，怎么能不是 3.0 的口呢。其实凭借USB接口的颜色能够一定程度上判断接口类型，但并不一定准确。&lt;/p&gt;
&lt;p&gt;准确的做法是：看&lt;strong&gt;接口的针脚数&lt;/strong&gt; ，&lt;code&gt;USB2.0&lt;/code&gt; 的针脚数目是 &lt;strong&gt;4&lt;/strong&gt; 个，&lt;code&gt;USB3.0&lt;/code&gt; 的针脚数目是 &lt;strong&gt;9&lt;/strong&gt; 个。如下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/2018/11/12/小知识科普/usb2.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;上图是本渣18年从青大毕业时，学院发的纪念U盘，4个引脚，USB2.0的接口。为啥发U盘呢，18年在青岛开上合峰会的时候正值毕业季，各种大型活动统统不让搞，往年的毕业歌会也被无情的取消，那么办晚会的钱就拿来每人发个U盘吧，反正大家都是搞计算机的，以后也用得到，话说要发好歹也发个3.0口的u盘呗，吐槽一下。不过，当时每个U盘里都拷了毕业纪念视频，还是挺走心的，这个得表扬一波。&lt;/p&gt;
    
    </summary>
    
      <category term="笔记" scheme="https://wangjibao.com.cn/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="笔记" scheme="https://wangjibao.com.cn/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>树莓派搭建智能路由器</title>
    <link href="https://wangjibao.com.cn/2018/11/12/%E6%A0%91%E8%8E%93%E6%B4%BE%E6%90%AD%E5%BB%BA%E6%99%BA%E8%83%BD%E8%B7%AF%E7%94%B1%E5%99%A8/"/>
    <id>https://wangjibao.com.cn/2018/11/12/树莓派搭建智能路由器/</id>
    <published>2018-11-12T15:40:44.000Z</published>
    <updated>2018-11-12T17:14:51.290Z</updated>
    
    <content type="html"><![CDATA[<p>使用树莓派搭建一个小智能路由器，文档为当年做本科毕业设计时写的，单纯的一个环境搭建记录，放出来，喜欢玩的小伙伴说不定可以参考一下。</p><a id="more"></a><div class="row">    <embed src="树莓派搭建智能路由器.pdf" width="100%" height="550" type="application/pdf"></div>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;使用树莓派搭建一个小智能路由器，文档为当年做本科毕业设计时写的，单纯的一个环境搭建记录，放出来，喜欢玩的小伙伴说不定可以参考一下。&lt;/p&gt;
    
    </summary>
    
      <category term="资料" scheme="https://wangjibao.com.cn/categories/%E8%B5%84%E6%96%99/"/>
    
    
      <category term="资料" scheme="https://wangjibao.com.cn/tags/%E8%B5%84%E6%96%99/"/>
    
  </entry>
  
  <entry>
    <title>算法课第三次作业</title>
    <link href="https://wangjibao.com.cn/2018/11/12/%E7%AE%97%E6%B3%95%E8%AF%BE%E7%AC%AC%E4%B8%89%E6%AC%A1%E4%BD%9C%E4%B8%9A/"/>
    <id>https://wangjibao.com.cn/2018/11/12/算法课第三次作业/</id>
    <published>2018-11-12T15:39:55.000Z</published>
    <updated>2018-11-13T17:17:47.819Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1、书面作业"><a href="#1、书面作业" class="headerlink" title="1、书面作业"></a>1、书面作业</h3><p>懒得将 latex 转成 markdown了，直接传个PDF得了。</p><a id="more"></a><div class="row">    <embed src="Algorithm3-Greedy.pdf" width="100%" height="550" type="application/pdf"></div><h3 id="5、Cross-the-river"><a href="#5、Cross-the-river" class="headerlink" title="5、Cross the river"></a>5、<a href="http://theory.ict.ac.cn/grad_oj/contest/4/problem/31" target="_blank" rel="noopener">Cross the river</a></h3><p>贪心的基本思想：最重的人和最轻的人如果不超载重，就一起过河，如何超重，就最重的人自己一条船单独过河。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> n,l;</span><br><span class="line">    <span class="keyword">int</span> weight[<span class="number">50005</span>];</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; l;</span><br><span class="line">    <span class="keyword">for</span>( <span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; i++ )&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>,weight+i);</span><br><span class="line">    &#125;</span><br><span class="line">    sort(weight,weight+n);</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>, left = <span class="number">0</span>, right = n<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span>( left&lt;=right )&#123;</span><br><span class="line">        ans++;</span><br><span class="line">        <span class="keyword">if</span>( weight[right]+weight[left] &lt;= l )&#123;</span><br><span class="line">            left++;</span><br><span class="line">            right--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            right--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6、Assign-banana-to-monkeys"><a href="#6、Assign-banana-to-monkeys" class="headerlink" title="6、Assign banana to monkeys"></a>6、<a href="http://theory.ict.ac.cn/grad_oj/contest/4/problem/32" target="_blank" rel="noopener">Assign banana to monkeys</a></h3><p>贪心的基本思路：先按照位置排序，位于第 i 个位置的猴子就拿第 i 个位置的香蕉就好。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> monkey[<span class="number">5000005</span>];</span><br><span class="line"><span class="keyword">int</span> banana[<span class="number">5000005</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">char</span> ch;</span><br><span class="line">    <span class="keyword">do</span>&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>,monkey+n);</span><br><span class="line">        n++;</span><br><span class="line">    &#125;<span class="keyword">while</span>( (ch=getchar())!=<span class="string">'\n'</span> );</span><br><span class="line">    sort(monkey, monkey+n);</span><br><span class="line"></span><br><span class="line">    n=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">do</span>&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>,banana+n);</span><br><span class="line">        n++;</span><br><span class="line">    &#125;<span class="keyword">while</span>( (ch=getchar())!=<span class="string">'\n'</span> );</span><br><span class="line">    sort( banana, banana+n );</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>( <span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; i++ )&#123;</span><br><span class="line">        ans = max( ans, <span class="built_in">abs</span>(monkey[i] - banana[i]) );</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;1、书面作业&quot;&gt;&lt;a href=&quot;#1、书面作业&quot; class=&quot;headerlink&quot; title=&quot;1、书面作业&quot;&gt;&lt;/a&gt;1、书面作业&lt;/h3&gt;&lt;p&gt;懒得将 latex 转成 markdown了，直接传个PDF得了。&lt;/p&gt;
    
    </summary>
    
      <category term="作业" scheme="https://wangjibao.com.cn/categories/%E4%BD%9C%E4%B8%9A/"/>
    
      <category term="算法课第一次作业" scheme="https://wangjibao.com.cn/categories/%E4%BD%9C%E4%B8%9A/%E7%AE%97%E6%B3%95%E8%AF%BE%E7%AC%AC%E4%B8%80%E6%AC%A1%E4%BD%9C%E4%B8%9A/"/>
    
    
      <category term="作业" scheme="https://wangjibao.com.cn/tags/%E4%BD%9C%E4%B8%9A/"/>
    
  </entry>
  
  <entry>
    <title>wireshark网络分析的艺术</title>
    <link href="https://wangjibao.com.cn/2018/11/07/wireshark%E7%BD%91%E7%BB%9C%E5%88%86%E6%9E%90%E7%9A%84%E8%89%BA%E6%9C%AF/"/>
    <id>https://wangjibao.com.cn/2018/11/07/wireshark网络分析的艺术/</id>
    <published>2018-11-07T08:21:17.000Z</published>
    <updated>2018-11-12T03:38:29.334Z</updated>
    
    <content type="html"><![CDATA[<p>1、Linux服务器在收到 SSH 访问请求时，会先查询该客户端 IP 所对应的 PTR 记录（ IP 反向解析，由 IP 地址 获得对应的DNS，常用在垃圾邮件过滤）。假如经过5秒钟还没有收到回复，就再发一次查询。如果第二次查询还是等了5秒还没回复，就彻底放弃查询。</p><p>解决方式： <code>cat /etc/ssh/sshd_config | grep -i usedns</code> ，如果显示 <code>usedns yes</code> ,将其设置成 <code>no</code>即可。</p><p> 其中 <code>grep</code>是文本处理工具，同 <code>sed</code>、<code>awk</code>被称为文本处理三剑客。<code>-i</code> 代表忽略大小写的区别（ignore)。</p><p>2、启用 <code>TCP SACK</code>（ selective acknowledgement) 功能，在大量丢包时，不需要每个重传包都确认一次。可以在 <code>ack</code> 数据包中，告知对方哪些包我已经收到了，比如说，当前 <code>ack = 100</code> ，包中的 <code>sack 字段等于 107--120</code>，那么可以一次性完成 <code>100--106</code> 号包的重传，节约时间。</p><p>3、延迟确认</p><p>当要发送一个 <code>ack</code> 数据包的时候，因为纯粹的ack数据包只是单纯的确认，不含有其他有用信息。启用延迟确认，当收到一个 <code>seq</code>时，不立即发送 <code>ack</code>，而是稍等一会，当本地有数据要发送时，将信息加在 <code>ack</code>数据包里，就一起带过去了，节省带宽。</p><p>4、数据接收方可以积累一些包才对发送方 <code>ack</code> 一次。</p><p>5、愚笨窗口综合症（silly window syndrome)—“小包问题“</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">纳格（Nagle)算法:</span><br><span class="line">if 有新数据要发送</span><br><span class="line">if 数据量超过 MSS (即一个 TCP 包所能携带的最大数据量，通常为 1500-20tcp头-20ip头)</span><br><span class="line">立即发送</span><br><span class="line">else</span><br><span class="line">if 之前发出去的数据尚未确认</span><br><span class="line">把新数据缓存起来，凑够 MSS 或等确认到达再发送</span><br><span class="line">else</span><br><span class="line">立即发送</span><br><span class="line">end if</span><br><span class="line">end if</span><br><span class="line">end if</span><br></pre></td></tr></table></figure><a id="more"></a><p>6、延迟确认和 nagle 算法不能一起用，容易造成网络延迟大的要命</p><p>7、虽然说是 TCP 的三次握手，四次挥手，但是有时候，四次挥手，并不一定就是4个数据包，有可能是3个，即中间的 2号包的 <code>ACK</code> 和3号包的 <code>FIN</code> 结合在一起，形成一个数据包。</p><p>8、NTLM（ NT LAN Manager）,一种身份认证协议</p><p><img src="/2018/11/07/wireshark网络分析的艺术/NTLM.png" alt=""></p><ul><li>客户端向服务器发送一个 NTLM 协商请求，然后服务器立即回复一个随机字符串作为 challenge。</li><li>客户端收到 challenge 之后，向服务器回复 用户名，以及两个 response(用hash过的用户密码对 challenge加密得到的)</li><li>服务器不知道如何验证真假，所以将 <code>challenge</code> 和 两个<code>response</code> 都转发给 域控<code>Domain Controller</code> ，让域控去帮忙验证真假。</li><li>域控收到后，也用 <code>hash</code>过的用户密码对 <code>challenge</code>进行加密。如果加密结果和 <code>reponse</code>一样，说明密码正确，身份验证通过。</li></ul><p>由于从数据包里就能看到 <code>challenge</code> 和 <code>response</code> ，算法也是固定的，所以并不安全。</p><p>9、Kerberos（安全认证协议）</p><p>认证过程如下图，<code>kerberos</code> 认证是个双向的过程，即<code>client</code>可以验证<code>server</code>，<code>server</code> 也可以认证 <code>client</code>。</p><p><img src="/2018/11/07/wireshark网络分析的艺术/kerberos.png" alt=""></p><p>$\blacksquare$ <strong>相关名词解释</strong></p><ul><li>KDC ( key distributed center ): 整个安全认证过程的票据生成管理服务，包括 AS 和 TGS 服务。</li><li>AS ( authentication service ): 为 client 生成TGT的服务。</li><li>TGS( ticket granting service ): 为 client 生成某个服务器的 ticket。</li><li>TGT ( ticket-granting ticket ): 用于获取 ticket 的票据。  </li></ul><p>$\blacksquare$ <strong>认证过程</strong></p><p>(1) client 向 KDC 中的 AS  发送数据，表明自己的身份，AS对client的身份进行验证，验证通过后返给 client一个 TGT.</p><p>(2) client 拿着这个 TGT，给TGS发送数据，说我想访问某个 server。然后TGS会将会话密钥$K_{client-server}$用 client master key加密后传送给client；与此同时，TGS也会将会话密钥$K_{client-server}$连同client的基本信息打包用server master key加密也发client，并经client转发给server，至此client与KDC的交互完成。</p><p>(3) client用自己的 master key 解密 TGS 传过来的第一个包，解密后获得会话密钥$K_{client-server}$，并用这个密钥加密自己的的信息和时间戳打包后传送给server。</p><p>(4) server会收到两个数据包，一个用会话密钥加密，一个用自己的master key加密，server先用自己的master<br>key解密获取会话密钥和一份关于client的信息，然后server拿到解密后获取到的会话密钥再解开另外一个数据包，获得另一份关于client的信息和时间戳，对比一下这两份数据，一样即可验证通过。</p><p>详细过程请参照：<a href="https://blog.csdn.net/yangyang19920306/article/details/51673460" target="_blank" rel="noopener">https://blog.csdn.net/yangyang19920306/article/details/51673460</a></p><p>10、<code>TCP Fast Retransmission</code> ，当发送方收到3个及以上 <code>[TCP Dup ACK]</code> 时，就立刻重传它。</p><p><code>[TCP window Full]</code> 和 <code>[TCP zerowindow]</code> ，前者表示这个包的发送方暂时没办法再发送数据了（比如说接收方之前告诉我，接收窗口是100，我把100个数据发送过去了，但是都没有收到回复，可能在去的途中，所以为了保险起见，我不能再接着发送了）。后者表示这个包的发送方没办法再接收数据了（告诉对方，我的接收窗口满了，别再发了）。</p><p>11、LSO（ large segment offload）</p><p>传统的网络工作方式是这样的：应用层把产生的数据交给TCP层，TCP层再根据MSS大小进行分段（有CPU负责）,然后再交给网卡。而启用LSO之后，TCP层就可以把大于MSS的数据块直接传给网卡，让网卡来负责分段的工作。其实在数据量较大时，数据分段计算校验和等简单操作也挺浪费CPU资源的。在计算机的网卡，高级设置里可以启用这一功能，如下图：</p><p><img src="/2018/11/07/wireshark网络分析的艺术/lso.png" alt=""></p><p>详细说明：<a href="https://www.cnblogs.com/tcicy/p/8442225.html" target="_blank" rel="noopener">https://www.cnblogs.com/tcicy/p/8442225.html</a></p><p>12、TCP中的拥塞控制机制</p><p><img src="/2018/11/07/wireshark网络分析的艺术/cwnd.png" alt=""></p><p>了解其中的 慢开始、拥塞避免、快重传、快恢复机制。</p><p>详细说明：<a href="https://blog.csdn.net/jtracydy/article/details/52366461" target="_blank" rel="noopener">https://blog.csdn.net/jtracydy/article/details/52366461</a></p><p>13、有一种 拥塞窗口的计算方式： $ cwnd = cwnd + MSS*\frac{n \times MSS}{cwnd} $ .  n 代表当前接收到的 ack 的个数，当每个数据片返回一个 ack的时候，这个算法是没问题的，即 $\frac{n \times MSS}{cwnd} = 1$ , 每次拥塞窗口增大一个，如上图中的“拥塞避免”状态。但是，我们之前说过，并不是每个数据片都会返回一个 ack 的，有可能攒了好几个才 ack 一次，所以，这种计算方法存在问题，解决方法是关掉网卡中的 <code>Large Receive Offload</code>。</p><p>14、前面逼逼了辣么多，真实环境抓几个包说道说道。</p><p><img src="/2018/11/07/wireshark网络分析的艺术/tcppcap.png" alt=""></p><p>就拿上面截图的数据包说事吧，数据包<a href="/download/tcppcap.pcap">下载链接</a></p><center>185.199.109.153 为服务器端，192.168.199.160 为 客户端。</center><p>(1) 通信过程详解</p><p>首先，<strong>1203号</strong>包服务器端发送了seq = 939400，len = 1460。</p><p>紧接着客户端回复 <strong>1204号包</strong>，说我已经收到了 ack = 939400+1460 = 940860号包。</p><p>正常情况下，服务器接着应该发送 seq = 940860的包给客户端，但是，在 <strong>1205号</strong>包中，客户端却收到了 seq = 942320 , len = 1460 的数据包，wireshark显示 [ TCP Previous segment not captured ]，说明前一个包（seq = 940860的数据包）可能丢了。</p><p>既然数据包丢了，客户端就得发送 ack 接着请求，所以，在<strong>1206号</strong>包中，客户端第二次要求服务器端发送 seq = 940860 的数据，wireshark显示 [ TCP Dup ACK 1204#1 ]，代表这是1204号包的再一次请求。</p><p>接着，<strong>1207号</strong>包，客户端收到了 seq = 943780，len = 1460 的数据包（ 942320 + 1460 = 943780） 。</p><p><strong>1208号</strong>包，还没收到 seq = 940860  的数据包，客户端那个气啊，妹的，我再一次重复要求服务器重发 ack = 940860，出现了[ TCP Dup ACK 1204#2 ].</p><p>在<strong>1209号</strong>包中，客户端收到了 seq = 946700 ， len = 1460 的数据包，现在问题比较大了，两个应该收到的数据包却没有收到，分别是 seq = 940860, seq = 945240 (1207中：943780+1460 = 945240）。同样的，wireshark显示 [ TCP Previous segment not captured  ]。</p><p>接着，问题得到了改善，在<strong>1210号</strong>包中，客户端收到了本应该早收到的 seq = 945240, len = 1460 的数据包。wireshark显示 [ TCP Out-Of-Order ]，这也说明了，在真实的网络环境中，数据包并不一定是按序到达的。</p><p>客户端收到了 seq = 945240 ，seq = 946700(945240+1460) 的数据包，应该发送确认，直到此时，那个 seq = 940860 的包还是没给我发来，丫丫的，在<strong>1211号</strong>包 和 <strong>1212号</strong>包中客户端再一次发送 ack = 940860，要求服务器发送 seq = 940860号包给我，wireshark显示[ TCP Dup ACK 1204#3 ]，[TCP Dup ACK 1204#4 ]。</p><p>在下面的<strong>1213</strong> ( seq = 946700+1460 = 948160 )、<strong>1214</strong>、<strong>1215</strong> (seq = 948160+1460 = 949620 )、<strong>1216</strong>、<strong>1217</strong> ( seq = 949620+1460 = 951080 )、<strong>1218</strong>号，6个数据包还是重演之前的画面，客户端收到的是后面的数据包，每收到一个包，就重复确认一次 ack = 940860, 于是出现了图中的 [ TCP Dup ACK 1204#5 ] 、 [ TCP Dup ACK 1204#6 ]、 [ TCP Dup ACK 1204#7 ] 。</p><p>最终，好现象终于出现，<strong>1219号</strong>包，服务器终于发来了盼望已久的 seq = 940860， len = 1460 。一起顺利，所有问题已经解决。由于是乱序到达的，wireshark显示 [ TCP Out-Of-Order ]。</p><p>在 <strong>1220号</strong>包中，客户端发送对 seq = 940860 的确认，因为之前已经接收到了 seq = 951080+1460 = 952540，所以此时就显示的 ack = 952540 。</p><p>接下来，一切正常。</p><p>(2) SACK字段展示</p><p><img src="/2018/11/07/wireshark网络分析的艺术/sackshow.png" alt=""></p><p>拿 1211 号数据包详细说一下之前提到的 <code>SACK</code> 字段。1211数据包是 ack 1209号数据包的吧。有个事实是：我本应该收到 seq = 940860 的，但是，从1205和1207号包中，我收到的是 seq = 942320, seq = 943780 ，所以此时，1211的TCP头部可选字段的 <code>sack : 942320---945240</code> (943780+1460 = 955240)。从1209号数据包中我收到的是 seq = 946700，所以 1211数据包的TCP头部字段记录第二个 <code>sack : 946700---948160</code> (946700+1460 = 948160) 。</p><p>在TCP的头部可选字段记录这个两个字段值，花掉了 20 字节，所以TCP的头部长度变成了 20 + 20 = 40 Bytes.</p><p>同样的，当客户端收到了 1210 号数据包的时候，是不是就把这两个字段中间空缺的那 1460 ( 946700-945240 = 1460 ) 字节给补上了。所以，在 <strong>1212号</strong> ack 数据包中，<code>sack : 942320---948160</code> ,如上图所示。</p><p>那么当之前没收到的 seq = 940860 也收到的时候，这个 sack字段就没啥意义了，直接没有了，如 1220号ack包展示的那样。到此，一切那么的完美。</p><p>sack字段在变化，同样的，ack 数据包的头部长度也在变化，如上图中： 74 &gt;&gt; 66 &gt;&gt; 54。每次 ack 都会 <del>浪费</del> 一定的带宽，所以，出现了下面的收到多个 seq ，客户端才 ack 一次。</p><p>(3) 之前说过，真实的环境中，并不会每个数据包都 ack 一次，如下图，在这里是每收到 2 个数据包才发送一个 ack。</p><p><img src="/2018/11/07/wireshark网络分析的艺术/tcppack.png" alt=""></p><p> 15、TCP在三次握手的时候，客户端与服务器之间会协商 MSS 的大小，防止应用层发送的数据在 IP 层被分片。虽然，分片有时候是不可控的，比如数据包中间经过路由器时，也有可能被路由器分片。</p><p>协商过程如下图：</p><p><img src="/2018/11/07/wireshark网络分析的艺术/MSS.png" alt=""></p><p>客户端说我的 MSS = 1460， 但是服务器说他的 MSS = 1370，所以，在接下来的数据包中，应用层的数据按照 MSS= 1370 的大小来传输。</p><p>16、通过如下命令构造分片的包</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ping &lt;ip&gt; -l 9000 -n 4</span><br></pre></td></tr></table></figure><p>其中的 <code>-l</code> 参数指定发送的 ping 包的大小，9000 Bytes，所以会被分片处理，如下图所示。 <code>-n</code>指定发送的包的个数，还可以使用 <code>-f</code>    参数，指定发送的包不允许分片，即 <code>DF = 1</code>。</p><p><img src="/2018/11/07/wireshark网络分析的艺术/ICMP.png" alt=""></p><p>可以看到，分片数据包的 <code>off</code> 偏移字段，客户端可以根据 <code>ID</code> 字段，识别这是属于哪一个数据的分片包。那么，客户端如何确定什么时候开始重组这些分片的数据包？可以根据分片数据包的 <code>MF</code> 字段，最后一个分片包的 <code>MF = 0</code> ，代表这是最后一个数据包了，后面没有数据了，这时，客户端就可以重组这些分片的数据包了。</p><p>有一种网络的攻击方式： 往客户端持续发送 <code>MF = 1</code> 的数据包，导致客户端一直缓存分片，导致内存耗尽。</p><p>17、TCP中避免拥塞的方式有： 接收端通过<strong>接收窗口</strong>的大小来通知发送端，告知其数据接收能力。同时，发送端</p><p>通过<strong>拥塞控制</strong>算法来动态调整自己的数据发送量。其中：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">当前数据发送量 = min( 接收窗口大小， 拥塞控制值大小 )</span><br></pre></td></tr></table></figure><p>18、因为TCP头中只给接收窗口预留了16个比特（因为当时设计的时候，全世界的带宽都很小）,这就意味着它最大只能表示$2^{16} - 1 = 65535$ 字节，网络发展到今天明显不够用啊。后来，想到了一个解决方案，在TCP三次握手的时候，在可选字段中告知对方一个叫 <code>window scale</code> 的值，对方将这个值当做 2 的指数，算出来的值再作为接收窗口的系数。有了这个系数，就可以把接收窗口扩展好多倍了。</p><p><img src="/2018/11/07/wireshark网络分析的艺术/WS.png" alt=""></p><p>从上图中可以看出，客户端告诉服务器，自己的 Win = 65535,放大倍数为 2 倍；接着服务器告诉客户端，自己的 Win = 13600, 放大倍数为 WS = 128 倍。</p><p>数据包详情如下图：</p><p><img src="/2018/11/07/wireshark网络分析的艺术/windowscale.png" alt=""></p><p>19、思考：一个服务器是如何使用 80 端口同时为多个客户端提供服务的？根据连接建立时创建的<strong>五元组</strong>区分。详细点可以看 <strong>多路 I/O复用 epoll</strong>。</p><p>20、在网络层，也就是IP层头部，有那么几个字段：<code>identification</code>、<code>flags</code>、<code>offset</code> 。因为IP层是无连接的，每产生一个数据报，<code>identification</code>就加 1 ，如果中途的路由器将其分片后，接收端可以根据 <code>flags</code> 中的 <code>MF</code>、<code>DF</code>字段以及<code>片偏移</code>字段，将同一个 <code>identification</code> 的数据报重新组装起来。</p><p>21、一种流量劫持的手段如下图所示：</p><p><img src="/2018/11/07/wireshark网络分析的艺术/dns.png" alt=""></p><p>实线代表真实的流量，虚线代表劫持的流量。实现的原理就是，我假的服务比你真的服务先响应客户端，这样，等到真的数据来的时候，就会被用户无情的丢弃掉了。</p><p>可以通过查看数据包中的 <code>TTL</code> 值，分析流量是否存在被劫持的可能性。</p><p>22、HTTP &gt;&gt; HTTP1.1 &gt;&gt; SPDY &gt;&gt; HTTP2.0     QUIC(基于UDP)</p><p>23、<code>[ TCP zerowindow ]</code> 表示这个包的发送方已经没有办法再<strong>接收</strong>数据了，对应包中显示 <code>win = 0</code> 。</p><p><code>[ TCP window Full ]</code> 表示这个包的发送方暂时没有办法再<strong>发送</strong>数据了，已经把对方声称的接收窗口已经发满了确没收到ack，只能先暂停。<del>计算在途字节数</del></p><p>24、书上午看完了，总得来说，作业没有在刻意的讲述知识点，通过一个个案例，真实的说明网络知识是如何应用到现实生活的，内容比较基础，对初学者来说不错的书！</p><p>屁股后面跟着一堆作业，就这样吧。找个时间，读一下 <code>tshark</code> 的官方文档，感觉功能很强，用得好的话可以省很多事。<a href="https://www.wireshark.org/docs/man-pages/tshark.html" target="_blank" rel="noopener">https://www.wireshark.org/docs/man-pages/tshark.html</a></p><p>之前当当搞活动，加上双十一，买了好多书，下一本：《python黑帽子 黑客与渗透测试编程之道》。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;1、Linux服务器在收到 SSH 访问请求时，会先查询该客户端 IP 所对应的 PTR 记录（ IP 反向解析，由 IP 地址 获得对应的DNS，常用在垃圾邮件过滤）。假如经过5秒钟还没有收到回复，就再发一次查询。如果第二次查询还是等了5秒还没回复，就彻底放弃查询。&lt;/p&gt;
&lt;p&gt;解决方式： &lt;code&gt;cat /etc/ssh/sshd_config | grep -i usedns&lt;/code&gt; ，如果显示 &lt;code&gt;usedns yes&lt;/code&gt; ,将其设置成 &lt;code&gt;no&lt;/code&gt;即可。&lt;/p&gt;
&lt;p&gt; 其中 &lt;code&gt;grep&lt;/code&gt;是文本处理工具，同 &lt;code&gt;sed&lt;/code&gt;、&lt;code&gt;awk&lt;/code&gt;被称为文本处理三剑客。&lt;code&gt;-i&lt;/code&gt; 代表忽略大小写的区别（ignore)。&lt;/p&gt;
&lt;p&gt;2、启用 &lt;code&gt;TCP SACK&lt;/code&gt;（ selective acknowledgement) 功能，在大量丢包时，不需要每个重传包都确认一次。可以在 &lt;code&gt;ack&lt;/code&gt; 数据包中，告知对方哪些包我已经收到了，比如说，当前 &lt;code&gt;ack = 100&lt;/code&gt; ，包中的 &lt;code&gt;sack 字段等于 107--120&lt;/code&gt;，那么可以一次性完成 &lt;code&gt;100--106&lt;/code&gt; 号包的重传，节约时间。&lt;/p&gt;
&lt;p&gt;3、延迟确认&lt;/p&gt;
&lt;p&gt;当要发送一个 &lt;code&gt;ack&lt;/code&gt; 数据包的时候，因为纯粹的ack数据包只是单纯的确认，不含有其他有用信息。启用延迟确认，当收到一个 &lt;code&gt;seq&lt;/code&gt;时，不立即发送 &lt;code&gt;ack&lt;/code&gt;，而是稍等一会，当本地有数据要发送时，将信息加在 &lt;code&gt;ack&lt;/code&gt;数据包里，就一起带过去了，节省带宽。&lt;/p&gt;
&lt;p&gt;4、数据接收方可以积累一些包才对发送方 &lt;code&gt;ack&lt;/code&gt; 一次。&lt;/p&gt;
&lt;p&gt;5、愚笨窗口综合症（silly window syndrome)—“小包问题“&lt;/p&gt;
&lt;figure class=&quot;highlight shell&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;纳格（Nagle)算法:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;if 有新数据要发送&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	if 数据量超过 MSS (即一个 TCP 包所能携带的最大数据量，通常为 1500-20tcp头-20ip头)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		立即发送&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	else&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		if 之前发出去的数据尚未确认&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;			把新数据缓存起来，凑够 MSS 或等确认到达再发送&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		else&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;			立即发送&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		end if&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	end if&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;end if&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="笔记" scheme="https://wangjibao.com.cn/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="笔记" scheme="https://wangjibao.com.cn/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>VSCode配置Latex</title>
    <link href="https://wangjibao.com.cn/2018/11/05/VSCode%E9%85%8D%E7%BD%AELatex/"/>
    <id>https://wangjibao.com.cn/2018/11/05/VSCode配置Latex/</id>
    <published>2018-11-05T01:40:31.000Z</published>
    <updated>2018-11-05T02:44:26.521Z</updated>
    
    <content type="html"><![CDATA[<p>因为CTeX套装自带WinEdt编辑器难用、收费且不能实时编译显示pdf效果，本笔记主要记录如何在VSCode中编辑Tex文件，实现代码自动补全及实时查看文本编辑效果等功能。</p><h4 id="1、软件下载"><a href="#1、软件下载" class="headerlink" title="1、软件下载"></a>1、软件下载</h4><p>CTEX下载地址：<a href="http://www.ctex.org/HomePage，建议下载完整版套装。" target="_blank" rel="noopener">http://www.ctex.org/HomePage，建议下载完整版套装。</a></p><p>VSCode下载地址：<a href="https://code.visualstudio.com/" target="_blank" rel="noopener">https://code.visualstudio.com/</a></p><h4 id="2、软件配置"><a href="#2、软件配置" class="headerlink" title="2、软件配置"></a>2、软件配置</h4><h5 id="在VSCode中安装对应的插件"><a href="#在VSCode中安装对应的插件" class="headerlink" title="在VSCode中安装对应的插件"></a>在VSCode中安装对应的插件</h5><p><img src="/2018/11/05/VSCode配置Latex/plugin.png" alt=""></p><h5 id="更改配置文件"><a href="#更改配置文件" class="headerlink" title="更改配置文件"></a>更改配置文件</h5><p>在<code>file &gt;&gt; preferences &gt;&gt; setting &gt;&gt; User Setting &gt;&gt; Extensions &gt;&gt; LaTex Workshop configuration &gt;&gt; active</code> 中，打开 <code>Edit in setting.json</code> 文件。在文件中添加如下字段：</p><a id="more"></a><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">"latex-workshop.latex.recipes": [&#123;</span><br><span class="line">"name": "xelatex",</span><br><span class="line">"tools": ["xelatex"]</span><br><span class="line">&#125;, &#123;</span><br><span class="line">"name": "latexmk",</span><br><span class="line">"tools": ["latexmk"]</span><br><span class="line">&#125;, &#123;</span><br><span class="line">"name": "pdflatex -&gt; bibtex -&gt; pdflatex*2",</span><br><span class="line">"tools": ["pdflatex", "bibtex", "pdflatex", "pdflatex"]</span><br><span class="line">&#125;],</span><br></pre></td></tr></table></figure><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">"latex-workshop.latex.tools": [&#123;</span><br><span class="line">"name": "latexmk",</span><br><span class="line">"command": "latexmk",</span><br><span class="line">"args": ["-synctex=1", "-interaction=nonstopmode", "-file-line-error", "-pdf", "%DOC%"]</span><br><span class="line">&#125;, &#123;</span><br><span class="line">"name": "xelatex",</span><br><span class="line">"command": "xelatex",</span><br><span class="line">"args": ["-synctex=1", "-interaction=nonstopmode", "-file-line-error", "%DOC%"]</span><br><span class="line">&#125;, &#123;</span><br><span class="line">"name": "pdflatex",</span><br><span class="line">"command": "pdflatex",</span><br><span class="line">"args": ["-synctex=1", "-interaction=nonstopmode", "-file-line-error", "%DOC%"]</span><br><span class="line">&#125;, &#123;</span><br><span class="line">"name": "bibtex",</span><br><span class="line">"command": "bibtex",</span><br><span class="line">"args": ["%DOCFILE%"]</span><br><span class="line">&#125;],</span><br></pre></td></tr></table></figure><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">"latex-workshop.view.pdf.viewer": "tab",</span><br></pre></td></tr></table></figure><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">"latex-workshop.latex.clean.fileTypes": ["*.aux", "*.bbl", "*.blg", "*.idx", "*.ind", "*.lof", "*.lot", "*.out", "*.toc", "*.acn", "*.acr", "*.alg", "*.glg", "*.glo", "*.gls", "*.ist", "*.fls", "*.log", "*.fdb_latexmk"],</span><br></pre></td></tr></table></figure><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">"latex-workshop.latex.clean.enabled": false,</span><br></pre></td></tr></table></figure><p>添加后的效果如下图所示：</p><p><img src="/2018/11/05/VSCode配置Latex/jsoncode.png" alt=""></p><h4 id="3、开启自动保存，实时查看编辑效果"><a href="#3、开启自动保存，实时查看编辑效果" class="headerlink" title="3、开启自动保存，实时查看编辑效果"></a>3、开启自动保存，实时查看编辑效果</h4><p>在 <code>file</code>中将 <code>auto saved</code>勾选上即可。效果如下图：</p><p><img src="/2018/11/05/VSCode配置Latex/show.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;因为CTeX套装自带WinEdt编辑器难用、收费且不能实时编译显示pdf效果，本笔记主要记录如何在VSCode中编辑Tex文件，实现代码自动补全及实时查看文本编辑效果等功能。&lt;/p&gt;
&lt;h4 id=&quot;1、软件下载&quot;&gt;&lt;a href=&quot;#1、软件下载&quot; class=&quot;headerlink&quot; title=&quot;1、软件下载&quot;&gt;&lt;/a&gt;1、软件下载&lt;/h4&gt;&lt;p&gt;CTEX下载地址：&lt;a href=&quot;http://www.ctex.org/HomePage，建议下载完整版套装。&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://www.ctex.org/HomePage，建议下载完整版套装。&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;VSCode下载地址：&lt;a href=&quot;https://code.visualstudio.com/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://code.visualstudio.com/&lt;/a&gt;&lt;/p&gt;
&lt;h4 id=&quot;2、软件配置&quot;&gt;&lt;a href=&quot;#2、软件配置&quot; class=&quot;headerlink&quot; title=&quot;2、软件配置&quot;&gt;&lt;/a&gt;2、软件配置&lt;/h4&gt;&lt;h5 id=&quot;在VSCode中安装对应的插件&quot;&gt;&lt;a href=&quot;#在VSCode中安装对应的插件&quot; class=&quot;headerlink&quot; title=&quot;在VSCode中安装对应的插件&quot;&gt;&lt;/a&gt;在VSCode中安装对应的插件&lt;/h5&gt;&lt;p&gt;&lt;img src=&quot;/2018/11/05/VSCode配置Latex/plugin.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h5 id=&quot;更改配置文件&quot;&gt;&lt;a href=&quot;#更改配置文件&quot; class=&quot;headerlink&quot; title=&quot;更改配置文件&quot;&gt;&lt;/a&gt;更改配置文件&lt;/h5&gt;&lt;p&gt;在&lt;code&gt;file &amp;gt;&amp;gt; preferences &amp;gt;&amp;gt; setting &amp;gt;&amp;gt; User Setting &amp;gt;&amp;gt; Extensions &amp;gt;&amp;gt; LaTex Workshop configuration &amp;gt;&amp;gt; active&lt;/code&gt; 中，打开 &lt;code&gt;Edit in setting.json&lt;/code&gt; 文件。在文件中添加如下字段：&lt;/p&gt;
    
    </summary>
    
      <category term="笔记" scheme="https://wangjibao.com.cn/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="笔记" scheme="https://wangjibao.com.cn/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>数据科学导论作业</title>
    <link href="https://wangjibao.com.cn/2018/11/04/%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E5%AF%BC%E8%AE%BA%E4%BD%9C%E4%B8%9A/"/>
    <id>https://wangjibao.com.cn/2018/11/04/数据科学导论作业/</id>
    <published>2018-11-04T07:56:57.000Z</published>
    <updated>2018-11-19T13:24:18.626Z</updated>
    
    <content type="html"><![CDATA[<p>第一次作业：<a href="/download/数据科学导论第一次作业.rar">点击下载</a></p><p>怎么说，对这门课就是默默告诉自己，习惯就好。默默贴个 github 地址：</p><p><a href="https://github.com/justmarkham/DAT8" target="_blank" rel="noopener">https://github.com/justmarkham/DAT8</a></p><p>第二次作业：<a href="/download/数据科学导论第二次作业.rar">点击下载</a></p><p>同样，还是贴几个<code>github</code>链接地址：</p><p><a href="https://github.com/lamalor/ds100/blob/182feda62685b0988f4b4afb52c85256f4ac7d92/hw6/hw6.ipynb" target="_blank" rel="noopener">https://github.com/lamalor/ds100/blob/182feda62685b0988f4b4afb52c85256f4ac7d92/hw6/hw6.ipynb</a></p><p><a href="https://github.com/Dhanush123/data100/blob/master/hw6/hw6.ipynb" target="_blank" rel="noopener">https://github.com/Dhanush123/data100/blob/master/hw6/hw6.ipynb</a></p><p><a href="https://github.com/iewaij/introDataScience/blob/1eb96b44721ed6cc40761a7e3003f11a5c243cc3/legacy/material/homework/DS100%20SP17/hw5/hw5_solution.ipynb" target="_blank" rel="noopener">https://github.com/iewaij/introDataScience/blob/1eb96b44721ed6cc40761a7e3003f11a5c243cc3/legacy/material/homework/DS100%20SP17/hw5/hw5_solution.ipynb</a></p><p><a href="https://github.com/dovahcrow/ds100/blob/30d629246c87f2fafbf10c155545c30344be23e6/sp17/hw/hw5/hw5_solution.ipynb" target="_blank" rel="noopener">https://github.com/dovahcrow/ds100/blob/30d629246c87f2fafbf10c155545c30344be23e6/sp17/hw/hw5/hw5_solution.ipynb</a></p><h4 id="1、更改juypter默认工作路径"><a href="#1、更改juypter默认工作路径" class="headerlink" title="1、更改juypter默认工作路径"></a>1、更改juypter默认工作路径</h4><p>在 <code>anaconda prompt</code> 中执行命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jupyter notebook --generate-config</span><br></pre></td></tr></table></figure><p>即可查看 <code>jupyter_notebook_config.py</code> 配置文件的位置，打开配置文件 <code>jupyter_notebook_config.py</code>，搜索关键字 <code>notebook_dir</code> ，将值设置为自己想要的工作目录并取消注释即可（注意路径中不能有中文）；</p><p><img src="/2018/11/04/数据科学导论作业/juypter.png" alt=""></p><p>然后右击 <code>jupyter notebook</code> 快捷方式，将属性中的 “目标” 字段的值，去掉末尾的 <code>%USERPROFILE%</code> ，点击 <code>应用</code>，<code>确定</code>即可。</p><a id="more"></a><h4 id="2、jupyter使用anaconda虚拟python环境"><a href="#2、jupyter使用anaconda虚拟python环境" class="headerlink" title="2、jupyter使用anaconda虚拟python环境"></a>2、jupyter使用anaconda虚拟python环境</h4><p>打开 <code>anaconda prompt</code>，激活之前创建的某个python虚拟环境，在<strong>当前虚拟环境</strong>中执行 <code>conda install nb_conda</code>。重启 <code>juypter notebook</code> 服务器即可出现想要的虚拟环境 <code>kernal</code> 。</p><h4 id="3、jupyter两种工作模式及其快捷键"><a href="#3、jupyter两种工作模式及其快捷键" class="headerlink" title="3、jupyter两种工作模式及其快捷键"></a>3、jupyter两种工作模式及其快捷键</h4><ul><li>分为命令模式（边框蓝色) 和 编辑模式(边框绿色)</li><li>命令模式中， <code>M</code> 进入markdown编辑模式， <code>Y</code> 进入代码编辑模式</li></ul><h4 id="4、代码自动补全"><a href="#4、代码自动补全" class="headerlink" title="4、代码自动补全"></a>4、代码自动补全</h4><p>注意，下面的所有操作是在 <code>base</code> 环境中安装的，在其他虚拟环境中安装好像并不起作用。</p><p>安装<strong>nbextensions</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pip install jupyter_contrib_nbextensions</span><br><span class="line">jupyter contrib nbextension install --user</span><br></pre></td></tr></table></figure><p>安装<strong>nbextensions_configurator</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pip install jupyter_nbextensions_configurator</span><br><span class="line">jupyter nbextensions_configurator enable --user</span><br></pre></td></tr></table></figure><p>重启 jupyter，在弹出的主页面里，能看到增加了一个Nbextensions标签页，在这个页面里，勾选Hinterland即启用了代码自动补全。</p><h4 id="5、pandas教程-pan-el-da-ta-s"><a href="#5、pandas教程-pan-el-da-ta-s" class="headerlink" title="5、pandas教程[pan(el)-da(ta)-s]"></a>5、pandas教程[pan(el)-da(ta)-s]</h4><p>1、pandas中的数据分为三种： 一维数据 Series、二维数据 DataFrame、以及三维数据 Panel。</p><ul><li><p>Series相当于一个字典。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">data = np.random.randn(<span class="number">5</span>) <span class="comment"># 一维随机数</span></span><br><span class="line">index = [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>, <span class="string">'d'</span>, <span class="string">'e'</span>] <span class="comment"># 指定索引</span></span><br><span class="line">s = pd.Series(data, index)</span><br></pre></td></tr></table></figure></li><li><p>二维数据，1. 带Series的字典  2.列表构成的字典   3.带字典的列表</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">d = &#123;<span class="string">'one'</span> : pd.Series([<span class="number">1.</span>, <span class="number">2.</span>, <span class="number">3.</span>], index=[<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>]),<span class="string">'two'</span> : pd.Series([<span class="number">1.</span>, <span class="number">2.</span>, <span class="number">3.</span>, <span class="number">4.</span>], index=[<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>, <span class="string">'d'</span>])&#125;  <span class="comment">#one做列</span></span><br><span class="line">d = &#123;<span class="string">'one'</span> : [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>], <span class="string">'two'</span> : [<span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>]&#125;   <span class="comment">#one做列</span></span><br><span class="line">d = [&#123;<span class="string">'a'</span>: <span class="number">1</span>, <span class="string">'b'</span>: <span class="number">2</span>&#125;, &#123;<span class="string">'a'</span>: <span class="number">5</span>, <span class="string">'b'</span>: <span class="number">10</span>, <span class="string">'c'</span>: <span class="number">20</span>&#125;]  <span class="comment">#a,b,c做列</span></span><br><span class="line">df = pd.DataFrame(d)  <span class="comment"># 新建 DataFrame</span></span><br><span class="line">print(df）</span><br></pre></td></tr></table></figure></li></ul><p>列的选择，添加与删除</p><p>​    df[‘列名’]      df.pop(‘列名’)      df.insert(添加列位置索引序号, ‘添加列名’, 数值)</p><p>行的选取，列的选取，块的选取</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">df.index    df.columns   df.values   df.values    df.describes()   df.T    df.dtypes</span><br><span class="line">df.sort_index()    df.sort_values()</span><br><span class="line">df.head()   df.tail()</span><br><span class="line">df[行选取]   df[列名]   df.loc[[行选取],[列选取]]</span><br><span class="line">#df.iloc   df.iat</span><br><span class="line">df.drop(&apos;行名&apos;)</span><br><span class="line">df.append()</span><br><span class="line">df.shape   df.size   df.ndim    </span><br><span class="line">df.sum(axis=1 =0 =default)     df.mean()  df.std()</span><br><span class="line">表明智函数应用：pipe()   #对所有元素起作用</span><br><span class="line">行或列函数应用：apply()  #对行或者列起作用</span><br><span class="line">元素函数应用：applymap() #对某一个元素起作用</span><br></pre></td></tr></table></figure><p>python中使用  <code>type(var)</code> 查看变量的数据类型</p><h4 id="6、juypter显示行号"><a href="#6、juypter显示行号" class="headerlink" title="6、juypter显示行号"></a>6、juypter显示行号</h4><p><code>view &gt;&gt; toggle line numbers</code></p><h4 id="7、juypter中matplotlib画图中文显示乱码"><a href="#7、juypter中matplotlib画图中文显示乱码" class="headerlink" title="7、juypter中matplotlib画图中文显示乱码"></a>7、juypter中matplotlib画图中文显示乱码</h4><p><a href="https://blog.csdn.net/u014465934/article/details/80377470" target="_blank" rel="noopener">https://blog.csdn.net/u014465934/article/details/80377470</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;第一次作业：&lt;a href=&quot;/download/数据科学导论第一次作业.rar&quot;&gt;点击下载&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;怎么说，对这门课就是默默告诉自己，习惯就好。默默贴个 github 地址：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/justmarkham/DAT8&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/justmarkham/DAT8&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;第二次作业：&lt;a href=&quot;/download/数据科学导论第二次作业.rar&quot;&gt;点击下载&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;同样，还是贴几个&lt;code&gt;github&lt;/code&gt;链接地址：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/lamalor/ds100/blob/182feda62685b0988f4b4afb52c85256f4ac7d92/hw6/hw6.ipynb&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/lamalor/ds100/blob/182feda62685b0988f4b4afb52c85256f4ac7d92/hw6/hw6.ipynb&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/Dhanush123/data100/blob/master/hw6/hw6.ipynb&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/Dhanush123/data100/blob/master/hw6/hw6.ipynb&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/iewaij/introDataScience/blob/1eb96b44721ed6cc40761a7e3003f11a5c243cc3/legacy/material/homework/DS100%20SP17/hw5/hw5_solution.ipynb&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/iewaij/introDataScience/blob/1eb96b44721ed6cc40761a7e3003f11a5c243cc3/legacy/material/homework/DS100%20SP17/hw5/hw5_solution.ipynb&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/dovahcrow/ds100/blob/30d629246c87f2fafbf10c155545c30344be23e6/sp17/hw/hw5/hw5_solution.ipynb&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/dovahcrow/ds100/blob/30d629246c87f2fafbf10c155545c30344be23e6/sp17/hw/hw5/hw5_solution.ipynb&lt;/a&gt;&lt;/p&gt;
&lt;h4 id=&quot;1、更改juypter默认工作路径&quot;&gt;&lt;a href=&quot;#1、更改juypter默认工作路径&quot; class=&quot;headerlink&quot; title=&quot;1、更改juypter默认工作路径&quot;&gt;&lt;/a&gt;1、更改juypter默认工作路径&lt;/h4&gt;&lt;p&gt;在 &lt;code&gt;anaconda prompt&lt;/code&gt; 中执行命令：&lt;/p&gt;
&lt;figure class=&quot;highlight shell&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;jupyter notebook --generate-config&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;即可查看 &lt;code&gt;jupyter_notebook_config.py&lt;/code&gt; 配置文件的位置，打开配置文件 &lt;code&gt;jupyter_notebook_config.py&lt;/code&gt;，搜索关键字 &lt;code&gt;notebook_dir&lt;/code&gt; ，将值设置为自己想要的工作目录并取消注释即可（注意路径中不能有中文）；&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/2018/11/04/数据科学导论作业/juypter.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;然后右击 &lt;code&gt;jupyter notebook&lt;/code&gt; 快捷方式，将属性中的 “目标” 字段的值，去掉末尾的 &lt;code&gt;%USERPROFILE%&lt;/code&gt; ，点击 &lt;code&gt;应用&lt;/code&gt;，&lt;code&gt;确定&lt;/code&gt;即可。&lt;/p&gt;
    
    </summary>
    
      <category term="作业" scheme="https://wangjibao.com.cn/categories/%E4%BD%9C%E4%B8%9A/"/>
    
      <category term="数据科学导论大作业" scheme="https://wangjibao.com.cn/categories/%E4%BD%9C%E4%B8%9A/%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E5%AF%BC%E8%AE%BA%E5%A4%A7%E4%BD%9C%E4%B8%9A/"/>
    
    
      <category term="作业" scheme="https://wangjibao.com.cn/tags/%E4%BD%9C%E4%B8%9A/"/>
    
  </entry>
  
  <entry>
    <title>网络数据挖掘作业</title>
    <link href="https://wangjibao.com.cn/2018/10/31/%E7%BD%91%E7%BB%9C%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98%E4%BD%9C%E4%B8%9A/"/>
    <id>https://wangjibao.com.cn/2018/10/31/网络数据挖掘作业/</id>
    <published>2018-10-30T16:53:35.000Z</published>
    <updated>2018-11-04T17:02:33.423Z</updated>
    
    <content type="html"><![CDATA[<p>NMF(非负矩阵分解)，nature论文原文：</p><a id="more"></a><div class="row">    <embed src="1861-algorithms-for-non-negative-matrix-factorization.pdf" width="100%" height="550" type="application/pdf"></div><p>个人理解PPT：</p><div class="row">    <embed src="网络数据挖掘.pdf" width="100%" height="550" type="application/pdf"></div>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;NMF(非负矩阵分解)，nature论文原文：&lt;/p&gt;
    
    </summary>
    
      <category term="作业" scheme="https://wangjibao.com.cn/categories/%E4%BD%9C%E4%B8%9A/"/>
    
      <category term="网络数据挖掘作业" scheme="https://wangjibao.com.cn/categories/%E4%BD%9C%E4%B8%9A/%E7%BD%91%E7%BB%9C%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98%E4%BD%9C%E4%B8%9A/"/>
    
    
      <category term="作业" scheme="https://wangjibao.com.cn/tags/%E4%BD%9C%E4%B8%9A/"/>
    
  </entry>
  
  <entry>
    <title>算法课第二次作业</title>
    <link href="https://wangjibao.com.cn/2018/10/28/%E7%AE%97%E6%B3%95%E8%AF%BE%E7%AC%AC%E4%BA%8C%E6%AC%A1%E4%BD%9C%E4%B8%9A/"/>
    <id>https://wangjibao.com.cn/2018/10/28/算法课第二次作业/</id>
    <published>2018-10-27T16:22:15.000Z</published>
    <updated>2018-11-04T16:58:50.558Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一、Money-robbing"><a href="#一、Money-robbing" class="headerlink" title="一、Money robbing"></a>一、Money robbing</h3><h4 id="1、optimal-substructure-and-DP-equation"><a href="#1、optimal-substructure-and-DP-equation" class="headerlink" title="1、optimal substructure and DP equation"></a>1、optimal substructure and DP equation</h4><p>对于第 i 家，有两种选择，抢或者不抢。如果抢第 i 家，那么最大收益为：value[i] + 抢前 i-2 家的最优收益； 如果第 i 家不抢，那么最大收益为：抢前 i-1 家的最优收益。</p><p>状态转移方程可写为：<br>$$<br>dp[i] = max( dp[i-1], dp[i-2]+value[i] )<br>$$</p><h4 id="2、-pseudo-code"><a href="#2、-pseudo-code" class="headerlink" title="2、 pseudo-code"></a>2、 pseudo-code</h4><p><a href="https://leetcode-cn.com/problems/house-robber/description/" target="_blank" rel="noopener">LeetCode 198题</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">rob</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>( nums.size()==<span class="number">0</span> )</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>( nums.size()==<span class="number">1</span> )</span><br><span class="line">            <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; dp(nums.size(),<span class="number">0</span>);</span><br><span class="line">        dp[<span class="number">0</span>] = nums[<span class="number">0</span>];</span><br><span class="line">        dp[<span class="number">1</span>] = max( nums[<span class="number">0</span>], nums[<span class="number">1</span>] );</span><br><span class="line">        <span class="keyword">for</span>( <span class="keyword">int</span> i=<span class="number">2</span>; i&lt;nums.size(); i++ )&#123;</span><br><span class="line">            dp[i] = max( dp[i<span class="number">-1</span>], dp[i<span class="number">-2</span>]+nums[i] );</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[nums.size()<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><a id="more"></a><h4 id="3、-correctness-of-algorithm"><a href="#3、-correctness-of-algorithm" class="headerlink" title="3、 correctness of algorithm"></a>3、 correctness of algorithm</h4><p>如果暴力求解的话，每一家都有可能抢或者不抢，枚举每一种可能性，那么总的时间复杂度为 $O(2^n)$ ，且最后算出来的最优解一定是正确的。现在，我们采用动态规划思想中的 memory 数组，记录前 i-1 家的最优值，当计算第 i 家最优值时，其依赖的 <code>OPT[i-1]</code> 和 <code>OPT[i-2]</code> 已经求出，可直接计算当前最优值，故算法是正确的。</p><h4 id="4、-complexity-of-algorithm"><a href="#4、-complexity-of-algorithm" class="headerlink" title="4、 complexity of algorithm"></a>4、 complexity of algorithm</h4><p>代码中的 dp 数组，每个元素只计算了一遍，故算法的时间复杂度为 $ O(n) $。</p><p>注：</p><p>当房屋变成一个环的时候，也就是相当于在原有问题上添加了一个限制条件：第<code>1</code>家和第<code>n</code>家不能同时抢。那么，分别计算抢第二家到最后一家与抢第一家到倒数第二家的最大值，取两个值中更大的那个就是结果。</p><p><a href="https://leetcode-cn.com/problems/house-robber-ii/description/" target="_blank" rel="noopener">LeetCode 213题</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">rob</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>( nums.size()==<span class="number">0</span> )</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>( nums.size()==<span class="number">1</span> )</span><br><span class="line">            <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">return</span> max( func(nums, <span class="number">0</span>), func(nums, nums.size()<span class="number">-1</span> ));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">func</span><span class="params">( <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; nums, <span class="keyword">int</span> pos )</span></span>&#123;</span><br><span class="line">        nums.erase(nums.begin()+pos);</span><br><span class="line">        <span class="keyword">if</span>( nums.size()==<span class="number">0</span> )</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>( nums.size()==<span class="number">1</span> )</span><br><span class="line">            <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; dp(nums.size(),<span class="number">0</span>);</span><br><span class="line">        dp[<span class="number">0</span>] = nums[<span class="number">0</span>];</span><br><span class="line">        dp[<span class="number">1</span>] = max( nums[<span class="number">0</span>], nums[<span class="number">1</span>] );</span><br><span class="line">        <span class="keyword">for</span>( <span class="keyword">int</span> i=<span class="number">2</span>; i&lt;nums.size(); i++ )&#123;</span><br><span class="line">            dp[i] = max( dp[i<span class="number">-1</span>], dp[i<span class="number">-2</span>]+nums[i] );</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[nums.size()<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="二、Node-selection"><a href="#二、Node-selection" class="headerlink" title="二、Node selection"></a>二、Node selection</h3><h4 id="1、optimal-substructure-and-DP-equation-1"><a href="#1、optimal-substructure-and-DP-equation-1" class="headerlink" title="1、optimal substructure and DP equation"></a>1、optimal substructure and DP equation</h4><p>对于当前根节点，有两种可能性，选取或者不选取。如果选取了当前的根节点，那么其孩子节点就不能选取，即最优值变为：root-&gt;value + 4个孙子的最优值之和； 如果当前根节点没有选取，最优值变为：两个孩子节点最优值之和。</p><p>给定任意一个根，假设我们能够得到当前根选取与不选取的最优值，结果保存在一个长度为2的数组里，array[0]代表根节点不选取，array[1]代表根节点选取，那么最优解为：</p><p><img src="/2018/10/28/算法课第二次作业/form1.png" alt=""></p><h4 id="2、-pseudo-code-1"><a href="#2、-pseudo-code-1" class="headerlink" title="2、 pseudo-code"></a>2、 pseudo-code</h4><p><a href="https://leetcode-cn.com/problems/house-robber-iii/description/" target="_blank" rel="noopener">LeetCode 337题</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">rob</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ans = solve( root );</span><br><span class="line">        <span class="keyword">return</span> max( ans[<span class="number">0</span>], ans[<span class="number">1</span>] );</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; solve( TreeNode* root )&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ans(<span class="number">2</span>,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span>( !root )</span><br><span class="line">            <span class="keyword">return</span> ans;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; left_ans = solve( root-&gt;left);</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; right_ans = solve( root-&gt;right );</span><br><span class="line">        ans[<span class="number">0</span>] = max( left_ans[<span class="number">0</span>], left_ans[<span class="number">1</span>] ) + max( right_ans[<span class="number">0</span>], right_ans[<span class="number">1</span>] ); <span class="comment">//根节点不选</span></span><br><span class="line">        ans[<span class="number">1</span>] = root-&gt;val + left_ans[<span class="number">0</span>] + right_ans[<span class="number">0</span>]; <span class="comment">//选择根节点</span></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="3、correctness-of-algorithm"><a href="#3、correctness-of-algorithm" class="headerlink" title="3、correctness of algorithm"></a>3、correctness of algorithm</h4><p>当前节点的最优值，依赖于其儿子节点的最优值（当前节点没选，最优值等于选其左孩子节点最优值+选其右孩子节点最优值）或其孙子节点的最优值（选取了当前节点，最优值等于根节点值+其左孩子不选左根的最优值+右孩子不选右根的最优值），由此可知算法的正确性。</p><h4 id="4、complexity-of-algorithm"><a href="#4、complexity-of-algorithm" class="headerlink" title="4、complexity of algorithm"></a>4、complexity of algorithm</h4><p>整个算法相当于一个深度优先搜索（DFS），树中的每个节点都会遍历一次，故算法的时间复杂度为$O(n)$。</p><h3 id="三、Decoding"><a href="#三、Decoding" class="headerlink" title="三、Decoding"></a>三、Decoding</h3><h4 id="1、optimal-substructure-and-DP-equation-2"><a href="#1、optimal-substructure-and-DP-equation-2" class="headerlink" title="1、optimal substructure and DP equation"></a>1、optimal substructure and DP equation</h4><p><code>dp[i]</code>表示从字符<code>0~i</code>的字符串包含最多的编码种数。不考虑特殊情况，该题的递推式是$dp[i]=dp[i-1]+dp[i-2]$，因为一个数字可以表示一个编码，两个数字也有可能表示一个编码，所以<code>dp[i]</code>应该等于<code>0~i-1</code>的字符串包含的最多编码种数加上<code>0~i-2</code>的字符串包含的最多编码种数。但是考虑到一共只有26种基础编码加上特殊情况0，所以递推式可以表示为：</p><p><img src="/2018/10/28/算法课第二次作业/form2.png" alt=""></p><h4 id="2、-pseudo-code-2"><a href="#2、-pseudo-code-2" class="headerlink" title="2、 pseudo-code"></a>2、 pseudo-code</h4><p><a href="https://leetcode-cn.com/problems/decode-ways/description/" target="_blank" rel="noopener">LeetCode 91题</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numDecodings</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>( s.length()==<span class="number">0</span> || s[<span class="number">0</span>]==<span class="string">'0'</span> ) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; dp(s.length()+<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">        dp[<span class="number">0</span>] = dp[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>( <span class="keyword">int</span> i=<span class="number">1</span>; i&lt;s.length(); i++ )&#123;</span><br><span class="line">            <span class="keyword">if</span>( s[i]!=<span class="string">'0'</span> )</span><br><span class="line">                dp[i+<span class="number">1</span>] += dp[i];</span><br><span class="line">            <span class="keyword">if</span>( s[i<span class="number">-1</span>]!=<span class="string">'0'</span> &amp;&amp; (s[i<span class="number">-1</span>]-<span class="string">'0'</span>)*<span class="number">10</span>+(s[i]-<span class="string">'0'</span>)&lt;=<span class="number">26</span> )</span><br><span class="line">                dp[i+<span class="number">1</span>] += dp[i<span class="number">-1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[s.length()];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="3、correctness-of-algorithm-1"><a href="#3、correctness-of-algorithm-1" class="headerlink" title="3、correctness of algorithm"></a>3、correctness of algorithm</h4><p>首先该问题包含最优子结构的性质，求<code>0~n</code>的字符串包含最多的编码种数包含了求<code>0~n-1</code>的字符串包含最多的编码种数或<code>0~n-2</code>的字符串包含最多的编码种数。其次该问题包含重叠子性质，大量子问题会重复计算，如求dp[5]需要计算dp[4]或dp[3],求dp[4]需要求dp[3]或dp[2]，因此dp[3]被重复计算。综上该问题可以用动态规划方法解且求解方程正确。</p><h4 id="4、complexity-of-algorithm-1"><a href="#4、complexity-of-algorithm-1" class="headerlink" title="4、complexity of algorithm"></a>4、complexity of algorithm</h4><p>整个求解过程只遍历了一遍字符串，故算法时间复杂度为$O(n)$。</p><h3 id="六、OJ第一题"><a href="#六、OJ第一题" class="headerlink" title="六、OJ第一题"></a>六、OJ第一题</h3><p>LIS，DP入门第一题，没啥好说的，只要想清楚为啥每次将新来的数据往 <code>ans</code> 数组里插入，最后出来的就一定是最长的就可以了。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> num, T, N;</span><br><span class="line">    <span class="keyword">int</span> length, index;</span><br><span class="line">    <span class="keyword">int</span> ans[<span class="number">100005</span>];</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; T;</span><br><span class="line">    <span class="keyword">for</span>( <span class="keyword">int</span> t = <span class="number">0</span>; t&lt;T; t++ )&#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; N;</span><br><span class="line">        length = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">memset</span>(ans, <span class="number">-1</span>, <span class="keyword">sizeof</span>(ans));</span><br><span class="line">        <span class="keyword">for</span>( <span class="keyword">int</span> i=<span class="number">0</span>; i&lt;N; i++ )&#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;num);</span><br><span class="line">            index = lower_bound( ans, ans+length, num ) - ans;</span><br><span class="line">            ans[index] = num;</span><br><span class="line">            <span class="keyword">if</span>( index==length )</span><br><span class="line">                length++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; length &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="七、OJ第二题"><a href="#七、OJ第二题" class="headerlink" title="七、OJ第二题"></a>七、OJ第二题</h3><p>入门级题目外加了求 <code>K</code> 个最优值的条件，昨晚1点多打开题目，感觉随便码一码随便A掉，于是上床 睡觉，躺床上拍脑袋理论AC。仔细一想，K个最优值的状态转移，有点问题啊，带着疑问入睡不咋舒坦，大半夜将题目发到<code>315</code>群，杨老师帅气得给出了解决方案，顺带嘲笑了一波数据；炸老师看了数据量也嘲讽了一波；早上起来交了一发，发现 <code>0 ms</code>的时候，也疯狂鄙视一波，数据真的弱得不行。</p><p>想起来当年 <code>ycb</code> 的誓言：</p><p><img src="/2018/10/28/算法课第二次作业/ycb.jpeg" alt=""></p><p><img src="/2018/10/28/算法课第二次作业/dp1.png" alt=""></p><p><img src="/2018/10/28/算法课第二次作业/dp2.png" alt=""></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> m, n, k;</span><br><span class="line"><span class="keyword">int</span> num;</span><br><span class="line">priority_queue&lt;<span class="keyword">int</span>&gt; ans[<span class="number">105</span>], cur_ans, tmp_ans;<span class="comment">//默认大堆</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ans[<span class="number">1</span>].push(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; m &gt;&gt; n &gt;&gt; k;</span><br><span class="line">    <span class="keyword">for</span>( <span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=m; i++ )&#123;</span><br><span class="line">        <span class="keyword">for</span>( <span class="keyword">int</span> j=<span class="number">1</span>; j&lt;=n; j++ )&#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;num);</span><br><span class="line">            <span class="keyword">while</span>( !cur_ans.empty() )&#123;  <span class="comment">//清空cur_ans</span></span><br><span class="line">                cur_ans.pop();</span><br><span class="line">            &#125;</span><br><span class="line">            tmp_ans = ans[j<span class="number">-1</span>];</span><br><span class="line">            <span class="keyword">while</span>( !ans[j<span class="number">-1</span>].empty() )&#123;</span><br><span class="line">                cur_ans.push(ans[j<span class="number">-1</span>].top()+num);</span><br><span class="line">                ans[j<span class="number">-1</span>].pop();</span><br><span class="line">            &#125;</span><br><span class="line">            ans[j<span class="number">-1</span>] = tmp_ans;</span><br><span class="line">            <span class="keyword">while</span>( !ans[j].empty() )&#123;</span><br><span class="line">                cur_ans.push(ans[j].top()+num);</span><br><span class="line">                ans[j].pop();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span>( ans[j].size()&lt;k &amp;&amp; !cur_ans.empty() )&#123;</span><br><span class="line">                ans[j].push(cur_ans.top());</span><br><span class="line">                cur_ans.pop();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; ans[n].top();</span><br><span class="line">    ans[n].pop();</span><br><span class="line">    <span class="keyword">while</span>( !ans[n].empty() )&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">" "</span> &lt;&lt; ans[n].top();</span><br><span class="line">        ans[n].pop();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;一、Money-robbing&quot;&gt;&lt;a href=&quot;#一、Money-robbing&quot; class=&quot;headerlink&quot; title=&quot;一、Money robbing&quot;&gt;&lt;/a&gt;一、Money robbing&lt;/h3&gt;&lt;h4 id=&quot;1、optimal-substructure-and-DP-equation&quot;&gt;&lt;a href=&quot;#1、optimal-substructure-and-DP-equation&quot; class=&quot;headerlink&quot; title=&quot;1、optimal substructure and DP equation&quot;&gt;&lt;/a&gt;1、optimal substructure and DP equation&lt;/h4&gt;&lt;p&gt;对于第 i 家，有两种选择，抢或者不抢。如果抢第 i 家，那么最大收益为：value[i] + 抢前 i-2 家的最优收益； 如果第 i 家不抢，那么最大收益为：抢前 i-1 家的最优收益。&lt;/p&gt;
&lt;p&gt;状态转移方程可写为：&lt;br&gt;$$&lt;br&gt;dp[i] = max( dp[i-1], dp[i-2]+value[i] )&lt;br&gt;$$&lt;/p&gt;
&lt;h4 id=&quot;2、-pseudo-code&quot;&gt;&lt;a href=&quot;#2、-pseudo-code&quot; class=&quot;headerlink&quot; title=&quot;2、 pseudo-code&quot;&gt;&lt;/a&gt;2、 pseudo-code&lt;/h4&gt;&lt;p&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/house-robber/description/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;LeetCode 198题&lt;/a&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight c++&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Solution&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt;:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;rob&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;built_in&quot;&gt;vector&lt;/span&gt;&amp;lt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt;&amp;gt;&amp;amp; nums)&lt;/span&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;( nums.size()==&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt; )&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;( nums.size()==&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt; )&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; nums[&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;built_in&quot;&gt;vector&lt;/span&gt;&amp;lt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt;&amp;gt; dp(nums.size(),&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        dp[&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;] = nums[&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        dp[&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;] = max( nums[&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;], nums[&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;] );&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt;( &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; i=&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;; i&amp;lt;nums.size(); i++ )&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            dp[i] = max( dp[i&lt;span class=&quot;number&quot;&gt;-1&lt;/span&gt;], dp[i&lt;span class=&quot;number&quot;&gt;-2&lt;/span&gt;]+nums[i] );&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; dp[nums.size()&lt;span class=&quot;number&quot;&gt;-1&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="作业" scheme="https://wangjibao.com.cn/categories/%E4%BD%9C%E4%B8%9A/"/>
    
      <category term="算法课第二次作业" scheme="https://wangjibao.com.cn/categories/%E4%BD%9C%E4%B8%9A/%E7%AE%97%E6%B3%95%E8%AF%BE%E7%AC%AC%E4%BA%8C%E6%AC%A1%E4%BD%9C%E4%B8%9A/"/>
    
    
      <category term="作业" scheme="https://wangjibao.com.cn/tags/%E4%BD%9C%E4%B8%9A/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode21-30</title>
    <link href="https://wangjibao.com.cn/2018/10/20/LeetCode21-30/"/>
    <id>https://wangjibao.com.cn/2018/10/20/LeetCode21-30/</id>
    <published>2018-10-20T11:51:57.000Z</published>
    <updated>2018-10-21T04:36:23.923Z</updated>
    
    <content type="html"><![CDATA[<h2 id="21、合并两个有序链表"><a href="#21、合并两个有序链表" class="headerlink" title="21、合并两个有序链表"></a>21、<a href="https://leetcode-cn.com/problems/merge-two-sorted-lists" target="_blank" rel="noopener">合并两个有序链表</a></h2><p>两个有序链表的合并，本渣代码充分利用原有空间，没开辟新的内存存储新链。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">mergeTwoLists</span><span class="params">(ListNode* l1, ListNode* l2)</span> </span>&#123;</span><br><span class="line">        ListNode *ans = (ListNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(ListNode)), *tmp = ans;</span><br><span class="line">        ans-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">while</span>( l1&amp;&amp;l2 )&#123;</span><br><span class="line">            <span class="keyword">if</span>( l1-&gt;val &gt; l2-&gt;val )&#123;</span><br><span class="line">                tmp-&gt;next = l2;</span><br><span class="line">                l2 = l2-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                tmp-&gt;next = l1;</span><br><span class="line">                l1 = l1-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            tmp = tmp-&gt;next;</span><br><span class="line">            tmp-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>( l1 )</span><br><span class="line">            tmp-&gt;next = l1;</span><br><span class="line">        <span class="keyword">if</span>( l2 )</span><br><span class="line">            tmp-&gt;next = l2;</span><br><span class="line">        <span class="keyword">return</span> ans-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="22、括号生成"><a href="#22、括号生成" class="headerlink" title="22、括号生成"></a>22、<a href="https://leetcode-cn.com/problems/generate-parentheses" target="_blank" rel="noopener">括号生成</a></h2><p>生成的种类数是个卡特兰数，因此 n 的值不会太大。卡特兰数在计算机中是个特别重要的数串，像：三角剖分、n个叶节点树的种类、n个数字的进出栈、括号匹配、矩阵链乘等等都有卡特兰数的应用。</p><p>卡特兰数的通项公式：<br>$$<br>h(n) = C_{2n}^n - C_{2n}^{n-1}<br>$$<br>递推公式为：<br>$$<br>h(n) = h(n-1)*\frac{4n-2}{n+1}<br>$$<br>其实，求组合数时，当 n 很大的时候，计算也是个问题，好在有 <a href="https://blog.csdn.net/arrowlll/article/details/53064748" target="_blank" rel="noopener">Lucas定理</a> 可以解决这事，当然以上这些与解决本题没啥关系。</p><p>本题做法是直接递归一下即可，每次放左括号（第16行）或右括号（第17行），递归的退出条件是放了n个左括号和n个右括号（第9行），剪枝条件是放的右括号数量大于左括号数量了，明显会造成非法串，直接返回退出（第13行）。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; generateParenthesis(<span class="keyword">int</span> n) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; ans;</span><br><span class="line">        func(ans, <span class="string">""</span>, n, n);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; ans, <span class="built_in">string</span> tmp_ans, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>( left==<span class="number">0</span> &amp;&amp; right==<span class="number">0</span> )&#123;</span><br><span class="line">            ans.push_back(tmp_ans);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>( right&lt;left )  <span class="comment">//相当于剪枝，2^n剪到katalan(n)</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span>( left&gt;<span class="number">0</span> )</span><br><span class="line">            func( ans, tmp_ans+<span class="string">'('</span>, left<span class="number">-1</span>, right );</span><br><span class="line">        func( ans, tmp_ans+<span class="string">')'</span>, left, right<span class="number">-1</span> );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;21、合并两个有序链表&quot;&gt;&lt;a href=&quot;#21、合并两个有序链表&quot; class=&quot;headerlink&quot; title=&quot;21、合并两个有序链表&quot;&gt;&lt;/a&gt;21、&lt;a href=&quot;https://leetcode-cn.com/problems/merge-two-sorted-lists&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;合并两个有序链表&lt;/a&gt;&lt;/h2&gt;&lt;p&gt;两个有序链表的合并，本渣代码充分利用原有空间，没开辟新的内存存储新链。&lt;/p&gt;
&lt;figure class=&quot;highlight c++&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;31&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;32&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;/**&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt; * Definition for singly-linked list.&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt; * struct ListNode &amp;#123;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt; *     int val;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt; *     ListNode *next;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt; *     ListNode(int x) : val(x), next(NULL) &amp;#123;&amp;#125;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt; * &amp;#125;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt; */&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Solution&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt;:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;ListNode* &lt;span class=&quot;title&quot;&gt;mergeTwoLists&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(ListNode* l1, ListNode* l2)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        ListNode *ans = (ListNode*)&lt;span class=&quot;built_in&quot;&gt;malloc&lt;/span&gt;(&lt;span class=&quot;keyword&quot;&gt;sizeof&lt;/span&gt;(ListNode)), *tmp = ans;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        ans-&amp;gt;next = &lt;span class=&quot;literal&quot;&gt;NULL&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;while&lt;/span&gt;( l1&amp;amp;&amp;amp;l2 )&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;( l1-&amp;gt;val &amp;gt; l2-&amp;gt;val )&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                tmp-&amp;gt;next = l2;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                l2 = l2-&amp;gt;next;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                tmp-&amp;gt;next = l1;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                l1 = l1-&amp;gt;next;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            tmp = tmp-&amp;gt;next;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            tmp-&amp;gt;next = &lt;span class=&quot;literal&quot;&gt;NULL&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;( l1 )&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            tmp-&amp;gt;next = l1;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;( l2 )&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            tmp-&amp;gt;next = l2;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; ans-&amp;gt;next;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="LeetCode" scheme="https://wangjibao.com.cn/categories/LeetCode/"/>
    
      <category term="LeetCode21-30" scheme="https://wangjibao.com.cn/categories/LeetCode/LeetCode21-30/"/>
    
    
      <category term="LeetCode" scheme="https://wangjibao.com.cn/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>背包九讲</title>
    <link href="https://wangjibao.com.cn/2018/10/17/%E8%83%8C%E5%8C%85%E4%B9%9D%E8%AE%B2/"/>
    <id>https://wangjibao.com.cn/2018/10/17/背包九讲/</id>
    <published>2018-10-17T08:51:14.000Z</published>
    <updated>2018-11-04T17:18:37.235Z</updated>
    
    <content type="html"><![CDATA[<p>大二入门动态规划时，最先学得就是 <code>LCS</code> , <code>LIS</code> 和各种背包问题，后来接触二维DP和各种无厘头DP（数位DP啊，插头DP啊，状压DP啊，树状DP啊等等），以我这种智商水平，听听名字就好了。最近的算法课讲到了 <code>DP</code> 专题，找出了之前看的 <code>背包九讲</code>看了看，放出来，纪念一发当年的岁月吧。</p><a id="more"></a><div class="row">    <embed src="背包九讲.pdf" width="100%" height="550" type="application/pdf"></div>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;大二入门动态规划时，最先学得就是 &lt;code&gt;LCS&lt;/code&gt; , &lt;code&gt;LIS&lt;/code&gt; 和各种背包问题，后来接触二维DP和各种无厘头DP（数位DP啊，插头DP啊，状压DP啊，树状DP啊等等），以我这种智商水平，听听名字就好了。最近的算法课讲到了 &lt;code&gt;DP&lt;/code&gt; 专题，找出了之前看的 &lt;code&gt;背包九讲&lt;/code&gt;看了看，放出来，纪念一发当年的岁月吧。&lt;/p&gt;
    
    </summary>
    
      <category term="资料" scheme="https://wangjibao.com.cn/categories/%E8%B5%84%E6%96%99/"/>
    
    
      <category term="资料" scheme="https://wangjibao.com.cn/tags/%E8%B5%84%E6%96%99/"/>
    
  </entry>
  
  <entry>
    <title>Ubuntu中配置SS多用户模式并限制每个用户的流量</title>
    <link href="https://wangjibao.com.cn/2018/10/12/Ubuntu%E4%B8%AD%E9%85%8D%E7%BD%AESS%E5%A4%9A%E7%94%A8%E6%88%B7%E6%A8%A1%E5%BC%8F%E5%B9%B6%E9%99%90%E5%88%B6%E6%AF%8F%E4%B8%AA%E7%94%A8%E6%88%B7%E7%9A%84%E6%B5%81%E9%87%8F/"/>
    <id>https://wangjibao.com.cn/2018/10/12/Ubuntu中配置SS多用户模式并限制每个用户的流量/</id>
    <published>2018-10-12T12:40:14.000Z</published>
    <updated>2018-10-12T13:05:44.919Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1、更新软件并安装vim"><a href="#1、更新软件并安装vim" class="headerlink" title="1、更新软件并安装vim"></a>1、更新软件并安装vim</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get upgrade</span><br><span class="line">sudo apt-get install vim</span><br></pre></td></tr></table></figure><h3 id="2、更改-SSH-默认端口"><a href="#2、更改-SSH-默认端口" class="headerlink" title="2、更改 SSH 默认端口"></a>2、更改 SSH 默认端口</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sudo vim /etc/ssh/sshd_config</span><br><span class="line">找到 Port 字段，将其修改为自己想要的端口值</span><br><span class="line">sudo service ssh restart         #重启ssh服务</span><br><span class="line">sudo netstat -tunlp | grep ssh   #查看ssh服务监听的端口</span><br></pre></td></tr></table></figure><p>这里将ssh端口改成了22222，如下图（PS:不要问我为啥强行改22号端口，就是任性，额，其实有点其他用途，青大校友表示当年我就是靠这个强行免费使用校园网）：</p><p><img src="/2018/10/12/Ubuntu中配置SS多用户模式并限制每个用户的流量/ssh.png" alt=""></p><h3 id="3、安装shadowsocks-python版本"><a href="#3、安装shadowsocks-python版本" class="headerlink" title="3、安装shadowsocks-python版本"></a>3、安装shadowsocks-python版本</h3><a id="more"></a><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install python-pip</span><br><span class="line"><span class="meta">#</span>在ubuntu16.04中，可以通过pip安装pyhon版的shadowsocks，但是好像已经不维护更新了，停留在了2.8.2版本</span><br><span class="line">sudo pip install shadowsocks</span><br></pre></td></tr></table></figure><p>然后创建一个 <code>json</code> 文件并在其中填写个人配置信息即可，比如在 <code>/home/my_ss_config.json</code> 中，填写如下信息：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">"server" : "your_server_ip",     #自己服务器的IP</span><br><span class="line">"server_port" : 8388,            #服务器端口</span><br><span class="line">"local_address" : "127.0.0.1", </span><br><span class="line">"local_port" : 1080, </span><br><span class="line">"password" : "yourpassword",     #密码</span><br><span class="line">"timeout" : 300, </span><br><span class="line">"method" : "aes-256-cfb"         #加密方式</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>只要更改后面带 <code>#</code> 号的一些字段值即可，如果想多用户的话，可以将 <code>password</code> 字段改成如下模式（ss使用端口值识别不同的用户）：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">"port_password": &#123;</span><br><span class="line">"端口1": "密码1",</span><br><span class="line">"端口2": "密码2"</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p>一切准备就绪，接下来使用如下命令即可运行 SS 服务，实现 <code>Cross the Great Fire Wall</code> 。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo ssserver -c /home/my_ss_config.json -d start</span><br></pre></td></tr></table></figure><h3 id="4、多用户模式流量统计"><a href="#4、多用户模式流量统计" class="headerlink" title="4、多用户模式流量统计"></a>4、多用户模式流量统计</h3><p>说一下我为啥要搞这么个功能，前天，我TM大半夜的正嗨呢，突然，网断了！于是乎，打开4G，还是无法操作，这。。。。<del>我手纸都准备好了</del>，竟然发生这样的事？（开玩笑，哈哈，根正苗红的科研知识分子，油管看科研视频的好吧，为科研奉献全身！）收到邮件，告诉我流量用完了，呵。。。</p><p><img src="/2018/10/12/Ubuntu中配置SS多用户模式并限制每个用户的流量/bandwidth.png" alt=""></p><p>于是乎，大家公用的情况下，私开个个人账号，每到月末的时候应急用。于是乎用到了上面讲到的多用户模式，但是这样还不行，为每个用户限制流量使用上限才能达到目的。</p><p>找了找，发现国内的某度关于这方面是真的干净，上某歌，查到可以使用 <code>ss-bash</code> 实现，<a href="https://github.com/hellofwy/ss-bash" target="_blank" rel="noopener">github上有</a>，实现的原理就是：<code>不同的用户分配不同端口，使用iptables规则获取各端口的流量，脚本循环运行，在固定时间间隔根据iptables结果统计流量使用情况，并在流量超过限制时，添加对应端口的iptables reject规则以禁用端口。</code></p><p>安装shadowsocks与ss-bash之后，shadowsocks就不用做任何配置了，省去了上面的步骤，由ss-bash管理shadowsocks，包括配置的文件等等。有个缺点就是，ss-bash目前只支持python版Shadowsocks，只支持统计ipv4流量，但这问题影响不大。</p><p>执行如下指令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">apt-get install unzip       #下载解压工具</span><br><span class="line">apt-get install bc          #安装计算器，后面统计流量用</span><br><span class="line">wget https://github.com/hellofwy/ss-bash/archive/master.zip   #下载软件包</span><br><span class="line">unzip master.zip</span><br><span class="line">cd ss-bash-master/</span><br></pre></td></tr></table></figure><p>现在就可以使用相关命令配置 SS 了，具体操作指令如下（可通过 <code>./ssadmin.sh</code> 命令查看）：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">用法：</span><br><span class="line">    显示版本：</span><br><span class="line">        ssadmin.sh -v|v|version</span><br><span class="line">    显示帮助：</span><br><span class="line">        ssadmin.sh [-h|h|help]</span><br><span class="line">    启动ss:</span><br><span class="line">        ssadmin.sh start</span><br><span class="line">    停止ss：</span><br><span class="line">        ssadmin.sh stop</span><br><span class="line">    查看ss状态：</span><br><span class="line">        ssadmin.sh status</span><br><span class="line">    重启ss：</span><br><span class="line">        ssadmin.sh restart</span><br><span class="line">    软重启ss：</span><br><span class="line">        ssadmin.sh soft_restart</span><br><span class="line">        在不影响现有连接的情况下重启ss服务。用于ss服务参数修改，</span><br><span class="line">        和手动直接修改配置文件后，重启ss服务。</span><br><span class="line">    添加用户：</span><br><span class="line">        ssadmin.sh add port passwd limit</span><br><span class="line">            port：端口号, 0&lt;port&lt;=65535</span><br><span class="line">            passwd：密码, 不能有空格，引号等字符</span><br><span class="line">            limit：流量限制，可以用K/M/G/T、KB/MB/GB/TB等（不区</span><br><span class="line">                   分大小写）。支持小数。比如10.5G、10.5GB等。</span><br><span class="line">                   1KB=1024 bytes，以此类推。</span><br><span class="line">        示例： ssadmin.sh add 3333 abcde 10.5G</span><br><span class="line">    显示用户流量信息：</span><br><span class="line">        ssadmin.sh show port</span><br><span class="line">    显示所有用户流量信息：</span><br><span class="line">        ssadmin.sh show</span><br><span class="line">    显示用户密码信息：</span><br><span class="line">        ssadmin.sh showpw port</span><br><span class="line">    显示所有用户密码信息：</span><br><span class="line">        ssadmin.sh showpw</span><br><span class="line">    删除用户：</span><br><span class="line">        ssadmin.sh del port</span><br><span class="line">    修改用户：</span><br><span class="line">        ssadmin.sh change port passwd limit</span><br><span class="line">    修改用户密码：</span><br><span class="line">        ssadmin.sh cpw port passwd</span><br><span class="line">    修改用户流量限制：</span><br><span class="line">        ssadmin.sh clim port limit</span><br><span class="line">    修改所有用户流量限制：</span><br><span class="line">        ssadmin.sh change_all_limit limit</span><br><span class="line">    用户流量使用量置零：</span><br><span class="line">        ssadmin.sh rused limit</span><br><span class="line">    所有用户流量使用量置零：</span><br><span class="line">        ssadmin.sh reset_all_used</span><br><span class="line">    用户流量限制置零：</span><br><span class="line">        ssadmin.sh rlim port</span><br><span class="line">    全部用户流量限制置零：</span><br><span class="line">        ssadmin.sh reset_all_limit</span><br><span class="line">    显示已添加的iptables规则：</span><br><span class="line">        ssadmin.sh lrules</span><br></pre></td></tr></table></figure><p>添加完账户后，<code>./ssadmin.sh start</code>启动后，<code>./ssadmin.sh show</code> 即可查看每个用户的当前流量使用情况。如下图：</p><p><img src="/2018/10/12/Ubuntu中配置SS多用户模式并限制每个用户的流量/show.png" alt=""></p><p><code>ssadmin</code>文件夹中的各个文件的含义如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">ssadmin.sh      #管理程序，所有命令通过该程序执行</span><br><span class="line">sscounter.sh    #流量统计程序。由ssadmin.sh自动调用执行，注意：不要手动运行该程序</span><br><span class="line">sshelp</span><br><span class="line">sslib.sh        #包含一些参数配置和流量统计函数。由ssadmin.sh自动调用执行，注意：不要手动运行该程序</span><br><span class="line">ssmlt.json      #根据用户列表和ssmlt.template生成的ssserver实际使用的配置文件</span><br><span class="line">ssmlt.template  #ssserver的配置文件</span><br><span class="line">sstraffic       #用户流量使用情况，包括流量限制，已用流量，剩余流量等。ssadmin.sh show 命令，显示该文件内容。</span><br><span class="line">ssusers         #用户列表</span><br><span class="line">traffic.log     #用户流量记录，供程序内部使用。</span><br></pre></td></tr></table></figure><p>备注：</p><p>1、默认的流量采样间隔为5分钟，流量间隔可根据实际需求调整，但最好不要太小，比如小于10秒。可打开文件<code>sslib.sh</code> ，修改<code>INTERVEL</code> 的值，单位为秒。</p><p>2、如果shadowsocks不是使用apt-get或者pip安装，无法自动找到 <code>ssserver</code> 文件时，请手动指定程序的具体位置。打开文件 <code>sslib.sh</code> ，修改 <code>SSSERVER</code> 的值，比如 <code>ssserver</code> 的路径为 <code>/usr/local/bin/ssserver</code> 时，修改为:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SSSERVER=/usr/local/bin/ssserver</span><br></pre></td></tr></table></figure><h3 id="5、To-Do-List"><a href="#5、To-Do-List" class="headerlink" title="5、To Do List"></a>5、To Do List</h3><p>既然身为抓包组里的一员，就要干点抓包相关的事，是不是。比如说，十分好奇为啥大家流量用得那么多呢，肯定看视频了，看啥视频了呢，<code>奥特曼大战葫芦娃.avi</code> ？初步打算在服务器上进行流量采样，比如万分之一的采样率，然后记录下对应账户的 <code>DNS</code>请求的 <code>query</code> 字段值，<code>client hello</code>中的<code>SNI</code>字段等。</p><p>最近比较忙（<del>其实就是懒</del>），回头抽空搞一发。。。嘻嘻</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;1、更新软件并安装vim&quot;&gt;&lt;a href=&quot;#1、更新软件并安装vim&quot; class=&quot;headerlink&quot; title=&quot;1、更新软件并安装vim&quot;&gt;&lt;/a&gt;1、更新软件并安装vim&lt;/h3&gt;&lt;figure class=&quot;highlight shell&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;sudo apt-get update&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;sudo apt-get upgrade&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;sudo apt-get install vim&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h3 id=&quot;2、更改-SSH-默认端口&quot;&gt;&lt;a href=&quot;#2、更改-SSH-默认端口&quot; class=&quot;headerlink&quot; title=&quot;2、更改 SSH 默认端口&quot;&gt;&lt;/a&gt;2、更改 SSH 默认端口&lt;/h3&gt;&lt;figure class=&quot;highlight shell&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;sudo vim /etc/ssh/sshd_config&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;找到 Port 字段，将其修改为自己想要的端口值&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;sudo service ssh restart         #重启ssh服务&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;sudo netstat -tunlp | grep ssh   #查看ssh服务监听的端口&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;这里将ssh端口改成了22222，如下图（PS:不要问我为啥强行改22号端口，就是任性，额，其实有点其他用途，青大校友表示当年我就是靠这个强行免费使用校园网）：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/2018/10/12/Ubuntu中配置SS多用户模式并限制每个用户的流量/ssh.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h3 id=&quot;3、安装shadowsocks-python版本&quot;&gt;&lt;a href=&quot;#3、安装shadowsocks-python版本&quot; class=&quot;headerlink&quot; title=&quot;3、安装shadowsocks-python版本&quot;&gt;&lt;/a&gt;3、安装shadowsocks-python版本&lt;/h3&gt;
    
    </summary>
    
      <category term="笔记" scheme="https://wangjibao.com.cn/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="笔记" scheme="https://wangjibao.com.cn/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode11-20</title>
    <link href="https://wangjibao.com.cn/2018/10/09/LeetCode11-20/"/>
    <id>https://wangjibao.com.cn/2018/10/09/LeetCode11-20/</id>
    <published>2018-10-09T12:45:18.000Z</published>
    <updated>2018-10-20T11:50:02.502Z</updated>
    
    <content type="html"><![CDATA[<h2 id="11、盛最多水的容器"><a href="#11、盛最多水的容器" class="headerlink" title="11、盛最多水的容器"></a>11、<a href="https://leetcode-cn.com/problems/container-with-most-water" target="_blank" rel="noopener">盛最多水的容器</a></h2><p>双指针，算法中一个很重要的技巧，之前的三数求和就用到了双指针的技巧。</p><p>我们在由线段长度构成的数组中使用两个指针，一个放在开始，一个置于末尾。 此外，我们会使用变量 <code>maxArea</code> 来持续存储到目前为止所获得的最大面积。 在每一步中，我们会找出指针所指向的两条线段形成的区域，更新 <code>maxArea</code>，并将指向较短线段的指针向较长线段那端移动一步。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxArea</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; height)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> maxArea = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> frontPoint = <span class="number">0</span>, endPoint = height.size()<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>( frontPoint&lt;endPoint )&#123;</span><br><span class="line">            maxArea = max( maxArea, (endPoint-frontPoint)*min(height[frontPoint], height[endPoint]) );</span><br><span class="line">            <span class="keyword">if</span>( height[frontPoint]&lt;height[endPoint] )</span><br><span class="line">                frontPoint++;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                endPoint--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxArea;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="12、整数转罗马数字"><a href="#12、整数转罗马数字" class="headerlink" title="12、整数转罗马数字"></a>12、<a href="https://leetcode-cn.com/problems/integer-to-roman" target="_blank" rel="noopener">整数转罗马数字</a></h2><p>水题一个，模拟一下即可。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">intToRoman</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt; pair&lt;<span class="keyword">int</span>,<span class="built_in">string</span>&gt; &gt; mp;</span><br><span class="line">        mp.push_back( make_pair(<span class="number">1000</span>,<span class="string">"M"</span>) );</span><br><span class="line">        mp.push_back( make_pair(<span class="number">900</span>,<span class="string">"CM"</span>) );</span><br><span class="line">        mp.push_back( make_pair(<span class="number">500</span>,<span class="string">"D"</span>) );</span><br><span class="line">        mp.push_back( make_pair(<span class="number">400</span>,<span class="string">"CD"</span>) );</span><br><span class="line">        mp.push_back( make_pair(<span class="number">100</span>,<span class="string">"C"</span>) );</span><br><span class="line">        mp.push_back( make_pair(<span class="number">90</span>,<span class="string">"XC"</span>) );</span><br><span class="line">        mp.push_back( make_pair(<span class="number">50</span>,<span class="string">"L"</span>) );</span><br><span class="line">        mp.push_back( make_pair(<span class="number">40</span>,<span class="string">"XL"</span>) );</span><br><span class="line">        mp.push_back( make_pair(<span class="number">10</span>,<span class="string">"X"</span>) );</span><br><span class="line">        mp.push_back( make_pair(<span class="number">9</span>,<span class="string">"IX"</span>) );</span><br><span class="line">        mp.push_back( make_pair(<span class="number">5</span>,<span class="string">"V"</span>) );</span><br><span class="line">        mp.push_back( make_pair(<span class="number">4</span>,<span class="string">"IV"</span>) );</span><br><span class="line">        mp.push_back( make_pair(<span class="number">1</span>,<span class="string">"I"</span>) );</span><br><span class="line">        <span class="built_in">string</span> ans = <span class="string">""</span>;</span><br><span class="line">        <span class="keyword">for</span>( <span class="built_in">vector</span>&lt; pair&lt;<span class="keyword">int</span>,<span class="built_in">string</span>&gt; &gt;:: iterator it = mp.begin(); it!=mp.end(); it++ )&#123;</span><br><span class="line">            <span class="keyword">while</span>( num&gt;=(*it).first )&#123;</span><br><span class="line">                ans += (*it).second;</span><br><span class="line">                num -= (*it).first;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="13、罗马数字转整数"><a href="#13、罗马数字转整数" class="headerlink" title="13、罗马数字转整数"></a>13、<a href="https://leetcode-cn.com/problems/roman-to-integer" target="_blank" rel="noopener">罗马数字转整数</a></h2><p>水题，直接模拟</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">romanToInt</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">map</span>&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt; mp;</span><br><span class="line">        mp[<span class="string">'I'</span>] = <span class="number">1</span>, mp[<span class="string">'V'</span>] = <span class="number">5</span>, mp[<span class="string">'X'</span>] = <span class="number">10</span>, mp[<span class="string">'L'</span>] = <span class="number">50</span>;</span><br><span class="line">        mp[<span class="string">'C'</span>] = <span class="number">100</span>, mp[<span class="string">'D'</span>] = <span class="number">500</span>, mp[<span class="string">'M'</span>] = <span class="number">1000</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; nums;</span><br><span class="line">        <span class="keyword">for</span>( <span class="keyword">int</span> i=<span class="number">0</span>; i&lt;s.length(); i++ )</span><br><span class="line">            nums.push_back( mp[s[i]] );</span><br><span class="line">        nums.push_back(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>( <span class="keyword">int</span> i=<span class="number">0</span>; i&lt;nums.size()<span class="number">-1</span>; i++ )&#123;</span><br><span class="line">            <span class="keyword">if</span>( nums[i]&lt;nums[i+<span class="number">1</span>] )&#123;</span><br><span class="line">                ans += nums[i+<span class="number">1</span>]-nums[i];</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                ans += nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="14、最长公共前缀"><a href="#14、最长公共前缀" class="headerlink" title="14、最长公共前缀"></a>14、<a href="https://leetcode-cn.com/problems/longest-common-prefix" target="_blank" rel="noopener">最长公共前缀</a></h2><p>没啥好方案，直接暴力即可。暴力的方式有多种，一种像这里直接每次一个字符一个字符的得出 <code>ans</code> ，也可以挨个字符串直接与 <code>ans（初值为字符串strs[0]）</code> 比较，逐渐缩小 <code>ans</code> 的长度，直到最后得出结果。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">longestCommonPrefix</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; strs)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>( strs.size()==<span class="number">0</span> )</span><br><span class="line">            <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">        <span class="keyword">int</span> lens = <span class="number">0</span>, i = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">string</span> ans = <span class="string">""</span>;</span><br><span class="line">        <span class="keyword">char</span> ch;</span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>( strs[<span class="number">0</span>].length() &gt; lens )</span><br><span class="line">                ch = strs[<span class="number">0</span>][lens];</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">return</span> ans;</span><br><span class="line">            <span class="keyword">for</span>( i=<span class="number">1</span>; i&lt;strs.size(); i++ )&#123;</span><br><span class="line">                <span class="keyword">if</span>( strs[i][lens]!=ch )</span><br><span class="line">                    <span class="keyword">return</span> ans;</span><br><span class="line">            &#125;</span><br><span class="line">            ans += ch;</span><br><span class="line">            lens++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="15、三数之和"><a href="#15、三数之和" class="headerlink" title="15、三数之和"></a>15、<a href="https://leetcode-cn.com/problems/3sum" target="_blank" rel="noopener">三数之和</a></h2><p>三数之和其实和前面的两数之和原理一样，都是使用的双指针。这里的三数，其实可以直接固定一数，然后调用前面写的两数之和的代码。唯一的一点 <code>trick</code> 可能就是在去重上。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; threeSum(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt; <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; ans;</span><br><span class="line">        <span class="keyword">if</span>( nums.size()&lt;<span class="number">3</span> )</span><br><span class="line">            <span class="keyword">return</span> ans;</span><br><span class="line">        <span class="comment">//对 nums 进行排序并去重(此处去重不合适)</span></span><br><span class="line">        sort( nums.begin(), nums.end() );</span><br><span class="line">        <span class="comment">//vector&lt;int&gt;:: iterator it = unique( nums.begin(), nums.end() );</span></span><br><span class="line">        <span class="comment">//nums.erase( it, nums.end() );</span></span><br><span class="line">        <span class="keyword">for</span>( <span class="keyword">int</span> i=<span class="number">0</span>; i&lt;nums.size()<span class="number">-2</span>; i++ )&#123;</span><br><span class="line">            <span class="keyword">if</span>( i&gt;<span class="number">0</span> &amp;&amp; nums[i<span class="number">-1</span>]==nums[i] )</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            findTwoSum( nums, i+<span class="number">1</span>, nums.size()<span class="number">-1</span>, i, ans );</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">findTwoSum</span><span class="params">( <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> s, <span class="keyword">int</span> e, <span class="keyword">int</span> target, <span class="built_in">vector</span>&lt; <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt;&amp; ans )</span></span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; step_ans;</span><br><span class="line">        <span class="keyword">while</span>( s&lt;e )&#123;</span><br><span class="line">            <span class="keyword">if</span>( nums[s]+nums[e] == -nums[target] )&#123;</span><br><span class="line">                step_ans.clear();</span><br><span class="line">                step_ans.push_back(nums[target]);</span><br><span class="line">                step_ans.push_back(nums[s]);</span><br><span class="line">                step_ans.push_back(nums[e]);</span><br><span class="line">                ans.push_back(step_ans);</span><br><span class="line">                s++;</span><br><span class="line">                e--;</span><br><span class="line">                <span class="keyword">while</span>( s &lt; e &amp;&amp; nums[s]==nums[s<span class="number">-1</span>] )</span><br><span class="line">                    s++;</span><br><span class="line">                <span class="keyword">while</span>( e &gt; s &amp;&amp; nums[e]==nums[e+<span class="number">1</span>] )</span><br><span class="line">                    e--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>( nums[s]+nums[e] &gt; -nums[target] )</span><br><span class="line">                e--;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                s++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="16、最接近的三数之和"><a href="#16、最接近的三数之和" class="headerlink" title="16、最接近的三数之和"></a>16、<a href="https://leetcode-cn.com/problems/3sum-closest" target="_blank" rel="noopener">最接近的三数之和</a></h2><p>和三数之和的原理一样，排序后使用双指针遍历找最优解。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">threeSumClosest</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        sort( nums.begin(), nums.end() );</span><br><span class="line">        <span class="keyword">int</span> nearest = nums[<span class="number">0</span>]+nums[<span class="number">1</span>]+nums[<span class="number">2</span>], tmpSum;</span><br><span class="line">        <span class="keyword">for</span>( <span class="keyword">int</span> i=<span class="number">0</span>; i&lt;nums.size()<span class="number">-2</span>; i++ )&#123;</span><br><span class="line">            <span class="keyword">int</span> f = i+<span class="number">1</span>, e = nums.size()<span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">while</span>( f&lt;e )&#123;</span><br><span class="line">                tmpSum = nums[f] + nums[e] + nums[i];</span><br><span class="line">                nearest = <span class="built_in">abs</span>(target-nearest)&gt;<span class="built_in">abs</span>(target-tmpSum)? tmpSum:nearest;</span><br><span class="line">                <span class="keyword">if</span>( tmpSum==target )</span><br><span class="line">                    <span class="keyword">return</span> target;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>( tmpSum &gt; target )</span><br><span class="line">                    e--;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    f++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nearest;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="17、电话号码的字母组合"><a href="#17、电话号码的字母组合" class="headerlink" title="17、电话号码的字母组合"></a>17、<a href="https://leetcode-cn.com/problems/letter-combinations-of-a-phone-number" target="_blank" rel="noopener">电话号码的字母组合</a></h2><p>一行深搜代码解决，2年没写搜索了，敲的时候好生疏。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; letterCombinations(<span class="built_in">string</span> digits) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; mp,ans;</span><br><span class="line">        <span class="built_in">string</span> cur_ans;</span><br><span class="line">        mp.push_back(<span class="string">""</span>);</span><br><span class="line">        mp.push_back(<span class="string">""</span>);</span><br><span class="line">        mp.push_back(<span class="string">"abc"</span>);</span><br><span class="line">        mp.push_back(<span class="string">"def"</span>);</span><br><span class="line">        mp.push_back(<span class="string">"ghi"</span>);</span><br><span class="line">        mp.push_back(<span class="string">"jkl"</span>);</span><br><span class="line">        mp.push_back(<span class="string">"mno"</span>);</span><br><span class="line">        mp.push_back(<span class="string">"pqrs"</span>);</span><br><span class="line">        mp.push_back(<span class="string">"tuv"</span>);</span><br><span class="line">        mp.push_back(<span class="string">"wxyz"</span>);</span><br><span class="line">        <span class="keyword">if</span>( digits.length() )</span><br><span class="line">            digitsToString( mp, digits, ans, cur_ans );</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">digitsToString</span><span class="params">( <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; mp, <span class="built_in">string</span> digits, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; ans, <span class="built_in">string</span> cur_ans )</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>( digits.length()==<span class="number">0</span> )&#123;</span><br><span class="line">            ans.push_back( cur_ans );</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>( <span class="keyword">int</span> i=<span class="number">0</span>; i&lt;mp[digits[<span class="number">0</span>]-<span class="string">'0'</span>].length(); i++ )&#123;</span><br><span class="line">            digitsToString( mp, digits.substr(<span class="number">1</span>), ans, cur_ans+mp[digits[<span class="number">0</span>]-<span class="string">'0'</span>][i] );</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="18、四数之和"><a href="#18、四数之和" class="headerlink" title="18、四数之和"></a>18、<a href="https://leetcode-cn.com/problems/4sum" target="_blank" rel="noopener">四数之和</a></h2><p>还是双指针操作（发现一个规律就是，前面这些和双指针操作相关的题目，一个典型的特点就是数组要先排个序），算法复杂度 $  O(n^3) $ ，其实有很多种解题方式。</p><p>第一种：双指针操作，先固定两个位置，然后 $ O(n) $ 的时间复杂度遍历剩下的元素，找解的过程中就去除可能存在的重复解，体现在代码中就是一片形式相同的<code>while</code>循环。</p><p>第二种：还是双指针操作，在求解的过程中，我不管解是否存在重复，一一加到<code>ans</code>里面，最后再进行一个去重处理。优点是编码简单，缺点是空间复杂度高，最坏情况下为$n^4$的空间复杂度（nums全为0，target也为0）。</p><p>第三种：以空间换时间，利用$ O(n^2) $的空间先求出两个数字的和，然后变成 <code>两数之和</code>  问题。</p><p>第四种：使用深搜操作，理论上来讲，此种方法可以求 <code>m</code> 数之和，时间复杂度为 $ O(n^{m-1}) $。</p><p>方案一代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; fourSum(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt; <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; ans;</span><br><span class="line">        <span class="keyword">if</span>( nums.size()&lt;<span class="number">4</span> )</span><br><span class="line">            <span class="keyword">return</span> ans;</span><br><span class="line">        sort( nums.begin(), nums.end() );</span><br><span class="line">        <span class="keyword">for</span>( <span class="keyword">int</span> i=<span class="number">0</span>; i&lt;nums.size()<span class="number">-3</span>; i++ )&#123;</span><br><span class="line">            <span class="keyword">for</span>( <span class="keyword">int</span> j=i+<span class="number">1</span>; j&lt;nums.size()<span class="number">-2</span>; j++ )&#123;</span><br><span class="line">                <span class="keyword">int</span> f = j+<span class="number">1</span>, e = nums.size()<span class="number">-1</span>;</span><br><span class="line">                <span class="keyword">while</span>( f&lt;e )&#123;</span><br><span class="line">                    <span class="keyword">int</span> sum = nums[i]+nums[j]+nums[f]+nums[e];</span><br><span class="line">                    <span class="keyword">if</span>( sum==target )&#123;</span><br><span class="line">                        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; tmp_ans;</span><br><span class="line">                        tmp_ans.push_back(nums[i]);</span><br><span class="line">                        tmp_ans.push_back(nums[j]);</span><br><span class="line">                        tmp_ans.push_back(nums[f]);</span><br><span class="line">                        tmp_ans.push_back(nums[e]);</span><br><span class="line">                        ans.push_back( tmp_ans );</span><br><span class="line">                        f++;</span><br><span class="line">                        <span class="keyword">while</span>( f&lt;e &amp;&amp; nums[f<span class="number">-1</span>]==nums[f] )&#123;</span><br><span class="line">                            f++;</span><br><span class="line">                        &#125;</span><br><span class="line">                        e--;</span><br><span class="line">                        <span class="keyword">while</span>( e&gt;f &amp;&amp; nums[e+<span class="number">1</span>]==nums[e] )&#123;</span><br><span class="line">                            e--;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span>( sum&gt;target )&#123;</span><br><span class="line">                        e--;</span><br><span class="line">                        <span class="keyword">while</span>( e&gt;f &amp;&amp; nums[e+<span class="number">1</span>]==nums[e] )&#123;</span><br><span class="line">                            e--;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span>&#123;</span><br><span class="line">                        f++;</span><br><span class="line">                        <span class="keyword">while</span>( f&lt;e &amp;&amp; nums[f<span class="number">-1</span>]==nums[f] )&#123;</span><br><span class="line">                            f++;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">while</span>( j+<span class="number">1</span>&lt;nums.size()<span class="number">-2</span> &amp;&amp; nums[j+<span class="number">1</span>]==nums[j] )&#123;</span><br><span class="line">                    j++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span>( i+<span class="number">1</span>&lt;nums.size()<span class="number">-3</span> &amp;&amp; nums[i+<span class="number">1</span>]==nums[i] )&#123;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="19、删除链表的倒数第N个节点"><a href="#19、删除链表的倒数第N个节点" class="headerlink" title="19、删除链表的倒数第N个节点"></a>19、<a href="https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list" target="_blank" rel="noopener">删除链表的倒数第N个节点</a></h2><p>一遍遍历即可，其实也是双指针的思想.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">removeNthFromEnd</span><span class="params">(ListNode* head, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        ListNode *dummy = (ListNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(ListNode));</span><br><span class="line">        dummy-&gt;next = head;</span><br><span class="line">        ListNode *f = dummy, *e = dummy;</span><br><span class="line">        <span class="keyword">for</span>( <span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++ )</span><br><span class="line">            e = e-&gt;next;</span><br><span class="line">        <span class="keyword">while</span>( e-&gt;next )&#123;</span><br><span class="line">            f = f-&gt;next;</span><br><span class="line">            e = e-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        f-&gt;next = f-&gt;next-&gt;next;</span><br><span class="line">        <span class="keyword">return</span> dummy-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="20、有效的括号"><a href="#20、有效的括号" class="headerlink" title="20、有效的括号"></a>20、<a href="https://leetcode-cn.com/problems/valid-parentheses" target="_blank" rel="noopener">有效的括号</a></h2><p>水题，使用栈匹配一下即可，遇到左括号进栈，遇见右括号出栈，最后判断栈是否为空。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isValid</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">stack</span>&lt;<span class="keyword">char</span>&gt; ans;</span><br><span class="line">        ans.push(<span class="string">'#'</span>); <span class="comment">//加栈底后期就不用判断空不空了</span></span><br><span class="line">        <span class="keyword">for</span>( <span class="keyword">int</span> i=<span class="number">0</span>; i&lt;s.length(); i++ )&#123;</span><br><span class="line">            <span class="keyword">if</span>( s[i]==<span class="string">'('</span> || s[i]==<span class="string">'['</span> || s[i]==<span class="string">'&#123;'</span> )</span><br><span class="line">                ans.push(s[i]);</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>( (s[i]==<span class="string">')'</span>&amp;&amp;ans.top()!=<span class="string">'('</span>) || (s[i]==<span class="string">']'</span>&amp;&amp;ans.top()!=<span class="string">'['</span>) || (s[i]==<span class="string">'&#125;'</span>&amp;&amp;ans.top()!=<span class="string">'&#123;'</span>) )</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    ans.pop();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans.top()==<span class="string">'#'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;11、盛最多水的容器&quot;&gt;&lt;a href=&quot;#11、盛最多水的容器&quot; class=&quot;headerlink&quot; title=&quot;11、盛最多水的容器&quot;&gt;&lt;/a&gt;11、&lt;a href=&quot;https://leetcode-cn.com/problems/container-with-most-water&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;盛最多水的容器&lt;/a&gt;&lt;/h2&gt;&lt;p&gt;双指针，算法中一个很重要的技巧，之前的三数求和就用到了双指针的技巧。&lt;/p&gt;
&lt;p&gt;我们在由线段长度构成的数组中使用两个指针，一个放在开始，一个置于末尾。 此外，我们会使用变量 &lt;code&gt;maxArea&lt;/code&gt; 来持续存储到目前为止所获得的最大面积。 在每一步中，我们会找出指针所指向的两条线段形成的区域，更新 &lt;code&gt;maxArea&lt;/code&gt;，并将指向较短线段的指针向较长线段那端移动一步。&lt;/p&gt;
&lt;figure class=&quot;highlight c++&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Solution&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt;:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;maxArea&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;built_in&quot;&gt;vector&lt;/span&gt;&amp;lt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt;&amp;gt;&amp;amp; height)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; maxArea = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; frontPoint = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;, endPoint = height.size()&lt;span class=&quot;number&quot;&gt;-1&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;while&lt;/span&gt;( frontPoint&amp;lt;endPoint )&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            maxArea = max( maxArea, (endPoint-frontPoint)*min(height[frontPoint], height[endPoint]) );&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;( height[frontPoint]&amp;lt;height[endPoint] )&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                frontPoint++;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                endPoint--;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; maxArea;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="LeetCode" scheme="https://wangjibao.com.cn/categories/LeetCode/"/>
    
      <category term="LeetCode11-20" scheme="https://wangjibao.com.cn/categories/LeetCode/LeetCode11-20/"/>
    
    
      <category term="LeetCode" scheme="https://wangjibao.com.cn/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>colab免费云GPU使用教程</title>
    <link href="https://wangjibao.com.cn/2018/10/04/colab%E5%85%8D%E8%B4%B9%E4%BA%91GPU%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/"/>
    <id>https://wangjibao.com.cn/2018/10/04/colab免费云GPU使用教程/</id>
    <published>2018-10-04T15:58:42.000Z</published>
    <updated>2018-10-05T14:17:38.415Z</updated>
    
    <content type="html"><![CDATA[<h1 id="谷歌coLab免费云GPU搭建教程"><a href="#谷歌coLab免费云GPU搭建教程" class="headerlink" title="谷歌coLab免费云GPU搭建教程"></a>谷歌coLab免费云GPU搭建教程</h1><h3 id="网上教程的链接"><a href="#网上教程的链接" class="headerlink" title="网上教程的链接"></a>网上教程的链接</h3><p>知乎  <a href="https://zhuanlan.zhihu.com/p/34436045" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/34436045</a></p><p>cnblogs   <a href="http://www.cnblogs.com/kid551/p/8544908.html" target="_blank" rel="noopener">http://www.cnblogs.com/kid551/p/8544908.html</a></p><p><strong>注意第11步的代码替换成下列的代码：</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">!apt-get install -y -qq software-properties-common python-software-properties module-init-tools</span><br><span class="line"><span class="meta">#</span>!add-apt-repository -y ppa:alessandro-strada/ppa 2&gt;&amp;1 &gt; /dev/null</span><br><span class="line"><span class="meta">#</span>!apt-get update -qq 2&gt;&amp;1 &gt; /dev/null</span><br><span class="line"><span class="meta">#</span>!apt-get -y install -qq google-drive-ocamlfuse fuse</span><br><span class="line">!wget https://launchpad.net/~alessandro-strada/+archive/ubuntu/google-drive-ocamlfuse-beta/+build/15331130/+files/google-drive-ocamlfuse_0.7.0-0ubuntu1_amd64.deb</span><br><span class="line">!dpkg -i google-drive-ocamlfuse_0.7.0-0ubuntu1_amd64.deb</span><br><span class="line">!apt-get install -f</span><br><span class="line">!apt-get -y install -qq fuse</span><br><span class="line">from google.colab import auth</span><br><span class="line">auth.authenticate_user()</span><br><span class="line">from oauth2client.client import GoogleCredentials</span><br><span class="line">creds = GoogleCredentials.get_application_default()</span><br><span class="line">import getpass</span><br><span class="line">!google-drive-ocamlfuse -headless -id=&#123;creds.client_id&#125; -secret=&#123;creds.client_secret&#125; &lt; /dev/null 2&gt;&amp;1 | grep URL</span><br><span class="line">vcode = getpass.getpass()</span><br><span class="line">!echo &#123;vcode&#125; | google-drive-ocamlfuse -headless -id=&#123;creds.client_id&#125; -secret=&#123;creds.client_secret&#125;</span><br></pre></td></tr></table></figure><p>会报错，由于 <code>dpkg -i</code> 安装时依赖的原因，但是由于使用了 <code>install -f</code>，安装会成功的。</p><p>接着使用 <code>google-drive-ocamlfuse</code>  将云盘文件夹和远程的VM链接起来，方便文件共享操作。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">!mkdir -p drive</span><br><span class="line">!google-drive-ocamlfuse drive</span><br></pre></td></tr></table></figure><p>路径：</p><p>\content\drive...</p><p><strong>取消挂载</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fusermount -u ***</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;谷歌coLab免费云GPU搭建教程&quot;&gt;&lt;a href=&quot;#谷歌coLab免费云GPU搭建教程&quot; class=&quot;headerlink&quot; title=&quot;谷歌coLab免费云GPU搭建教程&quot;&gt;&lt;/a&gt;谷歌coLab免费云GPU搭建教程&lt;/h1&gt;&lt;h3 id=&quot;网上教程的
      
    
    </summary>
    
      <category term="笔记" scheme="https://wangjibao.com.cn/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="笔记" scheme="https://wangjibao.com.cn/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>Ubuntu16.04安装Tensorflow-GPU</title>
    <link href="https://wangjibao.com.cn/2018/10/04/Ubuntu16-04%E5%AE%89%E8%A3%85Tensorflow-GPU/"/>
    <id>https://wangjibao.com.cn/2018/10/04/Ubuntu16-04安装Tensorflow-GPU/</id>
    <published>2018-10-04T15:57:47.000Z</published>
    <updated>2019-04-20T08:06:44.943Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、Ubuntu安装及TensorFlow-Gpu安装"><a href="#一、Ubuntu安装及TensorFlow-Gpu安装" class="headerlink" title="一、Ubuntu安装及TensorFlow-Gpu安装"></a>一、Ubuntu安装及TensorFlow-Gpu安装</h2><p>1、UEFI启动的ubuntu要将 <code>\boot</code>分区设置成 <code>EFI</code>分区，这样会在<code>bios</code>中出现启动项。注意EFI模式只识别FAT32的U盘启动盘。</p><p>2、安装 搜狗输入法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">下载 sogou.deb</span><br><span class="line">sudo dpkg -i sogou.deb       #出现安装不成功，需要依赖</span><br><span class="line">sudo apt-get install -f      #安装依赖</span><br><span class="line">sudo dpkg -i sogou.deb</span><br><span class="line">然后在设置里按照自己的需求设置</span><br></pre></td></tr></table></figure><p>3、设置息屏时间</p><p>4、注意一定要安装好对应的显卡版本，在 <code>设置 &gt;&gt; 软件和更新 &gt;&gt; 附加驱动</code>里进行选择对应的显卡驱动<code>nvidia</code>；命令 <code>nvidia-smi</code>查看GPU驱动信息。   </p><p>5、安装更新   <code>sudo apt-get update</code>      <code>sudo apt-get install vim</code></p><p>6、安装 及卸载Anaconda</p><p>官网下载对应的安装包，执行命令 <code>bash Anaconda2-4.4.0-Linux-x86_64.sh</code> 即可进行安装，期间会选择安装路径啥的，默认即可。 安装完成后，重启 <code>命令窗口</code>，执行 python  命令即可看到已经安装成功。如果不成功，执行 <code>source ~/.bashrc</code>命令，使 <code>bashrc</code>生效。</p><p>卸载的话：</p><ul><li>删除整个anaconda的目录     <code>rm -rf anaconda*</code></li><li>将 <code>~/.bashrc</code>文件中的关于 anaconda的行注释掉</li><li>生效      <code>source ~/.bashrc</code></li></ul><p>7、命令  <code>anaconda-navigator</code>进入图形界面的操作。其实主要还是命令行操作，下面是 <code>conda</code>的常用命令。注意 <code>conda</code>是python的环境管理工具，兼具包管理；<code>pip</code>只是python的包管理工具而已。</p><a id="more"></a><p>8、<code>conda</code>常用命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">conda --help                             #查看帮助</span><br><span class="line">conda update conda                       #升级conda</span><br><span class="line">conda update anaconda                    #升级anaconda</span><br><span class="line">conda --version     或者    conda -V      #查看conda的版本</span><br><span class="line">conda info --envs                        #查看本地已创建的python运行环境，带*号的代表当前环境</span><br><span class="line">#创建python运行环境</span><br><span class="line">conda create --name &lt;env_name&gt; python=2.7/3.5/3.6</span><br><span class="line">#列出当前环境下所有活跃的包</span><br><span class="line">conda list</span><br><span class="line"></span><br><span class="line">#安装Python包</span><br><span class="line">conda install --name &lt;env_name&gt; &lt;package_name&gt;=version</span><br><span class="line">或者直接 activate 进入对应的环境中执行</span><br><span class="line">conda install &lt;package_name&gt;</span><br><span class="line"></span><br><span class="line">#更新python包</span><br><span class="line">conda update --name &lt;env_name&gt; &lt;package_name&gt;</span><br><span class="line">或者进入对应的环境执行</span><br><span class="line">conda update &lt;package_name&gt;</span><br><span class="line">#更新所有的包</span><br><span class="line">conda update --all</span><br><span class="line"></span><br><span class="line">#移除整个环境或者环境中的包</span><br><span class="line">conda remove --name &lt;env_name&gt; &lt;package_name&gt;     #进去到对应的环境就可以不指定&lt;env_name&gt;</span><br><span class="line">conda remove --name &lt;env_name&gt; --all              #将环境的包全部移除，相当于移除环境</span><br><span class="line"></span><br><span class="line">#查找包</span><br><span class="line">conda search --full-name &lt;package_name&gt;     #精确查找</span><br><span class="line">conda search *&lt;package_name&gt;*               #模糊查找</span><br><span class="line"></span><br><span class="line">#退出当前环境</span><br><span class="line">source deactivate &lt;env_name&gt;</span><br><span class="line">#激活当前环境</span><br><span class="line">source activate &lt;env_name&gt;</span><br><span class="line"></span><br><span class="line">#删除conda</span><br><span class="line">rm -rf ~/anaconda</span><br></pre></td></tr></table></figure><p>9、安装 <code>tensorflow-gpu</code></p><p>使用<code>conda</code>创建一个python环境，并激活进入，在保证<code>nvidia</code>显卡驱动正常的情况下，在该环境只执行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda install tensorflow-gpu=1.8/1.0/1.10/1.11    #我用的是1.9</span><br></pre></td></tr></table></figure><p>此命令会自动帮你安装对应版本的 <code>cudaToolKit</code>， <code>cupTi</code> ， <code>cuDNN SDK</code>等等，十分强大，再也不用自己照着傻逼<code>CSDN</code>配置各种东西了。</p><p>10、查看 <code>cuda</code> 和 <code>cuDNN</code>版本</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#cuda 版本 （9.0）</span><br><span class="line">cat /usr/local/cuda/version.txt</span><br><span class="line">#cudnn 版本 （7.3）</span><br><span class="line">cat /usr/local/cuda/include/cudnn.h | grep CUDNN_MAJOR -A 2</span><br></pre></td></tr></table></figure><h2 id="二、ubuntu安装pycharm"><a href="#二、ubuntu安装pycharm" class="headerlink" title="二、ubuntu安装pycharm"></a>二、ubuntu安装pycharm</h2><p>1、去官网下载对应的 <code>community</code>版本，免费。</p><p>2、<code>tar -xvzf **</code>进行解压到当前文件夹中；  或者直接 <code>extract</code>提取</p><p>3、进入到对应的 <code>bin</code> 文件夹，执行命令 <code>sh ./pycharm.sh</code>进行安装</p><p>4、 设置桌面图标</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo gedit  /usr/share/applications/pycharm.desktop</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[Desktop Entry]</span><br><span class="line">Type=Application</span><br><span class="line">Name=Pycharm</span><br><span class="line">GenericName=Pycharm3</span><br><span class="line">Comment=Pycharm3:The Python IDE</span><br><span class="line">Exec=&quot;/home/snakeson/developer/pycharm-community-2017.2.3/bin/pycharm.sh&quot; %f  #注意替换</span><br><span class="line">Icon=/home/snakeson/developer/pycharm-community-2017.2.3/bin/pycharm.png      #注意替换 </span><br><span class="line">Terminal=pycharm</span><br><span class="line">Categories=Pycharm;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo chmod +x /usr/share/applications/pycharm.desktop      #添加执行权限</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">将/usr/share/applications/pycharm.desktop文件拷贝到桌面，双击即可运行。</span><br></pre></td></tr></table></figure><p>5、卸载pycharm</p><ul><li>所有的配置都保存在解压的目录中，所以卸载只要<code>sudo rm -r **文件夹</code>  </li><li>默认会在 <code>home</code>目录创建一个 隐藏目录    <code>sudo rm -r ~/.pycharm*</code></li><li>删除之前创建的 <code>pycharm.desktop</code>文件，这样，所有的东西就全卸载干净了。</li></ul><p>6、之前使用 <code>conda 创建的所有的python环境，在pycharm中都可以使用。既可以在创建项目的时候指定已存在的解释环境，也可以后期在设置中更改</code>interpreter`选项。</p><p>7、pycharm中设置鼠标滚轮调节字体大小</p><p>在设置中 <code>keymap</code>  ，搜索<code>increase</code>  <code>decrease</code> 字段即可设置 鼠标快捷键</p><p>8、pycharm设置     <code>菜单栏</code> 字体及大小</p><p>在设置里 <code>override default fonts by（not recommended)</code>中修改。</p><p>9、自动生成新建Py文件的模板 </p><p><code>file &gt;&gt; setting &gt;&gt; editor &gt;&gt; file and code templates</code>中，选择<code>python script</code>文件，添加如下代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># _*_ coding: utf-8 _*_</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">@author: spring371327</span></span><br><span class="line"><span class="string">@time: $&#123;DATE&#125; $&#123;TIME&#125;</span></span><br><span class="line"><span class="string">"""</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;一、Ubuntu安装及TensorFlow-Gpu安装&quot;&gt;&lt;a href=&quot;#一、Ubuntu安装及TensorFlow-Gpu安装&quot; class=&quot;headerlink&quot; title=&quot;一、Ubuntu安装及TensorFlow-Gpu安装&quot;&gt;&lt;/a&gt;一、Ubuntu安装及TensorFlow-Gpu安装&lt;/h2&gt;&lt;p&gt;1、UEFI启动的ubuntu要将 &lt;code&gt;\boot&lt;/code&gt;分区设置成 &lt;code&gt;EFI&lt;/code&gt;分区，这样会在&lt;code&gt;bios&lt;/code&gt;中出现启动项。注意EFI模式只识别FAT32的U盘启动盘。&lt;/p&gt;
&lt;p&gt;2、安装 搜狗输入法&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;下载 sogou.deb&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;sudo dpkg -i sogou.deb       #出现安装不成功，需要依赖&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;sudo apt-get install -f      #安装依赖&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;sudo dpkg -i sogou.deb&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;然后在设置里按照自己的需求设置&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;3、设置息屏时间&lt;/p&gt;
&lt;p&gt;4、注意一定要安装好对应的显卡版本，在 &lt;code&gt;设置 &amp;gt;&amp;gt; 软件和更新 &amp;gt;&amp;gt; 附加驱动&lt;/code&gt;里进行选择对应的显卡驱动&lt;code&gt;nvidia&lt;/code&gt;；命令 &lt;code&gt;nvidia-smi&lt;/code&gt;查看GPU驱动信息。   &lt;/p&gt;
&lt;p&gt;5、安装更新   &lt;code&gt;sudo apt-get update&lt;/code&gt;      &lt;code&gt;sudo apt-get install vim&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;6、安装 及卸载Anaconda&lt;/p&gt;
&lt;p&gt;官网下载对应的安装包，执行命令 &lt;code&gt;bash Anaconda2-4.4.0-Linux-x86_64.sh&lt;/code&gt; 即可进行安装，期间会选择安装路径啥的，默认即可。 安装完成后，重启 &lt;code&gt;命令窗口&lt;/code&gt;，执行 python  命令即可看到已经安装成功。如果不成功，执行 &lt;code&gt;source ~/.bashrc&lt;/code&gt;命令，使 &lt;code&gt;bashrc&lt;/code&gt;生效。&lt;/p&gt;
&lt;p&gt;卸载的话：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;删除整个anaconda的目录     &lt;code&gt;rm -rf anaconda*&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;将 &lt;code&gt;~/.bashrc&lt;/code&gt;文件中的关于 anaconda的行注释掉&lt;/li&gt;
&lt;li&gt;生效      &lt;code&gt;source ~/.bashrc&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;7、命令  &lt;code&gt;anaconda-navigator&lt;/code&gt;进入图形界面的操作。其实主要还是命令行操作，下面是 &lt;code&gt;conda&lt;/code&gt;的常用命令。注意 &lt;code&gt;conda&lt;/code&gt;是python的环境管理工具，兼具包管理；&lt;code&gt;pip&lt;/code&gt;只是python的包管理工具而已。&lt;/p&gt;
    
    </summary>
    
      <category term="笔记" scheme="https://wangjibao.com.cn/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="笔记" scheme="https://wangjibao.com.cn/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>算法课第一次作业</title>
    <link href="https://wangjibao.com.cn/2018/10/04/%E7%AE%97%E6%B3%95%E8%AF%BE%E7%AC%AC%E4%B8%80%E6%AC%A1%E4%BD%9C%E4%B8%9A/"/>
    <id>https://wangjibao.com.cn/2018/10/04/算法课第一次作业/</id>
    <published>2018-10-04T15:56:17.000Z</published>
    <updated>2018-11-05T01:38:20.807Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一、Divide-and-Conquer"><a href="#一、Divide-and-Conquer" class="headerlink" title="一、Divide and Conquer"></a>一、Divide and Conquer</h3><p>　　You are interested in analyzing some hard-to-obtain data from two separate databases. Each database contains n numerical values, so there are 2n values total and you may assume that no two values are the same. You’d like to determine the median of this set of 2n values, which we will define here to be the n-th　smallest value.</p><p>　　However, the only way you can access these values is through queries to the databases. In a single query, you can specify a value k to one of the two databases, and the chosen database will return the kth smallest value that it contains. Since queries are expensive, you would like to compute the median using as few queries as possible.</p><p>Give an algorithm that finds the median value using at most O(logn) queries.　　</p><h4 id="1、problem-solving-ideas-and-pseudo-code"><a href="#1、problem-solving-ideas-and-pseudo-code" class="headerlink" title="1、problem-solving ideas and pseudo-code"></a>1、problem-solving ideas and pseudo-code</h4><p>首先将现实问题转化一下，变成计算机算法问题，即 <strong>找2个有序数组的并集的中位数</strong> ，<a href="https://leetcode-cn.com/problems/median-of-two-sorted-arrays/description/" target="_blank" rel="noopener">LeetCode 第四题</a>。</p><p><strong>(1）problem-solving ideas</strong></p><p>求中位数需要根据数组长度是奇数还是偶数分别讨论，奇数长度时中位数为最中间的一个数，偶数长度时中位数为最中间的两个数的平均值，为了方便，可以实现一个比题目更一般化的函数，求A和B的第k小数的函数，那么中位数的问题很容易解决。</p><p>求一个有序数组的第k个数只需要O(1)的复杂度，现在有两个数组，显然花费额外空间以O(n)时间归并然后O(1)寻找不满足题目要求。既然要求log时间复杂度，一般需要使用到二分思想。</p><p>分别考虑A和B的第k/2个元素：</p><ul><li>如果它们相等，则第k个数为其中的任意一个</li><li>如果A中的比较大，则B中前k/2个元素都不可能是第k个数了，因为这个数至少应该为A的第k/2个数，把B的前k/2去掉，然后重新寻找。</li><li>如果B中的比较大，则把A的前k/2个数去掉，重新寻找。</li></ul><p>直到A和B中某个变为空时或者寻找第1个数时可以停止递归，直接找到结果。</p><p>注意，上面的k/2只是理想的简单情况，实际上A和B的长度可能不够k/2，或者k为奇数等，但这些不是主要问题，可以让A取第k/2个数字，然后A不够长，则取A的最后一个数字，然后B取剩下长度对应的那个数字，具体参考代码。</p><a id="more"></a><p><strong>(2）pseudo code</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">findMedianSortedArrays</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums1, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> totalLength = nums1.size() + nums2.size();</span><br><span class="line">    <span class="keyword">if</span>( totalLength&amp;<span class="number">1</span> )</span><br><span class="line">        <span class="keyword">return</span> findKth( nums1.begin(), nums1.size(), nums2.begin(), nums2.size(), (totalLength&gt;&gt;<span class="number">1</span>)+<span class="number">1</span> );</span><br><span class="line">    <span class="keyword">else</span> <span class="comment">//除以 2.0 是为了保留小数点</span></span><br><span class="line">        <span class="keyword">return</span> (findKth( nums1.begin(), nums1.size(), nums2.begin(), nums2.size(), (totalLength&gt;&gt;<span class="number">1</span>) ) + findKth( nums1.begin(), nums1.size(), nums2.begin(), nums2.size(), (totalLength&gt;&gt;<span class="number">1</span>)+<span class="number">1</span> ))/<span class="number">2.0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findKth</span><span class="params">( <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;:: iterator nums1, <span class="keyword">int</span> len1, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;:: iterator nums2, <span class="keyword">int</span> len2, <span class="keyword">int</span> k )</span></span>&#123;</span><br><span class="line"><span class="comment">// 默认 len1 要大于 len2</span></span><br><span class="line">    <span class="keyword">if</span>( len1&lt;len2 )</span><br><span class="line">        <span class="keyword">return</span> findKth( nums2, len2, nums1, len1, k );</span><br><span class="line">    <span class="keyword">if</span>( len2==<span class="number">0</span> )</span><br><span class="line">        <span class="keyword">return</span> nums1[k<span class="number">-1</span>];</span><br><span class="line">    <span class="keyword">if</span>( k==<span class="number">1</span> )  <span class="comment">//k==1做特判，因为后期要移位, 不做特判point-1会出现负值</span></span><br><span class="line">        <span class="keyword">return</span> min( nums1[<span class="number">0</span>], nums2[<span class="number">0</span>] );</span><br><span class="line">    <span class="keyword">int</span> point2 = min( k&gt;&gt;<span class="number">1</span>, len2 );</span><br><span class="line">    <span class="keyword">int</span> point1 = k - point2;</span><br><span class="line">    <span class="comment">//下面对 nums1[point1-1] 和 nums2[point2-1]的大小关系进行讨论</span></span><br><span class="line">    <span class="keyword">if</span>( nums1[point1<span class="number">-1</span>] &gt; nums2[point2<span class="number">-1</span>] )</span><br><span class="line">        <span class="keyword">return</span> findKth( nums1, point1, nums2+point2, len2-point2, k-point2 );</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>( nums1[point1<span class="number">-1</span>] &lt; nums2[point2<span class="number">-1</span>] )</span><br><span class="line">        <span class="keyword">return</span> findKth( nums1+point1, len1-point1, nums2, point2, k-point1 );</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> nums1[point1<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="2、subproblem-reduction-graph"><a href="#2、subproblem-reduction-graph" class="headerlink" title="2、subproblem reduction graph"></a>2、subproblem reduction graph</h4><p><img src="/2018/10/04/算法课第一次作业/1.png" alt="问题缩减图"></p><h4 id="3、prove-the-correctness"><a href="#3、prove-the-correctness" class="headerlink" title="3、prove the correctness"></a>3、prove the correctness</h4><p>寻找两个有序数组的第K大数，那么肯定是第1个数组贡献 <strong>a</strong> 个数，第二个数组贡献 <strong>K - a</strong> 个数。首先我们假设每个数组分别贡献 <strong>K/2</strong>个数，讨论 A[k/2] 和 B[k/2] 的大小情况。</p><p>当 <strong>A[k/2] &gt; B[K/2]</strong> 时，很显然需要减少数组A贡献的数字的个数，增加数组B贡献的数组的个数，如下图：</p><p><img src="/2018/10/04/算法课第一次作业/11.png" alt=""></p><p>当 <strong>A[k/2] &lt; B[K/2]</strong> 时，很显然需要增加数组A贡献的数字的个数，减少数组B贡献的数组的个数，如下图：</p><p><img src="/2018/10/04/算法课第一次作业/13.png" alt=""></p><p>随着算法的执行，搜索的数组长度不断缩小，最后一定会返回对应的中位数值。</p><h4 id="4、the-complexity-of-this-algorithm"><a href="#4、the-complexity-of-this-algorithm" class="headerlink" title="4、the complexity of this algorithm"></a>4、the complexity of this algorithm</h4><p>分析可得：</p><p><img src="/2018/10/04/算法课第一次作业/41.png" alt=""></p><h3 id="五、Divide-and-Conquer"><a href="#五、Divide-and-Conquer" class="headerlink" title="五、Divide and Conquer"></a>五、Divide and Conquer</h3><p>　　Recall the problem of ﬁnding the number of inversions. As in the course, we are given a sequence of n numbers a1,··· ,an, which we assume are all distinct, and we deﬁne an inversion to be a pair i &lt; j such that ai &gt; aj.</p><p>　　We motivated the problem of counting inversions as a good measure of how diﬀerent two orderings are. However, one might feel that this measure is too sensitive. Let’s call a pair a significant inversion if i &lt; j and ai &gt; 3aj. Given an O(nlogn) algorithm to count the number of signiﬁcant inversions between two orderings.</p><h4 id="1、problem-solving-ideas-and-pseudo-code-1"><a href="#1、problem-solving-ideas-and-pseudo-code-1" class="headerlink" title="1、problem-solving ideas and pseudo-code"></a>1、problem-solving ideas and pseudo-code</h4><p><strong>(1）problem-solving ideas</strong></p><p>求数列的逆序数，除了暴力求解方式外，也可以使用归并排序、树状数组、线段树等结构进行计算。此处选择使用归并排序。</p><p>首先，将数组从中间切开，分为左右两半，<strong>A[0…n/2]</strong> 和 <strong>A [n/2+1…n]</strong>，分别计算这两个子问题的显著逆序数；</p><p>然后，计算跨左右两边的数对所形成的显著逆序的个数。</p><p>最后，将这三者的显著逆序数求和，即为整个数组的显著逆序数。</p><p><strong>(2）pseudo code</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">//统计变量num为全局变量</span><br><span class="line">void mergesort(int begin, int end)&#123;</span><br><span class="line">if (begin &gt;= end)</span><br><span class="line">return;</span><br><span class="line">int mid = (begin + end) / 2;</span><br><span class="line">mergesort(begin, mid);</span><br><span class="line">mergesort(mid + 1, end);</span><br><span class="line">mcount(begin, mid, end);</span><br><span class="line">merge(begin, mid, end);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void mcount(int begin, int mid, int end)&#123;</span><br><span class="line">int i = begin;</span><br><span class="line">int j = mid + 1;</span><br><span class="line">int k = begin;</span><br><span class="line">while (i &lt;= mid &amp;&amp; j &lt;= end)&#123;</span><br><span class="line">if (a[i] &gt; 2 * a[j])&#123;</span><br><span class="line">num += mid - i + 1;</span><br><span class="line">j++;</span><br><span class="line">&#125;</span><br><span class="line">else</span><br><span class="line">i++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">void merge(int begin, int mid, int end)&#123;</span><br><span class="line">int i = begin;</span><br><span class="line">int j = mid + 1;</span><br><span class="line">int k = begin;</span><br><span class="line"> </span><br><span class="line">while (i &lt;= mid &amp;&amp; j &lt;= end)&#123;</span><br><span class="line">if (a[i] &gt; a[j])&#123;</span><br><span class="line">temp[k] = a[j];</span><br><span class="line">k++;</span><br><span class="line">j++;</span><br><span class="line">&#125;</span><br><span class="line">else&#123;</span><br><span class="line">temp[k] = a[i];</span><br><span class="line">k++;</span><br><span class="line">i++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">while (i &lt;= mid)&#123;</span><br><span class="line">temp[k] = a[i];</span><br><span class="line">k++;</span><br><span class="line">i++;</span><br><span class="line">&#125;</span><br><span class="line">while (j &lt;= end)&#123;</span><br><span class="line">temp[k] = a[j];</span><br><span class="line">k++;</span><br><span class="line">j++;</span><br><span class="line">&#125;</span><br><span class="line">for (int p = begin; p &lt;= end; p++)</span><br><span class="line">a[p] = temp[p];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2、subproblem-reduction-graph-1"><a href="#2、subproblem-reduction-graph-1" class="headerlink" title="2、subproblem reduction graph"></a>2、subproblem reduction graph</h4><p>先分：</p><p><img src="/2018/10/04/算法课第一次作业/21.png" alt=""></p><p>后合：</p><p><img src="/2018/10/04/算法课第一次作业/22.png" alt=""></p><h4 id="3、prove-the-correctness-1"><a href="#3、prove-the-correctness-1" class="headerlink" title="3、prove the correctness"></a>3、prove the correctness</h4><p>其中，计算左右两边的显著逆序数的时候，会同时将左右两边的子数组变成有序。在计算跨两边的数对所形成的显著逆序的时候，就不用进行暴力遍历，只需O(n)的遍历即可。当 <strong>L[i] &gt; 3*R[j]</strong> 时，RC += |L|-i 即可，L中位于下标 i 之后的数字就不用遍历了，自然要比 3*R[j] 大。<br>同时，计算过程是基于归并排序的，整个算法即正确。</p><h4 id="4、the-complexity-of-this-algorithm-1"><a href="#4、the-complexity-of-this-algorithm-1" class="headerlink" title="4、the complexity of this algorithm"></a>4、the complexity of this algorithm</h4><p>计算左边的时间复杂度为 T(n/2)， 计算右边的时间复杂度为 T(n/2)， 合并的时间复杂度为 O(n)，所以总的时间复杂度为：</p><p><img src="/2018/10/04/算法课第一次作业/42.png" alt=""></p><h3 id="六、Divide-and-Conquer"><a href="#六、Divide-and-Conquer" class="headerlink" title="六、Divide and Conquer"></a>六、Divide and Conquer</h3><p>Given a table M consisting of 2n ∗ 2n blocks, we want to ﬁll it with a L-shaped module (consisting of three blocks). The L-shaped module is shown below.  </p><p><img src="/2018/10/04/算法课第一次作业/31.png" alt=""></p><p>Please give a ﬁll method, so that the last element of the table (M2n,2n) is empty.</p><p>For example: </p><p><img src="/2018/10/04/算法课第一次作业/32.png" alt=""></p><h4 id="1、problem-solving-ideas-and-pseudo-code-2"><a href="#1、problem-solving-ideas-and-pseudo-code-2" class="headerlink" title="1、problem-solving ideas and pseudo-code"></a>1、problem-solving ideas and pseudo-code</h4><p><strong>(1）problem-solving ideas</strong></p><p>　　有一个特殊方格的棋盘覆盖问题，只不过，此题目将特殊方格定死了，只能为最右下角那个，即 P(size-1,size-1)那个小方格。</p><p>　　该题关键在于如何划分各L型骨牌所在位置区域。我们发现，L型骨牌占三个方格，我们可以把棋盘从中央分为四块，那么这四块子棋盘中仅一块是有特殊方格的，可以用一块骨牌使得其他三块子棋盘均被覆盖。以此为原则，无论这种分法是否最终可解，我们首先保证了每个子棋盘都有一个特殊方格，所以，分治的模型就出来了。</p><p>　　我们可以用递归来完成分治的任务。每次递归，chess_board(int posx,int posy,int x,int y,int size)，(posx,posy)为子棋盘左上角坐标,size为子棋盘大小，因为棋盘总为正方形，所以size为边长，那么这3个参数就确定了子棋盘的位置和大小；(x,y)表示子棋盘中特殊方格的位置，这个位置是由上层递归分配骨牌后决定的。以此为标准，递归流程为：</p><p>①判断边界，若当前棋盘大小为1，则无法再分割，递归结束。</p><p>②定子棋盘中心位置。</p><p>③判断特殊方格所在位置（左上，右上，左下，或右下）。</p><p>④根据特殊方格位置确定所选L型骨牌，原特殊方格和三个L型骨牌的方格分别为四个子棋盘的特殊方格。</p><p>⑤依据④中判断，按编号填充棋盘。</p><p>⑥4次递归，分别对应四个子棋盘。</p><p><strong>(2）pseudo code</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">chess_board</span><span class="params">(<span class="keyword">int</span> posx,<span class="keyword">int</span> posy,<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">int</span> size)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>( size==<span class="number">1</span> )</span><br><span class="line"><span class="keyword">return</span> ;</span><br><span class="line">size /= <span class="number">2</span>;</span><br><span class="line"><span class="keyword">int</span> num = Count++;</span><br><span class="line"><span class="comment">//左上角</span></span><br><span class="line"><span class="keyword">if</span>( posx+size&gt;x &amp;&amp; posy+size&gt;y )</span><br><span class="line">chess_board(posx,posy,x,y,size);</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">board[posx+size<span class="number">-1</span>][posy+size<span class="number">-1</span>] = num;</span><br><span class="line">chess_board(posx,posy,posx+size<span class="number">-1</span>,posy+size<span class="number">-1</span>,size);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//右上角</span></span><br><span class="line"><span class="keyword">if</span>( y&gt;=posy+size &amp;&amp; x&lt;posx+size )</span><br><span class="line">chess_board(posx,posy+size,x,y,size);</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">board[posx+size<span class="number">-1</span>][posy+size] = num;</span><br><span class="line">chess_board(posx,posy+size,posx+size<span class="number">-1</span>,posy+size,size);</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">//左下角</span></span><br><span class="line"><span class="keyword">if</span>( x&gt;=posx+size &amp;&amp; y&lt;posy+size )</span><br><span class="line">chess_board(posx+size,posy,x,y,size);</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">board[posx+size][posy+size<span class="number">-1</span>] = num;</span><br><span class="line">chess_board(posx+size,posy,posx+size,posy+size<span class="number">-1</span>,size);</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">//右下角</span></span><br><span class="line"><span class="keyword">if</span>( x&gt;=posx+size &amp;&amp; y&gt;=posy+size )</span><br><span class="line">chess_board(posx+size,posy+size,x,y,size);</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">board[posx+size][posy+size] = num;</span><br><span class="line">chess_board(posx+size,posy+size,posx+size,posy+size,size);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2、subproblem-reduction-graph-2"><a href="#2、subproblem-reduction-graph-2" class="headerlink" title="2、subproblem reduction graph"></a>2、subproblem reduction graph</h4><p>假设有如下图的一个棋盘，棋盘中有一个特殊方格：</p><p><img src="/2018/10/04/算法课第一次作业/37.png" alt=""></p><p>第一次分割：</p><p><img src="/2018/10/04/算法课第一次作业/38.png" alt=""></p><p>第二次分割：</p><p><img src="/2018/10/04/算法课第一次作业/39.png" alt=""></p><p>第三次分割：</p><p><img src="/2018/10/04/算法课第一次作业/310.png" alt=""></p><p>第四次分割：</p><p><img src="/2018/10/04/算法课第一次作业/311.png" alt=""></p><p>最后解的形式如下图所示（右下角空）：</p><p><img src="/2018/10/04/算法课第一次作业/314.png" alt=""></p><h4 id="3、prove-the-correctness-2"><a href="#3、prove-the-correctness-2" class="headerlink" title="3、prove the correctness"></a>3、prove the correctness</h4><p>使用数学归纳法：</p><p>（1）k = 1 时, 有解</p><p><img src="/2018/10/04/算法课第一次作业/33.png" alt=""></p><p>（2）k = 2 时，有解：</p><p><img src="/2018/10/04/算法课第一次作业/34.png" alt=""></p><p>（3）设 k-1 时成立(k&gt;2)，将 2^k <em> 2^k 棋盘分割为 4 个 2^(k-1) </em> 2^(k-1) 子棋盘，如下图所示：</p><p><img src="/2018/10/04/算法课第一次作业/36.png" alt=""></p><p>特殊方格必位于 4 个较小子棋盘之一中，其余 3 个子棋盘中无特殊方格。为了将这 3 个无特殊方格的子棋盘转化为特殊盘，我们可以用一个 L 型骨牌覆盖这 3 个较小的棋盘的汇合处，如下图所示，这 3 个子棋盘上被 L 型骨牌覆盖的方格就成为该棋盘上的特殊方格，从而将原问题化为 4 个较小规模的棋盘覆盖问题。递归的使用这种分割，直至棋盘简化为 2^1x2^1 棋盘。</p><p><img src="/2018/10/04/算法课第一次作业/312.png" alt=""></p><p>综上可得，该算法正确，最终可求得想要的结果。</p><h4 id="4、the-complexity-of-this-algorithm-2"><a href="#4、the-complexity-of-this-algorithm-2" class="headerlink" title="4、the complexity of this algorithm"></a>4、the complexity of this algorithm</h4><p>算法的时间复杂度递推式如下：</p><p><img src="/2018/10/04/算法课第一次作业/43.png" alt=""></p><p>即：</p><p><img src="/2018/10/04/算法课第一次作业/44.png" alt=""></p><h3 id="七、OJ第一题（寻找第K大数）"><a href="#七、OJ第一题（寻找第K大数）" class="headerlink" title="七、OJ第一题（寻找第K大数）"></a>七、OJ第一题（寻找第K大数）</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findKthLargest</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; small, big;</span><br><span class="line">        srand(time(<span class="literal">NULL</span>));</span><br><span class="line">        <span class="keyword">int</span> pivotIndex = rand()%nums.size();</span><br><span class="line">        <span class="keyword">for</span>( <span class="keyword">int</span> i=<span class="number">0</span>; i&lt;nums.size(); i++ )&#123;</span><br><span class="line">            <span class="keyword">if</span>( i==pivotIndex )</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span>( nums[i]&gt;nums[pivotIndex] )</span><br><span class="line">                big.push_back(nums[i]);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                small.push_back(nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>( big.size() == k<span class="number">-1</span> )</span><br><span class="line">            <span class="keyword">return</span> nums[pivotIndex];</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>( big.size() &gt; k<span class="number">-1</span> )</span><br><span class="line">            <span class="keyword">return</span> findKthLargest( big, k );</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> findKthLargest( small, k-big.size()<span class="number">-1</span> );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, k;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; k;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec;</span><br><span class="line">    <span class="keyword">int</span> num;</span><br><span class="line">    <span class="keyword">for</span>( <span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; i++ )&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;num);</span><br><span class="line">        vec.push_back(num);</span><br><span class="line">    &#125;</span><br><span class="line">    Solution s;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; s.findKthLargest(vec,k) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="八、OJ第二题（二维最近点对）"><a href="#八、OJ第二题（二维最近点对）" class="headerlink" title="八、OJ第二题（二维最近点对）"></a>八、OJ第二题（二维最近点对）</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt; pair&lt;<span class="keyword">double</span>, <span class="keyword">double</span>&gt; &gt; point;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">calcDist</span><span class="params">( pair&lt;<span class="keyword">double</span>, <span class="keyword">double</span>&gt; p1, pair&lt;<span class="keyword">double</span>, <span class="keyword">double</span>&gt; p2 )</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (p1.first-p2.first)*(p1.first-p2.first) + (p1.second-p2.second)*(p1.second-p2.second);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">compare_x</span><span class="params">( pair&lt;<span class="keyword">double</span>, <span class="keyword">double</span>&gt; p1, pair&lt;<span class="keyword">double</span>,<span class="keyword">double</span>&gt; p2 )</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> p1.first&lt;p2.first;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">compare_y</span><span class="params">( pair&lt;<span class="keyword">double</span>, <span class="keyword">double</span>&gt; p1, pair&lt;<span class="keyword">double</span>,<span class="keyword">double</span>&gt; p2 )</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> p1.second&lt;p2.second;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">pair&lt; pair&lt;<span class="keyword">double</span>, <span class="keyword">double</span>&gt;, pair&lt;<span class="keyword">double</span>, <span class="keyword">double</span>&gt; &gt; solution( <span class="built_in">vector</span>&lt; pair&lt;<span class="keyword">double</span>, <span class="keyword">double</span>&gt; &gt;&amp; vec )&#123;</span><br><span class="line">    <span class="keyword">if</span>( vec.size()&lt;=<span class="number">3</span> )&#123; <span class="comment">//当点的个数小于3个时，直接暴力求解,想一下为啥是3</span></span><br><span class="line">        pair&lt; pair&lt;<span class="keyword">double</span>, <span class="keyword">double</span>&gt;, pair&lt;<span class="keyword">double</span>, <span class="keyword">double</span>&gt; &gt; ans = make_pair(vec[<span class="number">0</span>], vec[<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">if</span>( vec.size()==<span class="number">3</span> )&#123;</span><br><span class="line">            <span class="keyword">double</span> dst01 = calcDist( vec[<span class="number">0</span>], vec[<span class="number">1</span>] );</span><br><span class="line">            <span class="keyword">double</span> dst12 = calcDist( vec[<span class="number">1</span>], vec[<span class="number">2</span>] );</span><br><span class="line">            <span class="keyword">if</span>( dst01&gt;dst12 )</span><br><span class="line">                ans = make_pair(vec[<span class="number">1</span>], vec[<span class="number">2</span>]);</span><br><span class="line">            <span class="keyword">double</span> dst02 = calcDist( vec[<span class="number">0</span>], vec[<span class="number">2</span>] );</span><br><span class="line">            <span class="keyword">if</span>( calcDist(ans.first, ans.second)&gt;dst02 )</span><br><span class="line">                ans = make_pair(vec[<span class="number">0</span>], vec[<span class="number">2</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//分开,左右两部分</span></span><br><span class="line">    sort( vec.begin(), vec.end(), compare_x );  <span class="comment">//并不是使用pivot，直接分一半过去</span></span><br><span class="line">    <span class="built_in">vector</span>&lt; pair&lt;<span class="keyword">double</span>, <span class="keyword">double</span>&gt; &gt; pointLeft( vec.size()/<span class="number">2</span> );</span><br><span class="line">    copy( vec.begin(), vec.begin()+vec.size()/<span class="number">2</span>, pointLeft.begin() );</span><br><span class="line">    <span class="built_in">vector</span>&lt; pair&lt;<span class="keyword">double</span>, <span class="keyword">double</span>&gt; &gt; pointRight( vec.size() - vec.size()/<span class="number">2</span> );</span><br><span class="line">    copy( vec.begin()+vec.size()/<span class="number">2</span>, vec.end(), pointRight.begin() );</span><br><span class="line">  </span><br><span class="line">    pair&lt; pair&lt;<span class="keyword">double</span>, <span class="keyword">double</span>&gt;, pair&lt;<span class="keyword">double</span>, <span class="keyword">double</span>&gt; &gt; ansLeft = solution( pointLeft );</span><br><span class="line">    pair&lt; pair&lt;<span class="keyword">double</span>, <span class="keyword">double</span>&gt;, pair&lt;<span class="keyword">double</span>, <span class="keyword">double</span>&gt; &gt; ansRight = solution( pointRight );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">double</span> dst = calcDist(ansLeft.first, ansLeft.second);</span><br><span class="line">    pair&lt; pair&lt;<span class="keyword">double</span>, <span class="keyword">double</span>&gt;, pair&lt;<span class="keyword">double</span>, <span class="keyword">double</span>&gt; &gt; ans = ansLeft;</span><br><span class="line">    <span class="keyword">if</span>( calcDist(ansLeft.first, ansLeft.second) &gt; calcDist(ansRight.first, ansRight.second) )&#123;</span><br><span class="line">        ans = ansRight;</span><br><span class="line">        dst = calcDist(ansRight.first, ansRight.second);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//计算中间</span></span><br><span class="line">    <span class="keyword">double</span> pivot = ( pointLeft[pointLeft.size()<span class="number">-1</span>].first + pointRight[<span class="number">0</span>].first ) / <span class="number">2.0</span>;</span><br><span class="line">    <span class="built_in">vector</span>&lt; pair&lt;<span class="keyword">double</span>, <span class="keyword">double</span>&gt; &gt; pointMiddle;</span><br><span class="line">    <span class="keyword">for</span>( <span class="keyword">int</span> i=<span class="number">0</span>; i&lt;vec.size(); i++ )&#123;</span><br><span class="line">        <span class="keyword">if</span>( (pivot-vec[i].first)*(pivot-vec[i].first) &lt; dst )</span><br><span class="line">            pointMiddle.push_back( vec[i] );</span><br><span class="line">    &#125;</span><br><span class="line">    sort( pointMiddle.begin(), pointMiddle.end(), compare_y );</span><br><span class="line">    <span class="keyword">for</span>( <span class="keyword">int</span> i=<span class="number">0</span>; i&lt;pointMiddle.size(); i++ )&#123;</span><br><span class="line">        <span class="keyword">for</span>( <span class="keyword">int</span> j=<span class="number">1</span>; j&lt;=<span class="number">7</span> &amp;&amp; (i+j)&lt;pointMiddle.size(); j++ )&#123;</span><br><span class="line">            <span class="keyword">if</span>( calcDist( pointMiddle[i], pointMiddle[i+j] ) &lt; dst )&#123;</span><br><span class="line">                dst = calcDist( pointMiddle[i], pointMiddle[i+j] );</span><br><span class="line">                ans = make_pair( pointMiddle[i], pointMiddle[i+j] );</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">double</span> x, y;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span>( <span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; i++ )&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%lf %lf"</span>, &amp;x, &amp;y);</span><br><span class="line">        point.push_back( make_pair(x,y) );</span><br><span class="line">    &#125;</span><br><span class="line">    pair&lt; pair&lt;<span class="keyword">double</span>, <span class="keyword">double</span>&gt;, pair&lt;<span class="keyword">double</span>, <span class="keyword">double</span>&gt; &gt; ans;</span><br><span class="line">    ans = solution(point);</span><br><span class="line">    <span class="keyword">double</span> mindst = calcDist( ans.first, ans.second );</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%.2f\n"</span>, <span class="built_in">sqrt</span>(<span class="number">1.0</span>*mindst));</span><br><span class="line">    <span class="comment">//cout &lt;&lt; "(" &lt;&lt; ans.first.first &lt;&lt; "," &lt;&lt; ans.first.second &lt;&lt; ")" &lt;&lt; ",  (" &lt;&lt; ans.second.first &lt;&lt; "," &lt;&lt; ans.second.second &lt;&lt; ")" &lt;&lt; endl;</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;一、Divide-and-Conquer&quot;&gt;&lt;a href=&quot;#一、Divide-and-Conquer&quot; class=&quot;headerlink&quot; title=&quot;一、Divide and Conquer&quot;&gt;&lt;/a&gt;一、Divide and Conquer&lt;/h3&gt;&lt;p&gt;　　You are interested in analyzing some hard-to-obtain data from two separate databases. Each database contains n numerical values, so there are 2n values total and you may assume that no two values are the same. You’d like to determine the median of this set of 2n values, which we will define here to be the n-th　smallest value.&lt;/p&gt;
&lt;p&gt;　　However, the only way you can access these values is through queries to the databases. In a single query, you can specify a value k to one of the two databases, and the chosen database will return the kth smallest value that it contains. Since queries are expensive, you would like to compute the median using as few queries as possible.&lt;/p&gt;
&lt;p&gt;Give an algorithm that finds the median value using at most O(logn) queries.　　&lt;/p&gt;
&lt;h4 id=&quot;1、problem-solving-ideas-and-pseudo-code&quot;&gt;&lt;a href=&quot;#1、problem-solving-ideas-and-pseudo-code&quot; class=&quot;headerlink&quot; title=&quot;1、problem-solving ideas and pseudo-code&quot;&gt;&lt;/a&gt;1、problem-solving ideas and pseudo-code&lt;/h4&gt;&lt;p&gt;首先将现实问题转化一下，变成计算机算法问题，即 &lt;strong&gt;找2个有序数组的并集的中位数&lt;/strong&gt; ，&lt;a href=&quot;https://leetcode-cn.com/problems/median-of-two-sorted-arrays/description/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;LeetCode 第四题&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;(1）problem-solving ideas&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;求中位数需要根据数组长度是奇数还是偶数分别讨论，奇数长度时中位数为最中间的一个数，偶数长度时中位数为最中间的两个数的平均值，为了方便，可以实现一个比题目更一般化的函数，求A和B的第k小数的函数，那么中位数的问题很容易解决。&lt;/p&gt;
&lt;p&gt;求一个有序数组的第k个数只需要O(1)的复杂度，现在有两个数组，显然花费额外空间以O(n)时间归并然后O(1)寻找不满足题目要求。既然要求log时间复杂度，一般需要使用到二分思想。&lt;/p&gt;
&lt;p&gt;分别考虑A和B的第k/2个元素：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如果它们相等，则第k个数为其中的任意一个&lt;/li&gt;
&lt;li&gt;如果A中的比较大，则B中前k/2个元素都不可能是第k个数了，因为这个数至少应该为A的第k/2个数，把B的前k/2去掉，然后重新寻找。&lt;/li&gt;
&lt;li&gt;如果B中的比较大，则把A的前k/2个数去掉，重新寻找。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;直到A和B中某个变为空时或者寻找第1个数时可以停止递归，直接找到结果。&lt;/p&gt;
&lt;p&gt;注意，上面的k/2只是理想的简单情况，实际上A和B的长度可能不够k/2，或者k为奇数等，但这些不是主要问题，可以让A取第k/2个数字，然后A不够长，则取A的最后一个数字，然后B取剩下长度对应的那个数字，具体参考代码。&lt;/p&gt;
    
    </summary>
    
      <category term="作业" scheme="https://wangjibao.com.cn/categories/%E4%BD%9C%E4%B8%9A/"/>
    
      <category term="算法课第一次作业" scheme="https://wangjibao.com.cn/categories/%E4%BD%9C%E4%B8%9A/%E7%AE%97%E6%B3%95%E8%AF%BE%E7%AC%AC%E4%B8%80%E6%AC%A1%E4%BD%9C%E4%B8%9A/"/>
    
    
      <category term="作业" scheme="https://wangjibao.com.cn/tags/%E4%BD%9C%E4%B8%9A/"/>
    
  </entry>
  
  <entry>
    <title>矩阵求导</title>
    <link href="https://wangjibao.com.cn/2018/09/29/%E7%9F%A9%E9%98%B5%E6%B1%82%E5%AF%BC/"/>
    <id>https://wangjibao.com.cn/2018/09/29/矩阵求导/</id>
    <published>2018-09-29T09:36:07.000Z</published>
    <updated>2018-11-04T17:14:33.189Z</updated>
    
    <content type="html"><![CDATA[<p>最近上课，各种机器学习，深度学习的求导公式，直接蒙圈了，一个不错的教程文档，分享一下。</p><a id="more"></a><div class="row">    <embed src="matrix_rules.pdf" width="100%" height="550" type="application/pdf"></div>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近上课，各种机器学习，深度学习的求导公式，直接蒙圈了，一个不错的教程文档，分享一下。&lt;/p&gt;
    
    </summary>
    
      <category term="资料" scheme="https://wangjibao.com.cn/categories/%E8%B5%84%E6%96%99/"/>
    
    
      <category term="资料" scheme="https://wangjibao.com.cn/tags/%E8%B5%84%E6%96%99/"/>
    
  </entry>
  
</feed>
