<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[博客访问加速]]></title>
    <url>%2F2019%2F04%2F21%2F%E5%8D%9A%E5%AE%A2%E8%AE%BF%E9%97%AE%E5%8A%A0%E9%80%9F%2F</url>
    <content type="text"><![CDATA[博客停更了将近半年的时间，然后近期闲着打算接着写写记录下日常学习过程，其中被同学吐槽，你这访问太慢了啊，页面好大会转不出来，怎么回事？github pages国内访问的话，速度还是很慢的，想要更好的提升访问速度，得将博客迁移到国内才行，幸运的是，国内的coding.net也提供pages服务。下面，我们主要讲解如何实现个人博客的双仓库部署。 ####]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ubuntu个性美化]]></title>
    <url>%2F2019%2F04%2F20%2FUbuntu%E4%B8%AA%E6%80%A7%E7%BE%8E%E5%8C%96%2F</url>
    <content type="text"><![CDATA[1、安装VMware Tools 在VMware中安装虚拟机后，记得安装VMware Tools。在虚拟机中找到名为VMwareTools…tar.gz的压缩包（一般在media文件夹中），复制到某个文件夹中后执行：tar -xvzf VMwareTools…tar.gz进行解压。之后会看到一个 ./vmware-install.pl的执行程序，执行后安装，一路默认即可，安装完成后，重启虚拟机。 2、卸载自带软件 123dpkg --list # 查看自带已安装程序sudo apt-get --purge remove &lt;programname&gt; # 卸载程序和所有配置文件sudo apt-get remove &lt;programname&gt; # 只卸载程序 当然也可以在软件管理中进行查看已安装软件，卸载软件等操作。 3、GTK,GTK+,Qt, KDE,GNOME, Unity的区别与联系 Linux本身没有图形界面，Linux现在的图形界面系统只是Linux下的应用程序。 GTK, GTK+, Qt是图形界面开发库(GUI Toolkit)，用户可以使用这些开发库编写GUI应用。 KDE，GNOME，Unity是linux下的桌面环境(Desktop Environment)，其中KDE使用Qt开发，GNOME使用GTK+开发，Unity是基于GNOME开发的一个桌面环境。 从 Ubuntu 16.04 LTS 到Ubuntu 18.04 LTS 最显著的变化是 Unity 用户界面被替换为了GNOME 桌面环境。 4、安装美化主题 参考博客，本文用到的主题工具包下载 美化过程中涉及的两个目录：/usr/share/themes 和 /usr/share/icons。 1）安装 TweakTool 工具： 123sudo apt-get updatesudo apt-get install gnome-tweak-toolsudo apt-get install gnome-shell-extensions # 解决Tweaks中shell无法设置的问题 2）安装GTK主题，修改图标，更改桌面shell，下载网址，将主题和桌面shell放到/usr/share/themes/目录下，图标包放到/usr/share/icons/文件夹下，之后在Tweaks工具中，即可选择使用它们 效果图如下： 3）更改开机动画，下载网址 1234将下载的开机动画解压并拷贝到： usr/share/plymouth/themessudo update-alternatives --install /usr/share/plymouth/themes/default.plymouth default.plymouth /usr/share/plymouth/themes/***/***.plymouth 100sudo update-alternatives --config default.plymouth # 选择对应序号即可，*号代表当前使用sudo update-initramfs -u 4）更改登录界面的背景（也可只修改css文件中对应的图片链接即可） 12345cp 下载的登录界面.jpg /usr/share/backgrounds/# 备份自带登录css文件cp /usr/share/gnome-shell/theme/ubuntu.css /usr/share/gnome-shell/theme/ubuntu.css.bakcp 下载的并更名为ubuntu.css的文件 /usr/share/gnome-shell/theme/reboot 效果图： 4）修改桌面shell的宽度和字体等。]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ubuntu官方源和PPA源简介]]></title>
    <url>%2F2019%2F04%2F20%2FUbuntu%E5%AE%98%E6%96%B9%E6%BA%90%E5%92%8CPPA%E6%BA%90%E7%AE%80%E4%BB%8B%2F</url>
    <content type="text"><![CDATA[在ubuntu中，软件的安装主要有3种方式： 通过apt包管理工具从官方软件源安装 通过deb格式的软件包安装，以安装搜狗输入法为例： 1234下载 sogou.debsudo dpkg -i sogou.deb #出现安装不成功，需要依赖sudo apt-get install -f #安装依赖sudo dpkg -i sogou.deb 使用软件的源码手动编译安装 下面我们主要介绍第一种安装方式，即apt命令从软件源安装。软件源分为 Ubuntu官方软件源 和 PPA软件源 两种。 1）Ubuntu 官方软件源，其中包含了系统中绝大多数的软件，对应的目录为 /etc/apt/sources.list，如下所示： 一般情况下，我们会将其改成国内的镜像源，因为访问国外的资源太慢了，国内开源镜像站点汇总。 安装和卸载软件也非常的简单： 12sudo apt-get install &lt;package-name&gt; # 安装sudo apt-get remove &lt;package-name&gt; # 卸载 每当通过 install 命令去安装一个软件时，apt 包管理工具就会从系统中的/etc/apt/sources.list文件或/etc/apt/sources.list.d文件夹中去读取软件源的网址信息，查找可以包含该软件的软件源的网址，然后就从这个网址上把指定的软件给下载下来，然后由 apt 包管理工具在本地进行一些解压和安装的其他操作。 2）PPA(Personal Package Archives)个人软件包集，它出现的原因是：系统自带的源是非常有限的 ，如果通过deb直接安装其他软件的话，得不到更新和维护，所以此时PPA软件源就应运而生。它其实是一个网站，开发者们在上面建立自己的仓库，上传开发的软件供用户安装。 12sudo add-apt-repository ppa:user/ppa-name # 添加ppa软件源sudo add-apt-repository --remove ppa:user/ppa-name # 删除ppa软件源 当添加完某个ppa软件源后，会在系统的 /etc/apt/sources.list.d 目录下生成对应的源文件： 可见，此操作就是在文件里添加了一个和软件源一模一样的东西，以 notepad++ 的使用为例： 1234567# 安装sudo add-apt-repository ppa:notepadqq-team/notepadqqsudo apt-get update # 记得此时要更新一下软件源sudo apt-get install notepadqq# 卸载sudo apt-get remove notepadqqsudo add-apt-repository --remove ppa:notepadqq-team/notepadqq 3）上面两个东西，其实要实现的功能是一样的，之所以在系统中存在/etc/apt/sources.list和/etc/apt/sources.list.d两套东西，是系统为了区分官方源与第三方源，毕竟第三方源存在安全问题的可能性比较大。]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTTP抓包实战]]></title>
    <url>%2F2018%2F11%2F13%2FHTTP%E6%8A%93%E5%8C%85%E5%AE%9E%E6%88%98%2F</url>
    <content type="text"><![CDATA[开始读《HTTP抓包实战》，在这个作业满天飞的日子里，计划1周读完，本篇博文对其中的部分知识点做一下简单的记录。 1、HTTP抓包分析使用的工具不再是wireshark（研究TCP/IP协议使用），而是使用 fiddler，版本4。其实 fiddler 做HTTP数据包分析的原理就是相当于一个web代理，如下图： fiddler在中间，可以记录所用的HTTP流量。fiddler启动时，会偷偷把 Internet 选项中的代理修改为 ：127.0.0.1,端口： 8888; fiddler在关闭时，会自动在Internet选项中取消代理，这样就不会对其他程序产生影响。如下图： fiddler界面如下图，使用方法请自行百度或google. 2、在 fiddler中抓取 https 的流量，需要做如下图配置并安装证书。 像 IE，chrome等浏览器都是使用windows证书库来验证证书，但是firefox浏览器是自己维护一个证书列表，所以需要在firefox中单独安装 fiddler证书。在上图中的action选项中可以下载fiddler的根证书到桌面，firefox &gt;&gt; 工具 &gt;&gt; 选项 &gt;&gt; 隐私与安全 &gt;&gt; 证书 &gt;&gt; 查看证书 &gt;&gt; 证书机构中可以导入证书，这里，fiddler的作者开了个玩笑，证书名叫DO_NOT_TRUST_FiddlerRoot。 3、在抓包时，我们经常能看到 tunnel to的握手包，这对我们分析数据包没啥作用，可以在fiddler &gt;&gt; rules &gt;&gt; hide connects中设置其隐藏掉。 4、Win+R输入certmgr.msc查看windows证书管理库 5、https://www.wangjibao.com.cn/2018/11/13/HTTP%E6%8A%93%E5%8C%85%E5%AE%9E%E6%88%98/#more 上面是个url的例子，https协议，www.wangjibao.com.cn为域名，这里使用的是默认80端口，所以省略端口显示，后面的/2018/11/13/HTTP%E6%8A%93%E5%8C%85%E5%AE%9E%E6%88%98/代表资源的路径，后面的#号代表啥呢，其实这是个 锚点(anchor)，我们知道，当一个页面非常长的时候，我们可以在页面中根据锚点直接定位到我们需要的地方。 6、HTTP的状态码，200类是成功，300类代表重定向，400类代表客户端错误，500类错误代表服务器错误。 其中的206(Partial Content)代表的是部分内容，迅雷、HTTP下载工具就是使用206状态码来实现的断点续传。 当遇到301 或 302的响应时，浏览器会自动根据response中的重定向url重新访问资源地址。如下图（京东之前叫360buy)： 先访问www.360buy.com返回301说这个网址已经move permanently了，给了个http://www.jd.com，然后，浏览器就是访问这个网址，但是服务器说302，代表说，这次对了，但是为了安全，去访问另一个网址吧https://www.jd.com吧，接着就会发现，129号中显示了tunnel to，代表开始握手协商了。 其实，这里301或302还是有区别的，301代表旧url已经永久移除了，搜索引擎会把权重计算到新的url上。但302代表旧url还在，只是临时重定向到新url上，搜索引擎会把权重计算到旧url上。 7、常用的HTTP请求方法就是 get和post。 我们登录国科大的选课网站，在 fildder中，可以清楚的看到，用户名和密码被包含在post请求的body中，发送给了服务器。同样，如果是get请求，包含在url中?后面的字段可以在QueryString中看到对应的Name--Value字段。 8、可以在fiddler &gt;&gt; tools &gt;&gt; user-agent中修改User-Agent字段的值，如下图，再浏览某些网页时，就变成了对应的显示模式。 9、Ajax (Asynchronous Javascript And XML”: 异步 JavaScript 和 XML）,是一种在无需重新加载整个网页的情况下，能够更新部分网页的技术。 10、在 Rules &gt;&gt; Automatic Breakpoint &gt;&gt; after/before Response中可以设置拦截HTTP请求。比如，我可以设置拦击HTTP的响应，然后在raw中修改页面的title字段，点击Run to Completion发成修改后的发送。 1号包中的红色代表拦截到了，这时别忘了，之前设置的全局断点给取消掉，不然会影响其他请求的发送和接收。效果如下图： 注意：修改操作必须在raw选项框里。当然，也可以设置局部断点，bpu www.baidu.com设置只拦截百度的请求，取消拦截在页面左下角的命令框中输入bpu即可；bpafter www.baidu.com拦截响应，bpafter取消拦截响应。 11、浏览器中的缓存 如下图，浏览器想请求某个资源的时候，先检查本地缓存，如果本地缓存存在这个文件的时候，直接获取该文件的最后修改时间等信息，构造数据包发送请求（内含有If-Modified-Since字段和If-None-Match字段）给服务器，服务器根据这两个值，结合自身的Last-Modified字段和Etag字段来判断需不需要发送数据给浏览器，如果不需要（1、Request中的If-Modified-Since的时间大于或等于Resonse中的Last-Modified的时间；2、ETag值和If-None-Match相匹配，说明hash值不变文档没改变），则服务器发送 304 Response给浏览器，告诉它，直接使用缓存就行了，节省时间加快网页加载速度。 当然，我们也可以 ctrl + F5强制刷新浏览器，告诉服务器，我不使用缓存，请发送最新的数据资源给我。 其中的pragma是HTTP1.0中使用的，Cache-Control是现在HTTP1.1用的，同时存在这两个字段，完全是为了兼容。 12、URL只能使用英文字母、数字或者某些标点符号，URL Encode(URL 编码)就是把所有非英文字母、数字字符都替换成百分号（%）后加两位十六进制数。如： https://www.wangjibao.com.cn/2018/11/13/HTTP抓包实战 编码后变成了如下模式， 1https://www.wangjibao.com.cn/2018/11/13/HTTP%E6%8A%93%E5%8C%85%E5%AE%9E%E6%88%98/ 13、Fiddler提供了丰富的插件，可以在https://www.telerik.com/fiddler/add-ons中下载安装使用，如`Java Script Formatter、Gallery、WinDiff`（比较两个session的不同）等等。 14、 Fiddler中可以在线调试 JavaScript文件，使用的是AutoResponder功能，如下图，其原理就是当命中某个文件时，自动替换成我们设置的文件返回给客户端，就不去服务器索取了。 当然，不仅可以替换 JS 文件，还可以替换网页中的图片为本地我们设置的图片。 15、我们还可以直接编辑Fiddler Script来修改HTTP请求或者响应，并且不中断程序（之前介绍的设置断点的方式，会使得程序中断）。Rules &gt;&gt; Coustomize Rules中，打开Fiddler ScriptEditor来编辑CustomRules.js文件，如图： 16、HTTP的Cookie机制 因为HTTP协议是无状态的，可以通过Cookie来维持会话。登录 http://piaoweb.sstm.org.cn，可以在fiddler中看到cookie的运行机制，如下图： 浏览器把Cookie通过HTTP请求中的Header发送给服务器，同时，服务器通过HTTP响应中的Header(Set-Cookie机制)把Cookie发送给浏览器。 上图中的 HttpOnly字段是说通过JavaScript脚本无法读取到Cookie信息，可以有效防止XSS攻击。 浏览器根据服务器返回的Set-Cookie设置好本地Cookie以后，浏览器每次请求服务器的资源时，就在Header中将Cookie附加上，这样，服务器就认为浏览器是登录状态。 17、Cookie劫持攻击 这里我们使用豆瓣网为例，演示一下Cookie劫持攻击。 （1）登录豆瓣网，用Fiddler抓取登录过程产生的数据包，可以看到一个如下图中的包，里面含有我们需要的cookie。 （2）我们打开这个会话的session，可以看到用户的cookie，其中的dbcl2是和用户登录相关的。 （3）我们在该会话上右键，replay &gt;&gt; Reissue and Edit，将cookie中的此字段删除，然后Run to Completion放行，可以看到此时我们现在是非登录状态，并且跳转到了登录界面，服务器返回302。 （4）现在我们知道，这个cookie字段就是和用户登录相关的，并且已经劫持到了，那么如何利用它呢？可以利用之前提到的Fiddler Script，编写脚本，每次发送数据包的时候，自动加上这个cookie不就行了，并且这个操作不会有任何中断。 在 Fiddler Script中的OnBeforeRequest函数中添加如下代码段： 1234if(oSession.uriContains("douban.com"))&#123; var sCookie = "dbcl2=\"170842457:NW8ZWiZHFUU\""; oSession.oRequest["Cookie"] = sCookie;&#125; 再次访问豆瓣网，发现自己已经处于登录状态了。 18、HTTP基本验证 把用户名+冒号+密码用Base64编码后生成字符串，放在header中的Authorization字段中，发送给服务器。 19、手机Fiddler抓包 手机和电脑处于同一局域网中，在fiddler &gt;&gt; Tools &gt;&gt; Options &gt;&gt; Connections中将allow remote computers to connect勾选上，同时在手机的wlan设置中，将其代理设置成电脑，IP为电脑IP，端口为8888；同时，在手机的安全设置中可以安装之前下载的fiddler root根证书，这样，就可以捕获到手机的https数据包了。 20、Replay菜单的详细说明： Reissue Requests：重新发送请求，和菜单栏上的Replay按钮是一样的功能。 Reissue Unconditionally：无条件反复发送选中的请求。 Reissue and Edit：把选中的请求以原来的形式重新发送，在每个新的Session中设置断点，在请求发送给服务器之前，可以修改请求。 Reissue and Verify：重新发送请求，检查响应，如果响应和上一个请求一样，就会变成绿色。 Reissue Sequentially：选中多个Session会按顺序一个一个重新发送请求，是单线程模式。 Reissue from Composer：在Composer中编辑该请求。 Revisit in IE：在IE浏览器中用Get方法访问这个请求。 21、重放攻击，在Fiddler中，可以使用Composer编辑数据包并进行发送。 其实，重放攻击危害很大，比如说，某网站的投票或者点赞功能，当我们抓取到某个点赞的包时，我们可以重复发送这个数据包来进行刷票。再比如说，某些软件的注册，当我们抓取到某个注册请求包的时候，我们进行大量重复发送，对app造成的损失还是很大的。 解决方案：在HTTP请求中，添加时间戳stamp和数字签名sign。数字签名保证有效性，时间戳保证时效性。 22、后面的3–4个章节是使用JMeter对网站做自动化测试和压力测试的，在此略过。]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[小知识科普]]></title>
    <url>%2F2018%2F11%2F12%2F%E5%B0%8F%E7%9F%A5%E8%AF%86%E7%A7%91%E6%99%AE%2F</url>
    <content type="text"><![CDATA[本篇博文记录一下平时生活中遇到的小知识，不定期更新。 1、判断USB接口类型晚上同学过来借扩展坞，看了眼USB接口的颜色，问，这是2.0的口吗？很明显，本渣渣耗费 199大洋 采购的东东，怎么能不是 3.0 的口呢。其实凭借USB接口的颜色能够一定程度上判断接口类型，但并不一定准确。 准确的做法是：看接口的针脚数 ，USB2.0 的针脚数目是 4 个，USB3.0 的针脚数目是 9 个。如下图： 上图是本渣18年从青大毕业时，学院发的纪念U盘，4个引脚，USB2.0的接口。为啥发U盘呢，18年在青岛开上合峰会的时候正值毕业季，各种大型活动统统不让搞，往年的毕业歌会也被无情的取消，那么办晚会的钱就拿来每人发个U盘吧，反正大家都是搞计算机的，以后也用得到，话说要发好歹也发个3.0口的u盘呗，吐槽一下。不过，当时每个U盘里都拷了毕业纪念视频，还是挺走心的，这个得表扬一波。 多说一句，信息安全班里当时毕业没有毕业聚餐你敢相信！？？其实知道现在想起来，还是耿耿于怀，原因大家也都心知肚明，怎么说，无愧于心就好！ 上图是3.0 的口，9个引脚能看清不，外面 5 个，里面 4 个。想一下，为啥2.0的东西插到3.0的口也能正常使用，是不就是使用的里面那4个引脚，外面那5个是闲着的，当插入3.0的东西时，这9个引脚会全部起作用。]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[树莓派搭建智能路由器]]></title>
    <url>%2F2018%2F11%2F12%2F%E6%A0%91%E8%8E%93%E6%B4%BE%E6%90%AD%E5%BB%BA%E6%99%BA%E8%83%BD%E8%B7%AF%E7%94%B1%E5%99%A8%2F</url>
    <content type="text"><![CDATA[使用树莓派搭建一个小智能路由器，文档为当年做本科毕业设计时写的，单纯的一个环境搭建记录，放出来，喜欢玩的小伙伴说不定可以参考一下。]]></content>
      <categories>
        <category>资料</category>
      </categories>
      <tags>
        <tag>资料</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[算法课第三次作业]]></title>
    <url>%2F2018%2F11%2F12%2F%E7%AE%97%E6%B3%95%E8%AF%BE%E7%AC%AC%E4%B8%89%E6%AC%A1%E4%BD%9C%E4%B8%9A%2F</url>
    <content type="text"><![CDATA[1、书面作业懒得将 latex 转成 markdown了，直接传个PDF得了。 5、Cross the river贪心的基本思想：最重的人和最轻的人如果不超载重，就一起过河，如何超重，就最重的人自己一条船单独过河。 123456789101112131415161718192021222324252627282930313233#include &lt;bits/stdc++.h&gt;#include &lt;string&gt;#include &lt;vector&gt;#include &lt;stack&gt;#include &lt;map&gt;#include &lt;stdlib.h&gt;#include &lt;stdio.h&gt;#include &lt;algorithm&gt;using namespace std;int main()&#123; int n,l; int weight[50005]; cin &gt;&gt; n &gt;&gt; l; for( int i=0; i&lt;n; i++ )&#123; scanf("%d",weight+i); &#125; sort(weight,weight+n); int ans = 0, left = 0, right = n-1; while( left&lt;=right )&#123; ans++; if( weight[right]+weight[left] &lt;= l )&#123; left++; right--; &#125; else&#123; right--; &#125; &#125; cout &lt;&lt; ans &lt;&lt; endl; return 0;&#125; 6、Assign banana to monkeys贪心的基本思路：先按照位置排序，位于第 i 个位置的猴子就拿第 i 个位置的香蕉就好。 123456789101112131415161718192021222324252627282930313233343536#include &lt;bits/stdc++.h&gt;#include &lt;string&gt;#include &lt;vector&gt;#include &lt;stack&gt;#include &lt;map&gt;#include &lt;stdlib.h&gt;#include &lt;stdio.h&gt;#include &lt;algorithm&gt;using namespace std;int monkey[5000005];int banana[5000005];int main()&#123; int n=0; char ch; do&#123; scanf("%d",monkey+n); n++; &#125;while( (ch=getchar())!='\n' ); sort(monkey, monkey+n); n=0; do&#123; scanf("%d",banana+n); n++; &#125;while( (ch=getchar())!='\n' ); sort( banana, banana+n ); int ans = 0; for( int i=0; i&lt;n; i++ )&#123; ans = max( ans, abs(monkey[i] - banana[i]) ); &#125; cout &lt;&lt; ans &lt;&lt; endl; return 0;&#125;]]></content>
      <categories>
        <category>作业</category>
        <category>算法课第一次作业</category>
      </categories>
      <tags>
        <tag>作业</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[wireshark网络分析的艺术]]></title>
    <url>%2F2018%2F11%2F07%2Fwireshark%E7%BD%91%E7%BB%9C%E5%88%86%E6%9E%90%E7%9A%84%E8%89%BA%E6%9C%AF%2F</url>
    <content type="text"><![CDATA[1、Linux服务器在收到 SSH 访问请求时，会先查询该客户端 IP 所对应的 PTR 记录（ IP 反向解析，由 IP 地址 获得对应的DNS，常用在垃圾邮件过滤）。假如经过5秒钟还没有收到回复，就再发一次查询。如果第二次查询还是等了5秒还没回复，就彻底放弃查询。 解决方式： cat /etc/ssh/sshd_config | grep -i usedns ，如果显示 usedns yes ,将其设置成 no即可。 其中 grep是文本处理工具，同 sed、awk被称为文本处理三剑客。-i 代表忽略大小写的区别（ignore)。 2、启用 TCP SACK（ selective acknowledgement) 功能，在大量丢包时，不需要每个重传包都确认一次。可以在 ack 数据包中，告知对方哪些包我已经收到了，比如说，当前 ack = 100 ，包中的 sack 字段等于 107--120，那么可以一次性完成 100--106 号包的重传，节约时间。 3、延迟确认 当要发送一个 ack 数据包的时候，因为纯粹的ack数据包只是单纯的确认，不含有其他有用信息。启用延迟确认，当收到一个 seq时，不立即发送 ack，而是稍等一会，当本地有数据要发送时，将信息加在 ack数据包里，就一起带过去了，节省带宽。 4、数据接收方可以积累一些包才对发送方 ack 一次。 5、愚笨窗口综合症（silly window syndrome)—“小包问题“ 123456789101112纳格（Nagle)算法:if 有新数据要发送 if 数据量超过 MSS (即一个 TCP 包所能携带的最大数据量，通常为 1500-20tcp头-20ip头) 立即发送 else if 之前发出去的数据尚未确认 把新数据缓存起来，凑够 MSS 或等确认到达再发送 else 立即发送 end if end ifend if 6、延迟确认和 nagle 算法不能一起用，容易造成网络延迟大的要命 7、虽然说是 TCP 的三次握手，四次挥手，但是有时候，四次挥手，并不一定就是4个数据包，有可能是3个，即中间的 2号包的 ACK 和3号包的 FIN 结合在一起，形成一个数据包。 8、NTLM（ NT LAN Manager）,一种身份认证协议 客户端向服务器发送一个 NTLM 协商请求，然后服务器立即回复一个随机字符串作为 challenge。 客户端收到 challenge 之后，向服务器回复 用户名，以及两个 response(用hash过的用户密码对 challenge加密得到的) 服务器不知道如何验证真假，所以将 challenge 和 两个response 都转发给 域控Domain Controller ，让域控去帮忙验证真假。 域控收到后，也用 hash过的用户密码对 challenge进行加密。如果加密结果和 reponse一样，说明密码正确，身份验证通过。 由于从数据包里就能看到 challenge 和 response ，算法也是固定的，所以并不安全。 9、Kerberos（安全认证协议） 认证过程如下图，kerberos 认证是个双向的过程，即client可以验证server，server 也可以认证 client。 $\blacksquare$ 相关名词解释 KDC ( key distributed center ): 整个安全认证过程的票据生成管理服务，包括 AS 和 TGS 服务。 AS ( authentication service ): 为 client 生成TGT的服务。 TGS( ticket granting service ): 为 client 生成某个服务器的 ticket。 TGT ( ticket-granting ticket ): 用于获取 ticket 的票据。 $\blacksquare$ 认证过程 (1) client 向 KDC 中的 AS 发送数据，表明自己的身份，AS对client的身份进行验证，验证通过后返给 client一个 TGT. (2) client 拿着这个 TGT，给TGS发送数据，说我想访问某个 server。然后TGS会将会话密钥$K_{client-server}$用 client master key加密后传送给client；与此同时，TGS也会将会话密钥$K_{client-server}$连同client的基本信息打包用server master key加密也发client，并经client转发给server，至此client与KDC的交互完成。 (3) client用自己的 master key 解密 TGS 传过来的第一个包，解密后获得会话密钥$K_{client-server}$，并用这个密钥加密自己的的信息和时间戳打包后传送给server。 (4) server会收到两个数据包，一个用会话密钥加密，一个用自己的master key加密，server先用自己的masterkey解密获取会话密钥和一份关于client的信息，然后server拿到解密后获取到的会话密钥再解开另外一个数据包，获得另一份关于client的信息和时间戳，对比一下这两份数据，一样即可验证通过。 详细过程请参照：https://blog.csdn.net/yangyang19920306/article/details/51673460 10、TCP Fast Retransmission ，当发送方收到3个及以上 [TCP Dup ACK] 时，就立刻重传它。 [TCP window Full] 和 [TCP zerowindow] ，前者表示这个包的发送方暂时没办法再发送数据了（比如说接收方之前告诉我，接收窗口是100，我把100个数据发送过去了，但是都没有收到回复，可能在去的途中，所以为了保险起见，我不能再接着发送了）。后者表示这个包的发送方没办法再接收数据了（告诉对方，我的接收窗口满了，别再发了）。 11、LSO（ large segment offload） 传统的网络工作方式是这样的：应用层把产生的数据交给TCP层，TCP层再根据MSS大小进行分段（有CPU负责）,然后再交给网卡。而启用LSO之后，TCP层就可以把大于MSS的数据块直接传给网卡，让网卡来负责分段的工作。其实在数据量较大时，数据分段计算校验和等简单操作也挺浪费CPU资源的。在计算机的网卡，高级设置里可以启用这一功能，如下图： 详细说明：https://www.cnblogs.com/tcicy/p/8442225.html 12、TCP中的拥塞控制机制 了解其中的 慢开始、拥塞避免、快重传、快恢复机制。 详细说明：https://blog.csdn.net/jtracydy/article/details/52366461 13、有一种 拥塞窗口的计算方式： $ cwnd = cwnd + MSS*\frac{n \times MSS}{cwnd} $ . n 代表当前接收到的 ack 的个数，当每个数据片返回一个 ack的时候，这个算法是没问题的，即 $\frac{n \times MSS}{cwnd} = 1$ , 每次拥塞窗口增大一个，如上图中的“拥塞避免”状态。但是，我们之前说过，并不是每个数据片都会返回一个 ack 的，有可能攒了好几个才 ack 一次，所以，这种计算方法存在问题，解决方法是关掉网卡中的 Large Receive Offload。 14、前面逼逼了辣么多，真实环境抓几个包说道说道。 就拿上面截图的数据包说事吧，数据包下载链接 185.199.109.153 为服务器端，192.168.199.160 为 客户端。 (1) 通信过程详解 首先，1203号包服务器端发送了seq = 939400，len = 1460。 紧接着客户端回复 1204号包，说我已经收到了 ack = 939400+1460 = 940860号包。 正常情况下，服务器接着应该发送 seq = 940860的包给客户端，但是，在 1205号包中，客户端却收到了 seq = 942320 , len = 1460 的数据包，wireshark显示 [ TCP Previous segment not captured ]，说明前一个包（seq = 940860的数据包）可能丢了。 既然数据包丢了，客户端就得发送 ack 接着请求，所以，在1206号包中，客户端第二次要求服务器端发送 seq = 940860 的数据，wireshark显示 [ TCP Dup ACK 1204#1 ]，代表这是1204号包的再一次请求。 接着，1207号包，客户端收到了 seq = 943780，len = 1460 的数据包（ 942320 + 1460 = 943780） 。 1208号包，还没收到 seq = 940860 的数据包，客户端那个气啊，妹的，我再一次重复要求服务器重发 ack = 940860，出现了[ TCP Dup ACK 1204#2 ]. 在1209号包中，客户端收到了 seq = 946700 ， len = 1460 的数据包，现在问题比较大了，两个应该收到的数据包却没有收到，分别是 seq = 940860, seq = 945240 (1207中：943780+1460 = 945240）。同样的，wireshark显示 [ TCP Previous segment not captured ]。 接着，问题得到了改善，在1210号包中，客户端收到了本应该早收到的 seq = 945240, len = 1460 的数据包。wireshark显示 [ TCP Out-Of-Order ]，这也说明了，在真实的网络环境中，数据包并不一定是按序到达的。 客户端收到了 seq = 945240 ，seq = 946700(945240+1460) 的数据包，应该发送确认，直到此时，那个 seq = 940860 的包还是没给我发来，丫丫的，在1211号包 和 1212号包中客户端再一次发送 ack = 940860，要求服务器发送 seq = 940860号包给我，wireshark显示[ TCP Dup ACK 1204#3 ]，[TCP Dup ACK 1204#4 ]。 在下面的1213 ( seq = 946700+1460 = 948160 )、1214、1215 (seq = 948160+1460 = 949620 )、1216、1217 ( seq = 949620+1460 = 951080 )、1218号，6个数据包还是重演之前的画面，客户端收到的是后面的数据包，每收到一个包，就重复确认一次 ack = 940860, 于是出现了图中的 [ TCP Dup ACK 1204#5 ] 、 [ TCP Dup ACK 1204#6 ]、 [ TCP Dup ACK 1204#7 ] 。 最终，好现象终于出现，1219号包，服务器终于发来了盼望已久的 seq = 940860， len = 1460 。一起顺利，所有问题已经解决。由于是乱序到达的，wireshark显示 [ TCP Out-Of-Order ]。 在 1220号包中，客户端发送对 seq = 940860 的确认，因为之前已经接收到了 seq = 951080+1460 = 952540，所以此时就显示的 ack = 952540 。 接下来，一切正常。 (2) SACK字段展示 拿 1211 号数据包详细说一下之前提到的 SACK 字段。1211数据包是 ack 1209号数据包的吧。有个事实是：我本应该收到 seq = 940860 的，但是，从1205和1207号包中，我收到的是 seq = 942320, seq = 943780 ，所以此时，1211的TCP头部可选字段的 sack : 942320---945240 (943780+1460 = 955240)。从1209号数据包中我收到的是 seq = 946700，所以 1211数据包的TCP头部字段记录第二个 sack : 946700---948160 (946700+1460 = 948160) 。 在TCP的头部可选字段记录这个两个字段值，花掉了 20 字节，所以TCP的头部长度变成了 20 + 20 = 40 Bytes. 同样的，当客户端收到了 1210 号数据包的时候，是不是就把这两个字段中间空缺的那 1460 ( 946700-945240 = 1460 ) 字节给补上了。所以，在 1212号 ack 数据包中，sack : 942320---948160 ,如上图所示。 那么当之前没收到的 seq = 940860 也收到的时候，这个 sack字段就没啥意义了，直接没有了，如 1220号ack包展示的那样。到此，一切那么的完美。 sack字段在变化，同样的，ack 数据包的头部长度也在变化，如上图中： 74 &gt;&gt; 66 &gt;&gt; 54。每次 ack 都会 浪费 一定的带宽，所以，出现了下面的收到多个 seq ，客户端才 ack 一次。 (3) 之前说过，真实的环境中，并不会每个数据包都 ack 一次，如下图，在这里是每收到 2 个数据包才发送一个 ack。 15、TCP在三次握手的时候，客户端与服务器之间会协商 MSS 的大小，防止应用层发送的数据在 IP 层被分片。虽然，分片有时候是不可控的，比如数据包中间经过路由器时，也有可能被路由器分片。 协商过程如下图： 客户端说我的 MSS = 1460， 但是服务器说他的 MSS = 1370，所以，在接下来的数据包中，应用层的数据按照 MSS= 1370 的大小来传输。 16、通过如下命令构造分片的包 1ping &lt;ip&gt; -l 9000 -n 4 其中的 -l 参数指定发送的 ping 包的大小，9000 Bytes，所以会被分片处理，如下图所示。 -n指定发送的包的个数，还可以使用 -f 参数，指定发送的包不允许分片，即 DF = 1。 可以看到，分片数据包的 off 偏移字段，客户端可以根据 ID 字段，识别这是属于哪一个数据的分片包。那么，客户端如何确定什么时候开始重组这些分片的数据包？可以根据分片数据包的 MF 字段，最后一个分片包的 MF = 0 ，代表这是最后一个数据包了，后面没有数据了，这时，客户端就可以重组这些分片的数据包了。 有一种网络的攻击方式： 往客户端持续发送 MF = 1 的数据包，导致客户端一直缓存分片，导致内存耗尽。 17、TCP中避免拥塞的方式有： 接收端通过接收窗口的大小来通知发送端，告知其数据接收能力。同时，发送端 通过拥塞控制算法来动态调整自己的数据发送量。其中： 1当前数据发送量 = min( 接收窗口大小， 拥塞控制值大小 ) 18、因为TCP头中只给接收窗口预留了16个比特（因为当时设计的时候，全世界的带宽都很小）,这就意味着它最大只能表示$2^{16} - 1 = 65535$ 字节，网络发展到今天明显不够用啊。后来，想到了一个解决方案，在TCP三次握手的时候，在可选字段中告知对方一个叫 window scale 的值，对方将这个值当做 2 的指数，算出来的值再作为接收窗口的系数。有了这个系数，就可以把接收窗口扩展好多倍了。 从上图中可以看出，客户端告诉服务器，自己的 Win = 65535,放大倍数为 2 倍；接着服务器告诉客户端，自己的 Win = 13600, 放大倍数为 WS = 128 倍。 数据包详情如下图： 19、思考：一个服务器是如何使用 80 端口同时为多个客户端提供服务的？根据连接建立时创建的五元组区分。详细点可以看 多路 I/O复用 epoll。 20、在网络层，也就是IP层头部，有那么几个字段：identification、flags、offset 。因为IP层是无连接的，每产生一个数据报，identification就加 1 ，如果中途的路由器将其分片后，接收端可以根据 flags 中的 MF、DF字段以及片偏移字段，将同一个 identification 的数据报重新组装起来。 21、一种流量劫持的手段如下图所示： 实线代表真实的流量，虚线代表劫持的流量。实现的原理就是，我假的服务比你真的服务先响应客户端，这样，等到真的数据来的时候，就会被用户无情的丢弃掉了。 可以通过查看数据包中的 TTL 值，分析流量是否存在被劫持的可能性。 22、HTTP &gt;&gt; HTTP1.1 &gt;&gt; SPDY &gt;&gt; HTTP2.0 QUIC(基于UDP) 23、[ TCP zerowindow ] 表示这个包的发送方已经没有办法再接收数据了，对应包中显示 win = 0 。 [ TCP window Full ] 表示这个包的发送方暂时没有办法再发送数据了，已经把对方声称的接收窗口已经发满了确没收到ack，只能先暂停。计算在途字节数 24、书上午看完了，总得来说，作业没有在刻意的讲述知识点，通过一个个案例，真实的说明网络知识是如何应用到现实生活的，内容比较基础，对初学者来说不错的书！ 屁股后面跟着一堆作业，就这样吧。找个时间，读一下 tshark 的官方文档，感觉功能很强，用得好的话可以省很多事。https://www.wireshark.org/docs/man-pages/tshark.html 之前当当搞活动，加上双十一，买了好多书，下一本：《python黑帽子 黑客与渗透测试编程之道》。]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[VSCode配置Latex]]></title>
    <url>%2F2018%2F11%2F05%2FVSCode%E9%85%8D%E7%BD%AELatex%2F</url>
    <content type="text"><![CDATA[因为CTeX套装自带WinEdt编辑器难用、收费且不能实时编译显示pdf效果，本笔记主要记录如何在VSCode中编辑Tex文件，实现代码自动补全及实时查看文本编辑效果等功能。 1、软件下载CTEX下载地址：http://www.ctex.org/HomePage，建议下载完整版套装。 VSCode下载地址：https://code.visualstudio.com/ 2、软件配置在VSCode中安装对应的插件 更改配置文件在file &gt;&gt; preferences &gt;&gt; setting &gt;&gt; User Setting &gt;&gt; Extensions &gt;&gt; LaTex Workshop configuration &gt;&gt; active 中，打开 Edit in setting.json 文件。在文件中添加如下字段： 12345678910"latex-workshop.latex.recipes": [&#123; "name": "xelatex", "tools": ["xelatex"]&#125;, &#123; "name": "latexmk", "tools": ["latexmk"]&#125;, &#123; "name": "pdflatex -&gt; bibtex -&gt; pdflatex*2", "tools": ["pdflatex", "bibtex", "pdflatex", "pdflatex"]&#125;], 1234567891011121314151617"latex-workshop.latex.tools": [&#123; "name": "latexmk", "command": "latexmk", "args": ["-synctex=1", "-interaction=nonstopmode", "-file-line-error", "-pdf", "%DOC%"]&#125;, &#123; "name": "xelatex", "command": "xelatex", "args": ["-synctex=1", "-interaction=nonstopmode", "-file-line-error", "%DOC%"]&#125;, &#123; "name": "pdflatex", "command": "pdflatex", "args": ["-synctex=1", "-interaction=nonstopmode", "-file-line-error", "%DOC%"]&#125;, &#123; "name": "bibtex", "command": "bibtex", "args": ["%DOCFILE%"]&#125;], 1"latex-workshop.view.pdf.viewer": "tab", 1"latex-workshop.latex.clean.fileTypes": ["*.aux", "*.bbl", "*.blg", "*.idx", "*.ind", "*.lof", "*.lot", "*.out", "*.toc", "*.acn", "*.acr", "*.alg", "*.glg", "*.glo", "*.gls", "*.ist", "*.fls", "*.log", "*.fdb_latexmk"], 1"latex-workshop.latex.clean.enabled": false, 添加后的效果如下图所示： 3、开启自动保存，实时查看编辑效果在 file中将 auto saved勾选上即可。效果如下图：]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据科学导论作业]]></title>
    <url>%2F2018%2F11%2F04%2F%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E5%AF%BC%E8%AE%BA%E4%BD%9C%E4%B8%9A%2F</url>
    <content type="text"><![CDATA[第一次作业：点击下载 怎么说，对这门课就是默默告诉自己，习惯就好。默默贴个 github 地址： https://github.com/justmarkham/DAT8 第二次作业：点击下载 同样，还是贴几个github链接地址： https://github.com/lamalor/ds100/blob/182feda62685b0988f4b4afb52c85256f4ac7d92/hw6/hw6.ipynb https://github.com/Dhanush123/data100/blob/master/hw6/hw6.ipynb https://github.com/iewaij/introDataScience/blob/1eb96b44721ed6cc40761a7e3003f11a5c243cc3/legacy/material/homework/DS100%20SP17/hw5/hw5_solution.ipynb https://github.com/dovahcrow/ds100/blob/30d629246c87f2fafbf10c155545c30344be23e6/sp17/hw/hw5/hw5_solution.ipynb 1、更改juypter默认工作路径在 anaconda prompt 中执行命令： 1jupyter notebook --generate-config 即可查看 jupyter_notebook_config.py 配置文件的位置，打开配置文件 jupyter_notebook_config.py，搜索关键字 notebook_dir ，将值设置为自己想要的工作目录并取消注释即可（注意路径中不能有中文）； 然后右击 jupyter notebook 快捷方式，将属性中的 “目标” 字段的值，去掉末尾的 %USERPROFILE% ，点击 应用，确定即可。 2、jupyter使用anaconda虚拟python环境打开 anaconda prompt，激活之前创建的某个python虚拟环境，在当前虚拟环境中执行 conda install nb_conda。重启 juypter notebook 服务器即可出现想要的虚拟环境 kernal 。 3、jupyter两种工作模式及其快捷键 分为命令模式（边框蓝色) 和 编辑模式(边框绿色) 命令模式中， M 进入markdown编辑模式， Y 进入代码编辑模式 4、代码自动补全注意，下面的所有操作是在 base 环境中安装的，在其他虚拟环境中安装好像并不起作用。 安装nbextensions 12pip install jupyter_contrib_nbextensionsjupyter contrib nbextension install --user 安装nbextensions_configurator 12pip install jupyter_nbextensions_configuratorjupyter nbextensions_configurator enable --user 重启 jupyter，在弹出的主页面里，能看到增加了一个Nbextensions标签页，在这个页面里，勾选Hinterland即启用了代码自动补全。 5、pandas教程[pan(el)-da(ta)-s]1、pandas中的数据分为三种： 一维数据 Series、二维数据 DataFrame、以及三维数据 Panel。 Series相当于一个字典。 123data = np.random.randn(5) # 一维随机数index = ['a', 'b', 'c', 'd', 'e'] # 指定索引s = pd.Series(data, index) 二维数据，1. 带Series的字典 2.列表构成的字典 3.带字典的列表 12345d = &#123;'one' : pd.Series([1., 2., 3.], index=['a', 'b', 'c']),'two' : pd.Series([1., 2., 3., 4.], index=['a', 'b', 'c', 'd'])&#125; #one做列d = &#123;'one' : [1, 2, 3, 4], 'two' : [4, 3, 2, 1]&#125; #one做列d = [&#123;'a': 1, 'b': 2&#125;, &#123;'a': 5, 'b': 10, 'c': 20&#125;] #a,b,c做列df = pd.DataFrame(d) # 新建 DataFrameprint(df） 列的选择，添加与删除 ​ df[‘列名’] df.pop(‘列名’) df.insert(添加列位置索引序号, ‘添加列名’, 数值) 行的选取，列的选取，块的选取 123456789101112df.index df.columns df.values df.values df.describes() df.T df.dtypesdf.sort_index() df.sort_values()df.head() df.tail()df[行选取] df[列名] df.loc[[行选取],[列选取]]#df.iloc df.iatdf.drop(&apos;行名&apos;)df.append()df.shape df.size df.ndim df.sum(axis=1 =0 =default) df.mean() df.std()表明智函数应用：pipe() #对所有元素起作用行或列函数应用：apply() #对行或者列起作用元素函数应用：applymap() #对某一个元素起作用 python中使用 type(var) 查看变量的数据类型 6、juypter显示行号view &gt;&gt; toggle line numbers 7、juypter中matplotlib画图中文显示乱码https://blog.csdn.net/u014465934/article/details/80377470]]></content>
      <categories>
        <category>作业</category>
        <category>数据科学导论大作业</category>
      </categories>
      <tags>
        <tag>作业</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[网络数据挖掘作业]]></title>
    <url>%2F2018%2F10%2F31%2F%E7%BD%91%E7%BB%9C%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98%E4%BD%9C%E4%B8%9A%2F</url>
    <content type="text"><![CDATA[NMF(非负矩阵分解)，nature论文原文： 个人理解PPT：]]></content>
      <categories>
        <category>作业</category>
        <category>网络数据挖掘作业</category>
      </categories>
      <tags>
        <tag>作业</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[算法课第二次作业]]></title>
    <url>%2F2018%2F10%2F28%2F%E7%AE%97%E6%B3%95%E8%AF%BE%E7%AC%AC%E4%BA%8C%E6%AC%A1%E4%BD%9C%E4%B8%9A%2F</url>
    <content type="text"><![CDATA[一、Money robbing1、optimal substructure and DP equation对于第 i 家，有两种选择，抢或者不抢。如果抢第 i 家，那么最大收益为：value[i] + 抢前 i-2 家的最优收益； 如果第 i 家不抢，那么最大收益为：抢前 i-1 家的最优收益。 状态转移方程可写为：$$dp[i] = max( dp[i-1], dp[i-2]+value[i] )$$ 2、 pseudo-codeLeetCode 198题 12345678910111213141516class Solution &#123;public: int rob(vector&lt;int&gt;&amp; nums)&#123; if( nums.size()==0 ) return 0; else if( nums.size()==1 ) return nums[0]; vector&lt;int&gt; dp(nums.size(),0); dp[0] = nums[0]; dp[1] = max( nums[0], nums[1] ); for( int i=2; i&lt;nums.size(); i++ )&#123; dp[i] = max( dp[i-1], dp[i-2]+nums[i] ); &#125; return dp[nums.size()-1]; &#125;&#125;; 3、 correctness of algorithm如果暴力求解的话，每一家都有可能抢或者不抢，枚举每一种可能性，那么总的时间复杂度为 $O(2^n)$ ，且最后算出来的最优解一定是正确的。现在，我们采用动态规划思想中的 memory 数组，记录前 i-1 家的最优值，当计算第 i 家最优值时，其依赖的 OPT[i-1] 和 OPT[i-2] 已经求出，可直接计算当前最优值，故算法是正确的。 4、 complexity of algorithm代码中的 dp 数组，每个元素只计算了一遍，故算法的时间复杂度为 $ O(n) $。 注： 当房屋变成一个环的时候，也就是相当于在原有问题上添加了一个限制条件：第1家和第n家不能同时抢。那么，分别计算抢第二家到最后一家与抢第一家到倒数第二家的最大值，取两个值中更大的那个就是结果。 LeetCode 213题 123456789101112131415161718192021222324class Solution &#123;public: int rob(vector&lt;int&gt;&amp; nums) &#123; if( nums.size()==0 ) return 0; else if( nums.size()==1 ) return nums[0]; return max( func(nums, 0), func(nums, nums.size()-1 )); &#125; int func( vector&lt;int&gt; nums, int pos )&#123; nums.erase(nums.begin()+pos); if( nums.size()==0 ) return 0; else if( nums.size()==1 ) return nums[0]; vector&lt;int&gt; dp(nums.size(),0); dp[0] = nums[0]; dp[1] = max( nums[0], nums[1] ); for( int i=2; i&lt;nums.size(); i++ )&#123; dp[i] = max( dp[i-1], dp[i-2]+nums[i] ); &#125; return dp[nums.size()-1]; &#125;&#125;; 二、Node selection1、optimal substructure and DP equation对于当前根节点，有两种可能性，选取或者不选取。如果选取了当前的根节点，那么其孩子节点就不能选取，即最优值变为：root-&gt;value + 4个孙子的最优值之和； 如果当前根节点没有选取，最优值变为：两个孩子节点最优值之和。 给定任意一个根，假设我们能够得到当前根选取与不选取的最优值，结果保存在一个长度为2的数组里，array[0]代表根节点不选取，array[1]代表根节点选取，那么最优解为： 2、 pseudo-codeLeetCode 337题 1234567891011121314151617class Solution &#123;public: int rob(TreeNode* root) &#123; vector&lt;int&gt; ans = solve( root ); return max( ans[0], ans[1] ); &#125; vector&lt;int&gt; solve( TreeNode* root )&#123; vector&lt;int&gt; ans(2,0); if( !root ) return ans; vector&lt;int&gt; left_ans = solve( root-&gt;left); vector&lt;int&gt; right_ans = solve( root-&gt;right ); ans[0] = max( left_ans[0], left_ans[1] ) + max( right_ans[0], right_ans[1] ); //根节点不选 ans[1] = root-&gt;val + left_ans[0] + right_ans[0]; //选择根节点 return ans; &#125;&#125;; 3、correctness of algorithm当前节点的最优值，依赖于其儿子节点的最优值（当前节点没选，最优值等于选其左孩子节点最优值+选其右孩子节点最优值）或其孙子节点的最优值（选取了当前节点，最优值等于根节点值+其左孩子不选左根的最优值+右孩子不选右根的最优值），由此可知算法的正确性。 4、complexity of algorithm整个算法相当于一个深度优先搜索（DFS），树中的每个节点都会遍历一次，故算法的时间复杂度为$O(n)$。 三、Decoding1、optimal substructure and DP equationdp[i]表示从字符0~i的字符串包含最多的编码种数。不考虑特殊情况，该题的递推式是$dp[i]=dp[i-1]+dp[i-2]$，因为一个数字可以表示一个编码，两个数字也有可能表示一个编码，所以dp[i]应该等于0~i-1的字符串包含的最多编码种数加上0~i-2的字符串包含的最多编码种数。但是考虑到一共只有26种基础编码加上特殊情况0，所以递推式可以表示为： 2、 pseudo-codeLeetCode 91题 123456789101112131415class Solution &#123;public: int numDecodings(string s) &#123; if( s.length()==0 || s[0]=='0' ) return 0; vector&lt;int&gt; dp(s.length()+1,0); dp[0] = dp[1] = 1; for( int i=1; i&lt;s.length(); i++ )&#123; if( s[i]!='0' ) dp[i+1] += dp[i]; if( s[i-1]!='0' &amp;&amp; (s[i-1]-'0')*10+(s[i]-'0')&lt;=26 ) dp[i+1] += dp[i-1]; &#125; return dp[s.length()]; &#125;&#125;; 3、correctness of algorithm首先该问题包含最优子结构的性质，求0~n的字符串包含最多的编码种数包含了求0~n-1的字符串包含最多的编码种数或0~n-2的字符串包含最多的编码种数。其次该问题包含重叠子性质，大量子问题会重复计算，如求dp[5]需要计算dp[4]或dp[3],求dp[4]需要求dp[3]或dp[2]，因此dp[3]被重复计算。综上该问题可以用动态规划方法解且求解方程正确。 4、complexity of algorithm整个求解过程只遍历了一遍字符串，故算法时间复杂度为$O(n)$。 六、OJ第一题LIS，DP入门第一题，没啥好说的，只要想清楚为啥每次将新来的数据往 ans 数组里插入，最后出来的就一定是最长的就可以了。 123456789101112131415161718192021222324#include &lt;bits/stdc++.h&gt;using namespace std;int main()&#123; int num, T, N; int length, index; int ans[100005]; cin &gt;&gt; T; for( int t = 0; t&lt;T; t++ )&#123; cin &gt;&gt; N; length = 0; memset(ans, -1, sizeof(ans)); for( int i=0; i&lt;N; i++ )&#123; scanf("%d",&amp;num); index = lower_bound( ans, ans+length, num ) - ans; ans[index] = num; if( index==length ) length++; &#125; cout &lt;&lt; length &lt;&lt; endl; &#125; return 0;&#125; 七、OJ第二题入门级题目外加了求 K 个最优值的条件，昨晚1点多打开题目，感觉随便码一码随便A掉，于是上床 睡觉，躺床上拍脑袋理论AC。仔细一想，K个最优值的状态转移，有点问题啊，带着疑问入睡不咋舒坦，大半夜将题目发到315群，杨老师帅气得给出了解决方案，顺带嘲笑了一波数据；炸老师看了数据量也嘲讽了一波；早上起来交了一发，发现 0 ms的时候，也疯狂鄙视一波，数据真的弱得不行。 想起来当年 ycb 的誓言： 1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;bits/stdc++.h&gt;using namespace std;int m, n, k;int num;priority_queue&lt;int&gt; ans[105], cur_ans, tmp_ans;//默认大堆int main()&#123; ans[1].push(0); cin &gt;&gt; m &gt;&gt; n &gt;&gt; k; for( int i=1; i&lt;=m; i++ )&#123; for( int j=1; j&lt;=n; j++ )&#123; scanf("%d", &amp;num); while( !cur_ans.empty() )&#123; //清空cur_ans cur_ans.pop(); &#125; tmp_ans = ans[j-1]; while( !ans[j-1].empty() )&#123; cur_ans.push(ans[j-1].top()+num); ans[j-1].pop(); &#125; ans[j-1] = tmp_ans; while( !ans[j].empty() )&#123; cur_ans.push(ans[j].top()+num); ans[j].pop(); &#125; while( ans[j].size()&lt;k &amp;&amp; !cur_ans.empty() )&#123; ans[j].push(cur_ans.top()); cur_ans.pop(); &#125; &#125; &#125; cout &lt;&lt; ans[n].top(); ans[n].pop(); while( !ans[n].empty() )&#123; cout &lt;&lt; " " &lt;&lt; ans[n].top(); ans[n].pop(); &#125; return 0;&#125;]]></content>
      <categories>
        <category>作业</category>
        <category>算法课第二次作业</category>
      </categories>
      <tags>
        <tag>作业</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode21-30]]></title>
    <url>%2F2018%2F10%2F20%2FLeetCode21-30%2F</url>
    <content type="text"><![CDATA[21、合并两个有序链表两个有序链表的合并，本渣代码充分利用原有空间，没开辟新的内存存储新链。 1234567891011121314151617181920212223242526272829303132/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: ListNode* mergeTwoLists(ListNode* l1, ListNode* l2) &#123; ListNode *ans = (ListNode*)malloc(sizeof(ListNode)), *tmp = ans; ans-&gt;next = NULL; while( l1&amp;&amp;l2 )&#123; if( l1-&gt;val &gt; l2-&gt;val )&#123; tmp-&gt;next = l2; l2 = l2-&gt;next; &#125; else&#123; tmp-&gt;next = l1; l1 = l1-&gt;next; &#125; tmp = tmp-&gt;next; tmp-&gt;next = NULL; &#125; if( l1 ) tmp-&gt;next = l1; if( l2 ) tmp-&gt;next = l2; return ans-&gt;next; &#125;&#125;; 22、括号生成生成的种类数是个卡特兰数，因此 n 的值不会太大。卡特兰数在计算机中是个特别重要的数串，像：三角剖分、n个叶节点树的种类、n个数字的进出栈、括号匹配、矩阵链乘等等都有卡特兰数的应用。 卡特兰数的通项公式：$$h(n) = C_{2n}^n - C_{2n}^{n-1}$$递推公式为：$$h(n) = h(n-1)*\frac{4n-2}{n+1}$$其实，求组合数时，当 n 很大的时候，计算也是个问题，好在有 Lucas定理 可以解决这事，当然以上这些与解决本题没啥关系。 本题做法是直接递归一下即可，每次放左括号（第16行）或右括号（第17行），递归的退出条件是放了n个左括号和n个右括号（第9行），剪枝条件是放的右括号数量大于左括号数量了，明显会造成非法串，直接返回退出（第13行）。 12345678910111213141516171819class Solution &#123;public: vector&lt;string&gt; generateParenthesis(int n) &#123; vector&lt;string&gt; ans; func(ans, "", n, n); return ans; &#125; void func(vector&lt;string&gt;&amp; ans, string tmp_ans, int left, int right)&#123; if( left==0 &amp;&amp; right==0 )&#123; ans.push_back(tmp_ans); return; &#125; if( right&lt;left ) //相当于剪枝，2^n剪到katalan(n) return; if( left&gt;0 ) func( ans, tmp_ans+'(', left-1, right ); func( ans, tmp_ans+')', left, right-1 ); &#125;&#125;;]]></content>
      <categories>
        <category>LeetCode</category>
        <category>LeetCode21-30</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[背包九讲]]></title>
    <url>%2F2018%2F10%2F17%2F%E8%83%8C%E5%8C%85%E4%B9%9D%E8%AE%B2%2F</url>
    <content type="text"><![CDATA[大二入门动态规划时，最先学得就是 LCS , LIS 和各种背包问题，后来接触二维DP和各种无厘头DP（数位DP啊，插头DP啊，状压DP啊，树状DP啊等等），以我这种智商水平，听听名字就好了。最近的算法课讲到了 DP 专题，找出了之前看的 背包九讲看了看，放出来，纪念一发当年的岁月吧。]]></content>
      <categories>
        <category>资料</category>
      </categories>
      <tags>
        <tag>资料</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ubuntu中配置SS多用户模式并限制每个用户的流量]]></title>
    <url>%2F2018%2F10%2F12%2FUbuntu%E4%B8%AD%E9%85%8D%E7%BD%AESS%E5%A4%9A%E7%94%A8%E6%88%B7%E6%A8%A1%E5%BC%8F%E5%B9%B6%E9%99%90%E5%88%B6%E6%AF%8F%E4%B8%AA%E7%94%A8%E6%88%B7%E7%9A%84%E6%B5%81%E9%87%8F%2F</url>
    <content type="text"><![CDATA[1、更新软件并安装vim123sudo apt-get updatesudo apt-get upgradesudo apt-get install vim 2、更改 SSH 默认端口1234sudo vim /etc/ssh/sshd_config找到 Port 字段，将其修改为自己想要的端口值sudo service ssh restart #重启ssh服务sudo netstat -tunlp | grep ssh #查看ssh服务监听的端口 这里将ssh端口改成了22222，如下图（PS:不要问我为啥强行改22号端口，就是任性，额，其实有点其他用途，青大校友表示当年我就是靠这个强行免费使用校园网）： 3、安装shadowsocks-python版本 123sudo apt-get install python-pip#在ubuntu16.04中，可以通过pip安装pyhon版的shadowsocks，但是好像已经不维护更新了，停留在了2.8.2版本sudo pip install shadowsocks 然后创建一个 json 文件并在其中填写个人配置信息即可，比如在 /home/my_ss_config.json 中，填写如下信息： 123456789&#123;"server" : "your_server_ip", #自己服务器的IP"server_port" : 8388, #服务器端口"local_address" : "127.0.0.1", "local_port" : 1080, "password" : "yourpassword", #密码"timeout" : 300, "method" : "aes-256-cfb" #加密方式&#125; 只要更改后面带 # 号的一些字段值即可，如果想多用户的话，可以将 password 字段改成如下模式（ss使用端口值识别不同的用户）： 1234"port_password": &#123; "端口1": "密码1", "端口2": "密码2"&#125;, 一切准备就绪，接下来使用如下命令即可运行 SS 服务，实现 Cross the Great Fire Wall 。 1sudo ssserver -c /home/my_ss_config.json -d start 4、多用户模式流量统计说一下我为啥要搞这么个功能，前天，我TM大半夜的正嗨呢，突然，网断了！于是乎，打开4G，还是无法操作，这。。。。我手纸都准备好了，竟然发生这样的事？（开玩笑，哈哈，根正苗红的科研知识分子，油管看科研视频的好吧，为科研奉献全身！）收到邮件，告诉我流量用完了，呵。。。 于是乎，大家公用的情况下，私开个个人账号，每到月末的时候应急用。于是乎用到了上面讲到的多用户模式，但是这样还不行，为每个用户限制流量使用上限才能达到目的。 找了找，发现国内的某度关于这方面是真的干净，上某歌，查到可以使用 ss-bash 实现，github上有，实现的原理就是：不同的用户分配不同端口，使用iptables规则获取各端口的流量，脚本循环运行，在固定时间间隔根据iptables结果统计流量使用情况，并在流量超过限制时，添加对应端口的iptables reject规则以禁用端口。 安装shadowsocks与ss-bash之后，shadowsocks就不用做任何配置了，省去了上面的步骤，由ss-bash管理shadowsocks，包括配置的文件等等。有个缺点就是，ss-bash目前只支持python版Shadowsocks，只支持统计ipv4流量，但这问题影响不大。 执行如下指令： 12345apt-get install unzip #下载解压工具apt-get install bc #安装计算器，后面统计流量用wget https://github.com/hellofwy/ss-bash/archive/master.zip #下载软件包unzip master.zipcd ss-bash-master/ 现在就可以使用相关命令配置 SS 了，具体操作指令如下（可通过 ./ssadmin.sh 命令查看）： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253用法： 显示版本： ssadmin.sh -v|v|version 显示帮助： ssadmin.sh [-h|h|help] 启动ss: ssadmin.sh start 停止ss： ssadmin.sh stop 查看ss状态： ssadmin.sh status 重启ss： ssadmin.sh restart 软重启ss： ssadmin.sh soft_restart 在不影响现有连接的情况下重启ss服务。用于ss服务参数修改， 和手动直接修改配置文件后，重启ss服务。 添加用户： ssadmin.sh add port passwd limit port：端口号, 0&lt;port&lt;=65535 passwd：密码, 不能有空格，引号等字符 limit：流量限制，可以用K/M/G/T、KB/MB/GB/TB等（不区 分大小写）。支持小数。比如10.5G、10.5GB等。 1KB=1024 bytes，以此类推。 示例： ssadmin.sh add 3333 abcde 10.5G 显示用户流量信息： ssadmin.sh show port 显示所有用户流量信息： ssadmin.sh show 显示用户密码信息： ssadmin.sh showpw port 显示所有用户密码信息： ssadmin.sh showpw 删除用户： ssadmin.sh del port 修改用户： ssadmin.sh change port passwd limit 修改用户密码： ssadmin.sh cpw port passwd 修改用户流量限制： ssadmin.sh clim port limit 修改所有用户流量限制： ssadmin.sh change_all_limit limit 用户流量使用量置零： ssadmin.sh rused limit 所有用户流量使用量置零： ssadmin.sh reset_all_used 用户流量限制置零： ssadmin.sh rlim port 全部用户流量限制置零： ssadmin.sh reset_all_limit 显示已添加的iptables规则： ssadmin.sh lrules 添加完账户后，./ssadmin.sh start启动后，./ssadmin.sh show 即可查看每个用户的当前流量使用情况。如下图： ssadmin文件夹中的各个文件的含义如下： 123456789ssadmin.sh #管理程序，所有命令通过该程序执行sscounter.sh #流量统计程序。由ssadmin.sh自动调用执行，注意：不要手动运行该程序sshelpsslib.sh #包含一些参数配置和流量统计函数。由ssadmin.sh自动调用执行，注意：不要手动运行该程序ssmlt.json #根据用户列表和ssmlt.template生成的ssserver实际使用的配置文件ssmlt.template #ssserver的配置文件sstraffic #用户流量使用情况，包括流量限制，已用流量，剩余流量等。ssadmin.sh show 命令，显示该文件内容。ssusers #用户列表traffic.log #用户流量记录，供程序内部使用。 备注： 1、默认的流量采样间隔为5分钟，流量间隔可根据实际需求调整，但最好不要太小，比如小于10秒。可打开文件sslib.sh ，修改INTERVEL 的值，单位为秒。 2、如果shadowsocks不是使用apt-get或者pip安装，无法自动找到 ssserver 文件时，请手动指定程序的具体位置。打开文件 sslib.sh ，修改 SSSERVER 的值，比如 ssserver 的路径为 /usr/local/bin/ssserver 时，修改为: 1SSSERVER=/usr/local/bin/ssserver 5、To Do List既然身为抓包组里的一员，就要干点抓包相关的事，是不是。比如说，十分好奇为啥大家流量用得那么多呢，肯定看视频了，看啥视频了呢，奥特曼大战葫芦娃.avi ？初步打算在服务器上进行流量采样，比如万分之一的采样率，然后记录下对应账户的 DNS请求的 query 字段值，client hello中的SNI字段等。 最近比较忙（其实就是懒），回头抽空搞一发。。。嘻嘻]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode11-20]]></title>
    <url>%2F2018%2F10%2F09%2FLeetCode11-20%2F</url>
    <content type="text"><![CDATA[11、盛最多水的容器双指针，算法中一个很重要的技巧，之前的三数求和就用到了双指针的技巧。 我们在由线段长度构成的数组中使用两个指针，一个放在开始，一个置于末尾。 此外，我们会使用变量 maxArea 来持续存储到目前为止所获得的最大面积。 在每一步中，我们会找出指针所指向的两条线段形成的区域，更新 maxArea，并将指向较短线段的指针向较长线段那端移动一步。 123456789101112131415class Solution &#123;public: int maxArea(vector&lt;int&gt;&amp; height) &#123; int maxArea = 0; int frontPoint = 0, endPoint = height.size()-1; while( frontPoint&lt;endPoint )&#123; maxArea = max( maxArea, (endPoint-frontPoint)*min(height[frontPoint], height[endPoint]) ); if( height[frontPoint]&lt;height[endPoint] ) frontPoint++; else endPoint--; &#125; return maxArea; &#125;&#125;; 12、整数转罗马数字水题一个，模拟一下即可。 123456789101112131415161718192021222324252627class Solution &#123;public: string intToRoman(int num) &#123; vector&lt; pair&lt;int,string&gt; &gt; mp; mp.push_back( make_pair(1000,"M") ); mp.push_back( make_pair(900,"CM") ); mp.push_back( make_pair(500,"D") ); mp.push_back( make_pair(400,"CD") ); mp.push_back( make_pair(100,"C") ); mp.push_back( make_pair(90,"XC") ); mp.push_back( make_pair(50,"L") ); mp.push_back( make_pair(40,"XL") ); mp.push_back( make_pair(10,"X") ); mp.push_back( make_pair(9,"IX") ); mp.push_back( make_pair(5,"V") ); mp.push_back( make_pair(4,"IV") ); mp.push_back( make_pair(1,"I") ); string ans = ""; for( vector&lt; pair&lt;int,string&gt; &gt;:: iterator it = mp.begin(); it!=mp.end(); it++ )&#123; while( num&gt;=(*it).first )&#123; ans += (*it).second; num -= (*it).first; &#125; &#125; return ans; &#125;&#125;; 13、罗马数字转整数水题，直接模拟 12345678910111213141516171819202122class Solution &#123;public: int romanToInt(string s) &#123; map&lt;char, int&gt; mp; mp['I'] = 1, mp['V'] = 5, mp['X'] = 10, mp['L'] = 50; mp['C'] = 100, mp['D'] = 500, mp['M'] = 1000; vector&lt;int&gt; nums; for( int i=0; i&lt;s.length(); i++ ) nums.push_back( mp[s[i]] ); nums.push_back(0); int ans = 0; for( int i=0; i&lt;nums.size()-1; i++ )&#123; if( nums[i]&lt;nums[i+1] )&#123; ans += nums[i+1]-nums[i]; i++; &#125; else ans += nums[i]; &#125; return ans; &#125;&#125;; 14、最长公共前缀没啥好方案，直接暴力即可。暴力的方式有多种，一种像这里直接每次一个字符一个字符的得出 ans ，也可以挨个字符串直接与 ans（初值为字符串strs[0]） 比较，逐渐缩小 ans 的长度，直到最后得出结果。 12345678910111213141516171819202122class Solution &#123;public: string longestCommonPrefix(vector&lt;string&gt;&amp; strs) &#123; if( strs.size()==0 ) return ""; int lens = 0, i = 0; string ans = ""; char ch; while(1)&#123; if( strs[0].length() &gt; lens ) ch = strs[0][lens]; else return ans; for( i=1; i&lt;strs.size(); i++ )&#123; if( strs[i][lens]!=ch ) return ans; &#125; ans += ch; lens++; &#125; &#125;&#125;; 15、三数之和三数之和其实和前面的两数之和原理一样，都是使用的双指针。这里的三数，其实可以直接固定一数，然后调用前面写的两数之和的代码。唯一的一点 trick 可能就是在去重上。 12345678910111213141516171819202122232425262728293031323334353637383940class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; threeSum(vector&lt;int&gt;&amp; nums) &#123; vector&lt; vector&lt;int&gt; &gt; ans; if( nums.size()&lt;3 ) return ans; //对 nums 进行排序并去重(此处去重不合适) sort( nums.begin(), nums.end() ); //vector&lt;int&gt;:: iterator it = unique( nums.begin(), nums.end() ); //nums.erase( it, nums.end() ); for( int i=0; i&lt;nums.size()-2; i++ )&#123; if( i&gt;0 &amp;&amp; nums[i-1]==nums[i] ) continue; findTwoSum( nums, i+1, nums.size()-1, i, ans ); &#125; return ans; &#125; void findTwoSum( vector&lt;int&gt;&amp; nums, int s, int e, int target, vector&lt; vector&lt;int&gt; &gt;&amp; ans )&#123; vector&lt;int&gt; step_ans; while( s&lt;e )&#123; if( nums[s]+nums[e] == -nums[target] )&#123; step_ans.clear(); step_ans.push_back(nums[target]); step_ans.push_back(nums[s]); step_ans.push_back(nums[e]); ans.push_back(step_ans); s++; e--; while( s &lt; e &amp;&amp; nums[s]==nums[s-1] ) s++; while( e &gt; s &amp;&amp; nums[e]==nums[e+1] ) e--; &#125; else if( nums[s]+nums[e] &gt; -nums[target] ) e--; else s++; &#125; &#125;&#125;; 16、最接近的三数之和和三数之和的原理一样，排序后使用双指针遍历找最优解。 123456789101112131415161718192021class Solution &#123;public: int threeSumClosest(vector&lt;int&gt;&amp; nums, int target) &#123; sort( nums.begin(), nums.end() ); int nearest = nums[0]+nums[1]+nums[2], tmpSum; for( int i=0; i&lt;nums.size()-2; i++ )&#123; int f = i+1, e = nums.size()-1; while( f&lt;e )&#123; tmpSum = nums[f] + nums[e] + nums[i]; nearest = abs(target-nearest)&gt;abs(target-tmpSum)? tmpSum:nearest; if( tmpSum==target ) return target; else if( tmpSum &gt; target ) e--; else f++; &#125; &#125; return nearest; &#125;&#125;; 17、电话号码的字母组合一行深搜代码解决，2年没写搜索了，敲的时候好生疏。 1234567891011121314151617181920212223242526272829class Solution &#123;public: vector&lt;string&gt; letterCombinations(string digits) &#123; vector&lt;string&gt; mp,ans; string cur_ans; mp.push_back(""); mp.push_back(""); mp.push_back("abc"); mp.push_back("def"); mp.push_back("ghi"); mp.push_back("jkl"); mp.push_back("mno"); mp.push_back("pqrs"); mp.push_back("tuv"); mp.push_back("wxyz"); if( digits.length() ) digitsToString( mp, digits, ans, cur_ans ); return ans; &#125; void digitsToString( vector&lt;string&gt;&amp; mp, string digits, vector&lt;string&gt;&amp; ans, string cur_ans )&#123; if( digits.length()==0 )&#123; ans.push_back( cur_ans ); return ; &#125; for( int i=0; i&lt;mp[digits[0]-'0'].length(); i++ )&#123; digitsToString( mp, digits.substr(1), ans, cur_ans+mp[digits[0]-'0'][i] ); &#125; &#125;&#125;; 18、四数之和还是双指针操作（发现一个规律就是，前面这些和双指针操作相关的题目，一个典型的特点就是数组要先排个序），算法复杂度 $ O(n^3) $ ，其实有很多种解题方式。 第一种：双指针操作，先固定两个位置，然后 $ O(n) $ 的时间复杂度遍历剩下的元素，找解的过程中就去除可能存在的重复解，体现在代码中就是一片形式相同的while循环。 第二种：还是双指针操作，在求解的过程中，我不管解是否存在重复，一一加到ans里面，最后再进行一个去重处理。优点是编码简单，缺点是空间复杂度高，最坏情况下为$n^4$的空间复杂度（nums全为0，target也为0）。 第三种：以空间换时间，利用$ O(n^2) $的空间先求出两个数字的和，然后变成 两数之和 问题。 第四种：使用深搜操作，理论上来讲，此种方法可以求 m 数之和，时间复杂度为 $ O(n^{m-1}) $。 方案一代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; fourSum(vector&lt;int&gt;&amp; nums, int target) &#123; vector&lt; vector&lt;int&gt; &gt; ans; if( nums.size()&lt;4 ) return ans; sort( nums.begin(), nums.end() ); for( int i=0; i&lt;nums.size()-3; i++ )&#123; for( int j=i+1; j&lt;nums.size()-2; j++ )&#123; int f = j+1, e = nums.size()-1; while( f&lt;e )&#123; int sum = nums[i]+nums[j]+nums[f]+nums[e]; if( sum==target )&#123; vector&lt;int&gt; tmp_ans; tmp_ans.push_back(nums[i]); tmp_ans.push_back(nums[j]); tmp_ans.push_back(nums[f]); tmp_ans.push_back(nums[e]); ans.push_back( tmp_ans ); f++; while( f&lt;e &amp;&amp; nums[f-1]==nums[f] )&#123; f++; &#125; e--; while( e&gt;f &amp;&amp; nums[e+1]==nums[e] )&#123; e--; &#125; &#125; else if( sum&gt;target )&#123; e--; while( e&gt;f &amp;&amp; nums[e+1]==nums[e] )&#123; e--; &#125; &#125; else&#123; f++; while( f&lt;e &amp;&amp; nums[f-1]==nums[f] )&#123; f++; &#125; &#125; &#125; while( j+1&lt;nums.size()-2 &amp;&amp; nums[j+1]==nums[j] )&#123; j++; &#125; &#125; while( i+1&lt;nums.size()-3 &amp;&amp; nums[i+1]==nums[i] )&#123; i++; &#125; &#125; return ans; &#125;&#125;; 19、删除链表的倒数第N个节点一遍遍历即可，其实也是双指针的思想. 123456789101112131415161718192021222324/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: ListNode* removeNthFromEnd(ListNode* head, int n) &#123; ListNode *dummy = (ListNode*)malloc(sizeof(ListNode)); dummy-&gt;next = head; ListNode *f = dummy, *e = dummy; for( int i=1; i&lt;=n; i++ ) e = e-&gt;next; while( e-&gt;next )&#123; f = f-&gt;next; e = e-&gt;next; &#125; f-&gt;next = f-&gt;next-&gt;next; return dummy-&gt;next; &#125;&#125;; 20、有效的括号水题，使用栈匹配一下即可，遇到左括号进栈，遇见右括号出栈，最后判断栈是否为空。 123456789101112131415161718class Solution &#123;public: bool isValid(string s) &#123; stack&lt;char&gt; ans; ans.push('#'); //加栈底后期就不用判断空不空了 for( int i=0; i&lt;s.length(); i++ )&#123; if( s[i]=='(' || s[i]=='[' || s[i]=='&#123;' ) ans.push(s[i]); else&#123; if( (s[i]==')'&amp;&amp;ans.top()!='(') || (s[i]==']'&amp;&amp;ans.top()!='[') || (s[i]=='&#125;'&amp;&amp;ans.top()!='&#123;') ) return false; else ans.pop(); &#125; &#125; return ans.top()=='#'; &#125;&#125;;]]></content>
      <categories>
        <category>LeetCode</category>
        <category>LeetCode11-20</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[colab免费云GPU使用教程]]></title>
    <url>%2F2018%2F10%2F04%2Fcolab%E5%85%8D%E8%B4%B9%E4%BA%91GPU%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[谷歌coLab免费云GPU搭建教程网上教程的链接知乎 https://zhuanlan.zhihu.com/p/34436045 cnblogs http://www.cnblogs.com/kid551/p/8544908.html 注意第11步的代码替换成下列的代码： 12345678910111213141516!apt-get install -y -qq software-properties-common python-software-properties module-init-tools#!add-apt-repository -y ppa:alessandro-strada/ppa 2&gt;&amp;1 &gt; /dev/null#!apt-get update -qq 2&gt;&amp;1 &gt; /dev/null#!apt-get -y install -qq google-drive-ocamlfuse fuse!wget https://launchpad.net/~alessandro-strada/+archive/ubuntu/google-drive-ocamlfuse-beta/+build/15331130/+files/google-drive-ocamlfuse_0.7.0-0ubuntu1_amd64.deb!dpkg -i google-drive-ocamlfuse_0.7.0-0ubuntu1_amd64.deb!apt-get install -f!apt-get -y install -qq fusefrom google.colab import authauth.authenticate_user()from oauth2client.client import GoogleCredentialscreds = GoogleCredentials.get_application_default()import getpass!google-drive-ocamlfuse -headless -id=&#123;creds.client_id&#125; -secret=&#123;creds.client_secret&#125; &lt; /dev/null 2&gt;&amp;1 | grep URLvcode = getpass.getpass()!echo &#123;vcode&#125; | google-drive-ocamlfuse -headless -id=&#123;creds.client_id&#125; -secret=&#123;creds.client_secret&#125; 会报错，由于 dpkg -i 安装时依赖的原因，但是由于使用了 install -f，安装会成功的。 接着使用 google-drive-ocamlfuse 将云盘文件夹和远程的VM链接起来，方便文件共享操作。 12!mkdir -p drive!google-drive-ocamlfuse drive 路径： \content\drive... 取消挂载 1fusermount -u ***]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ubuntu16.04安装Tensorflow-GPU]]></title>
    <url>%2F2018%2F10%2F04%2FUbuntu16-04%E5%AE%89%E8%A3%85Tensorflow-GPU%2F</url>
    <content type="text"><![CDATA[一、Ubuntu安装及TensorFlow-Gpu安装1、UEFI启动的ubuntu要将 \boot分区设置成 EFI分区，这样会在bios中出现启动项。注意EFI模式只识别FAT32的U盘启动盘。 2、安装 搜狗输入法 12345下载 sogou.debsudo dpkg -i sogou.deb #出现安装不成功，需要依赖sudo apt-get install -f #安装依赖sudo dpkg -i sogou.deb然后在设置里按照自己的需求设置 3、设置息屏时间 4、注意一定要安装好对应的显卡版本，在 设置 &gt;&gt; 软件和更新 &gt;&gt; 附加驱动里进行选择对应的显卡驱动nvidia；命令 nvidia-smi查看GPU驱动信息。 5、安装更新 sudo apt-get update sudo apt-get install vim 6、安装 及卸载Anaconda 官网下载对应的安装包，执行命令 bash Anaconda2-4.4.0-Linux-x86_64.sh 即可进行安装，期间会选择安装路径啥的，默认即可。 安装完成后，重启 命令窗口，执行 python 命令即可看到已经安装成功。如果不成功，执行 source ~/.bashrc命令，使 bashrc生效。 卸载的话： 删除整个anaconda的目录 rm -rf anaconda* 将 ~/.bashrc文件中的关于 anaconda的行注释掉 生效 source ~/.bashrc 7、命令 anaconda-navigator进入图形界面的操作。其实主要还是命令行操作，下面是 conda的常用命令。注意 conda是python的环境管理工具，兼具包管理；pip只是python的包管理工具而已。 8、conda常用命令： 12345678910111213141516171819202122232425262728293031323334353637conda --help #查看帮助conda update conda #升级condaconda update anaconda #升级anacondaconda --version 或者 conda -V #查看conda的版本conda info --envs #查看本地已创建的python运行环境，带*号的代表当前环境#创建python运行环境conda create --name &lt;env_name&gt; python=2.7/3.5/3.6#列出当前环境下所有活跃的包conda list#安装Python包conda install --name &lt;env_name&gt; &lt;package_name&gt;=version或者直接 activate 进入对应的环境中执行conda install &lt;package_name&gt;#更新python包conda update --name &lt;env_name&gt; &lt;package_name&gt;或者进入对应的环境执行conda update &lt;package_name&gt;#更新所有的包conda update --all#移除整个环境或者环境中的包conda remove --name &lt;env_name&gt; &lt;package_name&gt; #进去到对应的环境就可以不指定&lt;env_name&gt;conda remove --name &lt;env_name&gt; --all #将环境的包全部移除，相当于移除环境#查找包conda search --full-name &lt;package_name&gt; #精确查找conda search *&lt;package_name&gt;* #模糊查找#退出当前环境source deactivate &lt;env_name&gt;#激活当前环境source activate &lt;env_name&gt;#删除condarm -rf ~/anaconda 9、安装 tensorflow-gpu 使用conda创建一个python环境，并激活进入，在保证nvidia显卡驱动正常的情况下，在该环境只执行： 1conda install tensorflow-gpu=1.8/1.0/1.10/1.11 #我用的是1.9 此命令会自动帮你安装对应版本的 cudaToolKit， cupTi ， cuDNN SDK等等，十分强大，再也不用自己照着傻逼CSDN配置各种东西了。 10、查看 cuda 和 cuDNN版本 1234#cuda 版本 （9.0）cat /usr/local/cuda/version.txt#cudnn 版本 （7.3）cat /usr/local/cuda/include/cudnn.h | grep CUDNN_MAJOR -A 2 二、ubuntu安装pycharm1、去官网下载对应的 community版本，免费。 2、tar -xvzf **进行解压到当前文件夹中； 或者直接 extract提取 3、进入到对应的 bin 文件夹，执行命令 sh ./pycharm.sh进行安装 4、 设置桌面图标 1sudo gedit /usr/share/applications/pycharm.desktop 123456789[Desktop Entry]Type=ApplicationName=PycharmGenericName=Pycharm3Comment=Pycharm3:The Python IDEExec=&quot;/home/snakeson/developer/pycharm-community-2017.2.3/bin/pycharm.sh&quot; %f #注意替换Icon=/home/snakeson/developer/pycharm-community-2017.2.3/bin/pycharm.png #注意替换 Terminal=pycharmCategories=Pycharm; 1sudo chmod +x /usr/share/applications/pycharm.desktop #添加执行权限 1将/usr/share/applications/pycharm.desktop文件拷贝到桌面，双击即可运行。 5、卸载pycharm 所有的配置都保存在解压的目录中，所以卸载只要sudo rm -r **文件夹 默认会在 home目录创建一个 隐藏目录 sudo rm -r ~/.pycharm* 删除之前创建的 pycharm.desktop文件，这样，所有的东西就全卸载干净了。 6、之前使用 conda 创建的所有的python环境，在pycharm中都可以使用。既可以在创建项目的时候指定已存在的解释环境，也可以后期在设置中更改interpreter`选项。 7、pycharm中设置鼠标滚轮调节字体大小 在设置中 keymap ，搜索increase decrease 字段即可设置 鼠标快捷键 8、pycharm设置 菜单栏 字体及大小 在设置里 override default fonts by（not recommended)中修改。 9、自动生成新建Py文件的模板 file &gt;&gt; setting &gt;&gt; editor &gt;&gt; file and code templates中，选择python script文件，添加如下代码： 12345# _*_ coding: utf-8 _*_"""@author: spring371327@time: $&#123;DATE&#125; $&#123;TIME&#125;"""]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[算法课第一次作业]]></title>
    <url>%2F2018%2F10%2F04%2F%E7%AE%97%E6%B3%95%E8%AF%BE%E7%AC%AC%E4%B8%80%E6%AC%A1%E4%BD%9C%E4%B8%9A%2F</url>
    <content type="text"><![CDATA[一、Divide and Conquer You are interested in analyzing some hard-to-obtain data from two separate databases. Each database contains n numerical values, so there are 2n values total and you may assume that no two values are the same. You’d like to determine the median of this set of 2n values, which we will define here to be the n-th smallest value. However, the only way you can access these values is through queries to the databases. In a single query, you can specify a value k to one of the two databases, and the chosen database will return the kth smallest value that it contains. Since queries are expensive, you would like to compute the median using as few queries as possible. Give an algorithm that finds the median value using at most O(logn) queries. 1、problem-solving ideas and pseudo-code首先将现实问题转化一下，变成计算机算法问题，即 找2个有序数组的并集的中位数 ，LeetCode 第四题。 (1）problem-solving ideas 求中位数需要根据数组长度是奇数还是偶数分别讨论，奇数长度时中位数为最中间的一个数，偶数长度时中位数为最中间的两个数的平均值，为了方便，可以实现一个比题目更一般化的函数，求A和B的第k小数的函数，那么中位数的问题很容易解决。 求一个有序数组的第k个数只需要O(1)的复杂度，现在有两个数组，显然花费额外空间以O(n)时间归并然后O(1)寻找不满足题目要求。既然要求log时间复杂度，一般需要使用到二分思想。 分别考虑A和B的第k/2个元素： 如果它们相等，则第k个数为其中的任意一个 如果A中的比较大，则B中前k/2个元素都不可能是第k个数了，因为这个数至少应该为A的第k/2个数，把B的前k/2去掉，然后重新寻找。 如果B中的比较大，则把A的前k/2个数去掉，重新寻找。 直到A和B中某个变为空时或者寻找第1个数时可以停止递归，直接找到结果。 注意，上面的k/2只是理想的简单情况，实际上A和B的长度可能不够k/2，或者k为奇数等，但这些不是主要问题，可以让A取第k/2个数字，然后A不够长，则取A的最后一个数字，然后B取剩下长度对应的那个数字，具体参考代码。 (2）pseudo code 12345678910111213141516171819202122232425double findMedianSortedArrays(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2) &#123; int totalLength = nums1.size() + nums2.size(); if( totalLength&amp;1 ) return findKth( nums1.begin(), nums1.size(), nums2.begin(), nums2.size(), (totalLength&gt;&gt;1)+1 ); else //除以 2.0 是为了保留小数点 return (findKth( nums1.begin(), nums1.size(), nums2.begin(), nums2.size(), (totalLength&gt;&gt;1) ) + findKth( nums1.begin(), nums1.size(), nums2.begin(), nums2.size(), (totalLength&gt;&gt;1)+1 ))/2.0;&#125;int findKth( vector&lt;int&gt;:: iterator nums1, int len1, vector&lt;int&gt;:: iterator nums2, int len2, int k )&#123; // 默认 len1 要大于 len2 if( len1&lt;len2 ) return findKth( nums2, len2, nums1, len1, k ); if( len2==0 ) return nums1[k-1]; if( k==1 ) //k==1做特判，因为后期要移位, 不做特判point-1会出现负值 return min( nums1[0], nums2[0] ); int point2 = min( k&gt;&gt;1, len2 ); int point1 = k - point2; //下面对 nums1[point1-1] 和 nums2[point2-1]的大小关系进行讨论 if( nums1[point1-1] &gt; nums2[point2-1] ) return findKth( nums1, point1, nums2+point2, len2-point2, k-point2 ); else if( nums1[point1-1] &lt; nums2[point2-1] ) return findKth( nums1+point1, len1-point1, nums2, point2, k-point1 ); else return nums1[point1-1]; &#125; 2、subproblem reduction graph 3、prove the correctness寻找两个有序数组的第K大数，那么肯定是第1个数组贡献 a 个数，第二个数组贡献 K - a 个数。首先我们假设每个数组分别贡献 K/2个数，讨论 A[k/2] 和 B[k/2] 的大小情况。 当 A[k/2] &gt; B[K/2] 时，很显然需要减少数组A贡献的数字的个数，增加数组B贡献的数组的个数，如下图： 当 A[k/2] &lt; B[K/2] 时，很显然需要增加数组A贡献的数字的个数，减少数组B贡献的数组的个数，如下图： 随着算法的执行，搜索的数组长度不断缩小，最后一定会返回对应的中位数值。 4、the complexity of this algorithm分析可得： 五、Divide and Conquer Recall the problem of ﬁnding the number of inversions. As in the course, we are given a sequence of n numbers a1,··· ,an, which we assume are all distinct, and we deﬁne an inversion to be a pair i &lt; j such that ai &gt; aj. We motivated the problem of counting inversions as a good measure of how diﬀerent two orderings are. However, one might feel that this measure is too sensitive. Let’s call a pair a significant inversion if i &lt; j and ai &gt; 3aj. Given an O(nlogn) algorithm to count the number of signiﬁcant inversions between two orderings. 1、problem-solving ideas and pseudo-code(1）problem-solving ideas 求数列的逆序数，除了暴力求解方式外，也可以使用归并排序、树状数组、线段树等结构进行计算。此处选择使用归并排序。 首先，将数组从中间切开，分为左右两半，A[0…n/2] 和 A [n/2+1…n]，分别计算这两个子问题的显著逆序数； 然后，计算跨左右两边的数对所形成的显著逆序的个数。 最后，将这三者的显著逆序数求和，即为整个数组的显著逆序数。 (2）pseudo code 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455//统计变量num为全局变量void mergesort(int begin, int end)&#123; if (begin &gt;= end) return; int mid = (begin + end) / 2; mergesort(begin, mid); mergesort(mid + 1, end); mcount(begin, mid, end); merge(begin, mid, end);&#125;void mcount(int begin, int mid, int end)&#123; int i = begin; int j = mid + 1; int k = begin; while (i &lt;= mid &amp;&amp; j &lt;= end)&#123; if (a[i] &gt; 2 * a[j])&#123; num += mid - i + 1; j++; &#125; else i++; &#125;&#125; void merge(int begin, int mid, int end)&#123; int i = begin; int j = mid + 1; int k = begin; while (i &lt;= mid &amp;&amp; j &lt;= end)&#123; if (a[i] &gt; a[j])&#123; temp[k] = a[j]; k++; j++; &#125; else&#123; temp[k] = a[i]; k++; i++; &#125; &#125; while (i &lt;= mid)&#123; temp[k] = a[i]; k++; i++; &#125; while (j &lt;= end)&#123; temp[k] = a[j]; k++; j++; &#125; for (int p = begin; p &lt;= end; p++) a[p] = temp[p];&#125; 2、subproblem reduction graph先分： 后合： 3、prove the correctness其中，计算左右两边的显著逆序数的时候，会同时将左右两边的子数组变成有序。在计算跨两边的数对所形成的显著逆序的时候，就不用进行暴力遍历，只需O(n)的遍历即可。当 L[i] &gt; 3*R[j] 时，RC += |L|-i 即可，L中位于下标 i 之后的数字就不用遍历了，自然要比 3*R[j] 大。同时，计算过程是基于归并排序的，整个算法即正确。 4、the complexity of this algorithm计算左边的时间复杂度为 T(n/2)， 计算右边的时间复杂度为 T(n/2)， 合并的时间复杂度为 O(n)，所以总的时间复杂度为： 六、Divide and ConquerGiven a table M consisting of 2n ∗ 2n blocks, we want to ﬁll it with a L-shaped module (consisting of three blocks). The L-shaped module is shown below. Please give a ﬁll method, so that the last element of the table (M2n,2n) is empty. For example: 1、problem-solving ideas and pseudo-code(1）problem-solving ideas 有一个特殊方格的棋盘覆盖问题，只不过，此题目将特殊方格定死了，只能为最右下角那个，即 P(size-1,size-1)那个小方格。 该题关键在于如何划分各L型骨牌所在位置区域。我们发现，L型骨牌占三个方格，我们可以把棋盘从中央分为四块，那么这四块子棋盘中仅一块是有特殊方格的，可以用一块骨牌使得其他三块子棋盘均被覆盖。以此为原则，无论这种分法是否最终可解，我们首先保证了每个子棋盘都有一个特殊方格，所以，分治的模型就出来了。 我们可以用递归来完成分治的任务。每次递归，chess_board(int posx,int posy,int x,int y,int size)，(posx,posy)为子棋盘左上角坐标,size为子棋盘大小，因为棋盘总为正方形，所以size为边长，那么这3个参数就确定了子棋盘的位置和大小；(x,y)表示子棋盘中特殊方格的位置，这个位置是由上层递归分配骨牌后决定的。以此为标准，递归流程为： ①判断边界，若当前棋盘大小为1，则无法再分割，递归结束。 ②定子棋盘中心位置。 ③判断特殊方格所在位置（左上，右上，左下，或右下）。 ④根据特殊方格位置确定所选L型骨牌，原特殊方格和三个L型骨牌的方格分别为四个子棋盘的特殊方格。 ⑤依据④中判断，按编号填充棋盘。 ⑥4次递归，分别对应四个子棋盘。 (2）pseudo code 12345678910111213141516171819202122232425262728293031323334353637void chess_board(int posx,int posy,int x,int y,int size)&#123; if( size==1 ) return ; size /= 2; int num = Count++; //左上角 if( posx+size&gt;x &amp;&amp; posy+size&gt;y ) chess_board(posx,posy,x,y,size); else&#123; board[posx+size-1][posy+size-1] = num; chess_board(posx,posy,posx+size-1,posy+size-1,size); &#125; //右上角 if( y&gt;=posy+size &amp;&amp; x&lt;posx+size ) chess_board(posx,posy+size,x,y,size); else&#123; board[posx+size-1][posy+size] = num; chess_board(posx,posy+size,posx+size-1,posy+size,size); &#125; //左下角 if( x&gt;=posx+size &amp;&amp; y&lt;posy+size ) chess_board(posx+size,posy,x,y,size); else&#123; board[posx+size][posy+size-1] = num; chess_board(posx+size,posy,posx+size,posy+size-1,size); &#125; //右下角 if( x&gt;=posx+size &amp;&amp; y&gt;=posy+size ) chess_board(posx+size,posy+size,x,y,size); else&#123; board[posx+size][posy+size] = num; chess_board(posx+size,posy+size,posx+size,posy+size,size); &#125;&#125; 2、subproblem reduction graph假设有如下图的一个棋盘，棋盘中有一个特殊方格： 第一次分割： 第二次分割： 第三次分割： 第四次分割： 最后解的形式如下图所示（右下角空）： 3、prove the correctness使用数学归纳法： （1）k = 1 时, 有解 （2）k = 2 时，有解： （3）设 k-1 时成立(k&gt;2)，将 2^k 2^k 棋盘分割为 4 个 2^(k-1) 2^(k-1) 子棋盘，如下图所示： 特殊方格必位于 4 个较小子棋盘之一中，其余 3 个子棋盘中无特殊方格。为了将这 3 个无特殊方格的子棋盘转化为特殊盘，我们可以用一个 L 型骨牌覆盖这 3 个较小的棋盘的汇合处，如下图所示，这 3 个子棋盘上被 L 型骨牌覆盖的方格就成为该棋盘上的特殊方格，从而将原问题化为 4 个较小规模的棋盘覆盖问题。递归的使用这种分割，直至棋盘简化为 2^1x2^1 棋盘。 综上可得，该算法正确，最终可求得想要的结果。 4、the complexity of this algorithm算法的时间复杂度递推式如下： 即： 七、OJ第一题（寻找第K大数）12345678910111213141516171819202122232425262728293031323334353637383940#include &lt;bits/stdc++.h&gt;using namespace std;class Solution &#123;public: int findKthLargest(vector&lt;int&gt;&amp; nums, int k) &#123; vector&lt;int&gt; small, big; srand(time(NULL)); int pivotIndex = rand()%nums.size(); for( int i=0; i&lt;nums.size(); i++ )&#123; if( i==pivotIndex ) continue; if( nums[i]&gt;nums[pivotIndex] ) big.push_back(nums[i]); else small.push_back(nums[i]); &#125; if( big.size() == k-1 ) return nums[pivotIndex]; else if( big.size() &gt; k-1 ) return findKthLargest( big, k ); else return findKthLargest( small, k-big.size()-1 ); &#125;&#125;;int main()&#123; int n, k; cin &gt;&gt; n &gt;&gt; k; vector&lt;int&gt; vec; int num; for( int i=0; i&lt;n; i++ )&#123; scanf("%d", &amp;num); vec.push_back(num); &#125; Solution s; cout &lt;&lt; s.findKthLargest(vec,k) &lt;&lt; endl; return 0;&#125; 八、OJ第二题（二维最近点对）12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182#include &lt;bits/stdc++.h&gt;using namespace std;vector&lt; pair&lt;double, double&gt; &gt; point;double calcDist( pair&lt;double, double&gt; p1, pair&lt;double, double&gt; p2 )&#123; return (p1.first-p2.first)*(p1.first-p2.first) + (p1.second-p2.second)*(p1.second-p2.second);&#125;bool compare_x( pair&lt;double, double&gt; p1, pair&lt;double,double&gt; p2 )&#123; return p1.first&lt;p2.first;&#125;bool compare_y( pair&lt;double, double&gt; p1, pair&lt;double,double&gt; p2 )&#123; return p1.second&lt;p2.second;&#125;pair&lt; pair&lt;double, double&gt;, pair&lt;double, double&gt; &gt; solution( vector&lt; pair&lt;double, double&gt; &gt;&amp; vec )&#123; if( vec.size()&lt;=3 )&#123; //当点的个数小于3个时，直接暴力求解,想一下为啥是3 pair&lt; pair&lt;double, double&gt;, pair&lt;double, double&gt; &gt; ans = make_pair(vec[0], vec[1]); if( vec.size()==3 )&#123; double dst01 = calcDist( vec[0], vec[1] ); double dst12 = calcDist( vec[1], vec[2] ); if( dst01&gt;dst12 ) ans = make_pair(vec[1], vec[2]); double dst02 = calcDist( vec[0], vec[2] ); if( calcDist(ans.first, ans.second)&gt;dst02 ) ans = make_pair(vec[0], vec[2]); &#125; return ans; &#125; //分开,左右两部分 sort( vec.begin(), vec.end(), compare_x ); //并不是使用pivot，直接分一半过去 vector&lt; pair&lt;double, double&gt; &gt; pointLeft( vec.size()/2 ); copy( vec.begin(), vec.begin()+vec.size()/2, pointLeft.begin() ); vector&lt; pair&lt;double, double&gt; &gt; pointRight( vec.size() - vec.size()/2 ); copy( vec.begin()+vec.size()/2, vec.end(), pointRight.begin() ); pair&lt; pair&lt;double, double&gt;, pair&lt;double, double&gt; &gt; ansLeft = solution( pointLeft ); pair&lt; pair&lt;double, double&gt;, pair&lt;double, double&gt; &gt; ansRight = solution( pointRight ); double dst = calcDist(ansLeft.first, ansLeft.second); pair&lt; pair&lt;double, double&gt;, pair&lt;double, double&gt; &gt; ans = ansLeft; if( calcDist(ansLeft.first, ansLeft.second) &gt; calcDist(ansRight.first, ansRight.second) )&#123; ans = ansRight; dst = calcDist(ansRight.first, ansRight.second); &#125; //计算中间 double pivot = ( pointLeft[pointLeft.size()-1].first + pointRight[0].first ) / 2.0; vector&lt; pair&lt;double, double&gt; &gt; pointMiddle; for( int i=0; i&lt;vec.size(); i++ )&#123; if( (pivot-vec[i].first)*(pivot-vec[i].first) &lt; dst ) pointMiddle.push_back( vec[i] ); &#125; sort( pointMiddle.begin(), pointMiddle.end(), compare_y ); for( int i=0; i&lt;pointMiddle.size(); i++ )&#123; for( int j=1; j&lt;=7 &amp;&amp; (i+j)&lt;pointMiddle.size(); j++ )&#123; if( calcDist( pointMiddle[i], pointMiddle[i+j] ) &lt; dst )&#123; dst = calcDist( pointMiddle[i], pointMiddle[i+j] ); ans = make_pair( pointMiddle[i], pointMiddle[i+j] ); &#125; &#125; &#125; return ans;&#125;int main()&#123; int n; double x, y; cin &gt;&gt; n; for( int i=0; i&lt;n; i++ )&#123; scanf("%lf %lf", &amp;x, &amp;y); point.push_back( make_pair(x,y) ); &#125; pair&lt; pair&lt;double, double&gt;, pair&lt;double, double&gt; &gt; ans; ans = solution(point); double mindst = calcDist( ans.first, ans.second ); printf("%.2f\n", sqrt(1.0*mindst)); //cout &lt;&lt; "(" &lt;&lt; ans.first.first &lt;&lt; "," &lt;&lt; ans.first.second &lt;&lt; ")" &lt;&lt; ", (" &lt;&lt; ans.second.first &lt;&lt; "," &lt;&lt; ans.second.second &lt;&lt; ")" &lt;&lt; endl; return 0;&#125;]]></content>
      <categories>
        <category>作业</category>
        <category>算法课第一次作业</category>
      </categories>
      <tags>
        <tag>作业</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[矩阵求导]]></title>
    <url>%2F2018%2F09%2F29%2F%E7%9F%A9%E9%98%B5%E6%B1%82%E5%AF%BC%2F</url>
    <content type="text"><![CDATA[最近上课，各种机器学习，深度学习的求导公式，直接蒙圈了，一个不错的教程文档，分享一下。]]></content>
      <categories>
        <category>资料</category>
      </categories>
      <tags>
        <tag>资料</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode1-10]]></title>
    <url>%2F2018%2F09%2F28%2FLeetCode1-10%2F</url>
    <content type="text"><![CDATA[1、两数之和123456789101112131415161718class Solution &#123;public: vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; nums, int target) &#123; unordered_map&lt;int, int&gt; Map; vector&lt;int&gt; ans; for(int i=0; i&lt;nums.size(); i++) Map[nums[i]] = i; for(int i=0; i&lt;nums.size(); i++)&#123; int tmp = target - nums[i]; if( Map.count(tmp) &amp;&amp; Map[tmp]!=i )&#123; ans.push_back(i); ans.push_back(Map[tmp]); break; &#125; &#125; return ans; &#125;&#125;; 2、两数相加1234567891011121314151617181920212223242526272829303132/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) &#123; ListNode* res = new ListNode(0); ListNode* tmp = res; int sum = 0; while( l1 || l2 )&#123; if( l1 )&#123; sum += l1-&gt;val; l1 = l1-&gt;next; &#125; if( l2 )&#123; sum += l2-&gt;val; l2 = l2-&gt;next; &#125; tmp-&gt;next = new ListNode(sum%10); tmp = tmp-&gt;next; sum /= 10; &#125; if( sum ) tmp-&gt;next = new ListNode(sum); return res-&gt;next; //解决的很是巧妙 &#125;&#125;; 3、无重复字符的最长子串1234567891011121314151617181920class Solution &#123;public: int lengthOfLongestSubstring(string s) &#123; int ans = 0; int i, j; map&lt;char, int&gt; mp; for( i=0,j=0; j&lt;s.length(); j++ )&#123; if( mp.count(s[j]) == 0 )&#123; //map中之前不含有此元素 mp.insert(make_pair( s[j], j )); &#125; else&#123; //map中之前含有此元素 ans = max( ans, j-i ); i = max( mp[s[j]]+1, i ); mp[s[j]] = j; &#125; &#125; ans = max( ans, j-i ); //到字符串的结尾了，需要处理 return ans; &#125;&#125;; 4、两个排序数组的中位数12345678910111213141516171819202122232425262728class Solution &#123;public: double findMedianSortedArrays(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2) &#123; int totalLength = nums1.size() + nums2.size(); if( totalLength&amp;1 ) return findKth( nums1.begin(), nums1.size(), nums2.begin(), nums2.size(), (totalLength&gt;&gt;1)+1 ); else //除以 2.0 是为了保留小数点 return (findKth( nums1.begin(), nums1.size(), nums2.begin(), nums2.size(), (totalLength&gt;&gt;1) ) + findKth( nums1.begin(), nums1.size(), nums2.begin(), nums2.size(), (totalLength&gt;&gt;1)+1 ))/2.0; &#125; int findKth( vector&lt;int&gt;:: iterator nums1, int len1, vector&lt;int&gt;:: iterator nums2, int len2, int k )&#123; // 默认 len1 要大于 len2 if( len1&lt;len2 ) return findKth( nums2, len2, nums1, len1, k ); if( len2==0 ) return nums1[k-1]; if( k==1 ) //k==1做特判，因为后期要移位, 不做特判point-1会出现负值 return min( nums1[0], nums2[0] ); int point2 = min( k&gt;&gt;1, len2 ); int point1 = k - point2; //下面对 nums1[point1-1] 和 nums2[point2-1]的大小关系进行讨论 if( nums1[point1-1] &gt; nums2[point2-1] ) return findKth( nums1, point1, nums2+point2, len2-point2, k-point2 ); else if( nums1[point1-1] &lt; nums2[point2-1] ) return findKth( nums1+point1, len1-point1, nums2, point2, k-point1 ); else return nums1[point1-1]; &#125;&#125;; 5、最长回文子串Manacher算法，国内也叫“马拉车”。虽然 RL[i]=min(RL[2*pos-i], MaxRight-i)，但是位于 i 半径右边界与 MaxRight之间的元素是不会被重复遍历的，否则会与 i 的对称 j 起冲突，也正因为如此，算法的复杂度是 O(n)。 12345678910111213141516171819202122232425262728293031323334353637class Solution &#123;public: string longestPalindrome(string s) &#123; string newString = "#"; for( int i=0; i&lt;s.length(); i++ )&#123; newString += s[i]; newString += "#"; &#125; int maxLen = 0, maxLenIndex = 0; int maxRight=0, pos=0; //代表当前最右及其对应中心元的位置 int radius[newString.length()]; for( int i=0; i&lt;newString.length(); i++ )&#123; if( i&lt;maxRight ) radius[i] = min( radius[2*pos-i], maxRight-i+1 ); //注意这里的 +1 else radius[i] = 1; while( (i+radius[i])&lt;newString.length() &amp;&amp; (i-radius[i])&gt;=0 &amp;&amp; newString[i+radius[i]]==newString[i-radius[i]] )&#123; // i+radius[i]-1为当前所到位置 radius[i] += 1; &#125; //更新 maxRight 和 pos if( (i+radius[i]-1)&gt;maxRight )&#123; maxRight = i+radius[i]-1; pos = i; &#125; if( maxLen&lt;radius[i] )&#123; maxLen = radius[i]; maxLenIndex = i; &#125; &#125; string ansString = ""; for( int i=maxLenIndex-radius[maxLenIndex]+1; i&lt;maxLenIndex+radius[maxLenIndex]-1; i++ )&#123; if( newString[i]!='#' ) ansString += newString[i]; &#125; return ansString; &#125;&#125;; 6、Z字形变换规律题，多些几个即可找到下标间的规律。 123456789101112131415161718192021222324252627282930class Solution &#123;public: string convert(string s, int numRows) &#123; if( numRows==1 ) return s; string ans = ""; int total = 2*numRows - 2; int curNum, pos; pos = 0; do&#123; ans += s[pos]; pos += total; &#125;while( pos&lt;s.length() ); for( int i=1; i&lt;numRows-1; i++ )&#123; curNum = total - 2*i; pos = i; do&#123; ans += s[pos]; pos += curNum; curNum = total - curNum; &#125;while( pos&lt;s.length() ); &#125; pos = numRows - 1; do&#123; ans += s[pos]; pos += total; &#125;while( pos&lt;s.length() ); return ans; &#125;&#125;; 7、反转整数12345678910111213141516class Solution &#123;public: int reverse(int x) &#123; long long int num = 0; int flag = x&lt;0? -1:1; x = abs(x); do&#123; num = 10*num + x%10; x /= 10; &#125;while(x); num = num*flag; if( num&gt;INT_MAX || num&lt;INT_MIN ) num = 0; return int(num); &#125;&#125;; 8、字符串转整数 (atoi)一个简单的模拟题，但不得不说leetcode的测试用例真的是强，考虑了 -1 ，给我报 +1的错，两者都考虑了，报了 -+1 的错，真的每一个可能但错误的细节都考虑到了，强！ 12345678910111213141516171819202122232425262728293031323334class Solution &#123;public: int myAtoi(string str) &#123; //先将开始的空余字符去掉 for( int index=0; index&lt;str.length(); index++ )&#123; if( str[index]!=' ' )&#123; str = str.substr(index); break; &#125; &#125; int flag = 1; if( str[0]=='-' )&#123; flag = -1; str = str.substr(1); &#125; else if( str[0]=='+' )&#123; flag = 1; str = str.substr(1); &#125; long long num = 0; for( int i=0; i&lt;str.length(); i++ )&#123; if( str[i]&gt;='0' &amp;&amp; str[i]&lt;='9' )&#123; num = num*10 + (str[i]-'0'); if( flag*num &lt; INT_MIN ) return INT_MIN; else if( flag*num &gt; INT_MAX ) return INT_MAX; &#125; else break; &#125; return flag*num; &#125;&#125;; 9、回文数将数字倒过来，比较前后两个数是否相同即可。 123456789101112class Solution &#123;public: bool isPalindrome(int x) &#123; if( x&lt;0 ) return false; int y = 0, tmp_x = x; while( tmp_x )&#123; y = 10*y+(tmp_x%10); tmp_x /= 10; &#125; return x==y; &#125;&#125;; 10、正则表达式匹配动态规划的思想来解决这道题目，对于动态规划类的题目，是比较难的，难在状态转移方程写不出来。 首先，dp[i][j]表示 s 中前 i 个字符和 p 中的前 j 个字符是否匹配。下面对 p 中的第 j 个字符是否是 * 号进行分类讨论（至于为啥是以*号为关键字符进行讨论，自己想想，脑补脑补）。 1、 p[j-1] != &#39;*&#39;： 只需要比较 s[i-1] 和 p[j-1] 是否匹配即可，匹配的条件为 s[i-1]==p[j-1] || p[j-1]==&#39;.&#39;，转移方程为： dp[i][j] = dp[i-1][j-1] &amp;&amp; (s[i-1]==p[j-1] || p[j-1]==&#39;.&#39;) 2、p[j-1] == &#39;*&#39;，分3类情况讨论： p[j-1] 的 * 号不起作用，也就是没匹配，此情况下 p[j-2] 和 p[j-1]是作废的，转移方程: dp[i][j] = dp[i][j-2] p[j-1] 的 * 号匹配一个字符，也就是 P 中的 p[j-2] 和 p[j-1] 所组成的元素和 S 中的 s[i-1]相匹配，所以状态转移方程为： dp[i][j] = dp[i-1][j-2] &amp;&amp; (s[i-1]==p[j-2] || p[j-2]==&#39;.&#39;) p[j-1] 的 * 号匹配多个字符(&gt;=2)，如下图所示，很容易写出状态转移方程为： dp[i][j] =dp[i-1][j] &amp;&amp; (s[i-1]==p[j-2] || p[j-2]==&#39;.&#39;) 综上所述，总状态转移方程为： 接下来，对初始状态进行讨论： 当 S 不空， P 为空时，dp[i][0] = false 当 S 空， P 不空时： j%2!=0 时，dp[0][j] = false j%2==0 时， dp[0][j] = dp[0][j-2] &amp;&amp; p[j-1]==&#39;*&#39; 有了以上的分析，代码基本也就写完了，如下： 123456789101112131415161718192021222324252627class Solution &#123;public: bool isMatch(string s, string p) &#123; int m = s.length(), n = p.length(); bool dp[m+1][n+1]; dp[0][0] = true; //都为空，肯定匹配 // P为空 for( int i=1; i&lt;=m; i++ ) dp[i][0] = false; // S为空 for( int j=1; j&lt;=n; j++ )&#123; if( j%2==0 ) dp[0][j] = ( dp[0][j-2] &amp;&amp; (p[j-1]=='*') ); else dp[0][j] = false; &#125; for( int i=1; i&lt;=m; i++ )&#123; for( int j=1; j&lt;=n; j++ )&#123; if( p[j-1]!='*' ) dp[i][j] = dp[i-1][j-1] &amp;&amp; ( s[i-1]==p[j-1] || p[j-1]=='.' ); else dp[i][j] = dp[i][j-2] || ( ( dp[i-1][j-2] || dp[i-1][j] ) &amp;&amp; (s[i-1]==p[j-2] || p[j-2]=='.')); &#125; &#125; return dp[m][n]; &#125;&#125;;]]></content>
      <categories>
        <category>LeetCode</category>
        <category>LeetCode1-10</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[GitHub Pages+Hexo+Next博客搭建记录]]></title>
    <url>%2F2018%2F09%2F22%2FGitHub-Pages-Hexo-Next%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E8%AE%B0%E5%BD%95%2F</url>
    <content type="text"><![CDATA[1、前言 大二的时候看见学长搭建的个人博客，感觉好高大上的样子，想着自己啥时候不再是哪个只会喊：哇、牛批、666、厉害厉害的傻逼选手，然后浪啊浪，突然有一天，CSP考试上考到了一个Markdown转HTML的大模拟题：现场狂写2小时，黑箱测试最后只得20分，从此心理对MD留下了挥之不去的阴影，然后就没有了然后，此事不来了了之。大二的时候在CSDN上写过，但是感觉CSDN的广告是越来也严重了，上面，下面，左面，右面等等四面八方全是各种广告，于是乎，时隔三年，趁着中秋没钱出去浪啊，舍友也回家了，丧尸宿舍也搭建一个简单的个人博客吧，此文简单记录一下搭建过程。本文使用的是 Github pages + Hexo + Next 主题。 2、基础环境搭建2.1 注册GitHub账号并创建IO仓库 GitHub作为全球最大的同性交友网站，在程序员心中的地位不亚与PornHub在宅男心中的地位，有过之而无不及啊，登录官网填写相关信息进行账号注册，然后创建一个和注册名相同的仓库(Repository)，注意一定要是下图这种格式[username.github.io]，因为github page每个账号只有一个。 现在，已经可以通过https://wangjibao.github.io/来访问了，后面还会在这上面做更多的设置。 2.2 安装node.js Hexo是基于Node.js的，其实Node.js就是一个JavaScript的运行环境，用来生成我们所写的静态博客页面，去官网下载安装即可，并且会自动加入系统环境变量中。 其中的 npm(Node Package Manager) 是随 node.js 一起安装的包管理工具，能解决NodeJS代码部署上的很多问题。常用命令如下: 123456npm install npm -g #安装新版本的npmnpm install #安装npm依赖包npm install &lt;Mouble Name&gt; #安装包，分为全局安装和本地安装，全局安装添加 -g 参数npm uninstall &lt;Mouble Name&gt; #卸载包npm update &lt;Mouble Name&gt; #更新包npm list -g #列出所有的全局安装包 2.3 安装Ｇit并配置SSH Key Git是一个流行的版本控制工具，使用它和GitHub进行交互。前往Git官网下载安装到本地即可。 因为你要提交代码到GitHub必须得拥有权限，但是直接使用用户名+密码不安全，所以使用 SSH Key来解决本地和服务器的连接问题。 在Git Bash中执行： cd ~/.ssh ，检查本机存在的ssh秘钥。如果提示： No such file or directory 说明你是第一次使用git。 ssh-keygen -t rsa -C &quot;17600****26@163.com&quot; 按照提示操作，最终会在用户目录下生成一个id_rsa.pub文件，这就是自己的公钥。复制里面的字符串到自己的GitHub中，settings &gt;&gt; SSH and GPG keys &gt;&gt; New SSH Key。 执行如下命令，测试是否添加成功： `ssh -T git@github.com` 同时在git bash中进行如下配置: 12git config --global user.name &quot;wangjibao&quot; #github用户名git config --global user.email &quot;17600****26@163.com #github注册邮箱 2.4 安装sublime Sublime Text3，很方便快捷的代码编辑器，后期的很多文件修改编辑操作要借助此工具进行。官网下载安装的软件本身是付费的，但我大天朝能用付费的软件，呵，开玩笑！百度一发好多激活码直接用。 2.5 安装hexo 在某个目录下建一个文件夹，此文件夹作为hexo的工作区。在该文件夹中 Git Bash Here，执行如下命令安装hexo： npm install -g hexo 安装完成后，hexo -v 查看安装版本及是否安装成功。执行 hexo init，对此工作文件夹进行初始化（特别注意，此文件夹初始必须是空的，否则会报错）。完成后，将生成如下目录结构的文件树 其中_config.yml是全局配置文件，_posts是放置博客文章的文件夹，具体各文件功能查看这里。此时，我们执行 hexo server来启动Hexo服务，在浏览器中输入 http://localhost:4000查看初始效果。 常用的 Hexo命令如下： 1234567hexo -v #查看版本信息hexo new &quot;tilte&quot; #创建新文章，放在\source\_posts目录下hexo new page *** #创建页面hexo generate #用来生成静态文件，简写： hexo ghexo server #开启服务器实现本地预览功能，简写： hexo shexo deploy #部署网址，上传到github仓库，简写： hexo dhexo clean #清除缓存(db.json)和已生成的静态文件(public),例如在更换博客主题后执行该命令 2.6 域名购买及解析 前往阿里云购买属于自己的域名，当然，不买也是可以的，直接使用 wangjibao.github.io也能访问博客，只是为了博客更加个性化一点，遂购买一个属于自己的域名。购买完成后，前往域名解析页面设置域名解析，如下图： 其中第二行的IP地址是在cmd命令框中通过 ping wangjibao.github.io 命令得到。同时，在github pages的设置页面，填写购买的域名。 最后，在source文件夹中新建名为 CNAME的文件，在文件中填入www.wangjibao.com.cn；执行 hexo g -d命令，此时，即可通过在浏览器中的地址栏输入 www.wangjibao.com.cn 进行博客的浏览。 2.7 本地与Github连接 之前已经配置好了SSH Key，此时只要修改一下_config.yml文件即可轻松实现本地博文发布。修改_config.yml如下： 其中repository的值在下图中获得，注意，此处每个字段的冒号后面都跟有一个空格，否则会出错。 在发布博文前，执行如下命令安装必要的插件： npm install hexo-deployer-git --save 2.8 配置NexT主题NexT的官方说明文档，将各基础配置讲述得非常清楚，按照官方文档一步一步配置即可。包括： 安装NexT 下载主题 启用主题 验证主题 主题设定 选择Scheme（此处选用Gemini主题） 设置语言（zh-Hans） 设置菜单 设置侧栏 设置头像 设置作者昵称 设置站点描述 设置RSS（hexo install hexo-generator-feed --save） 添加标签页面 添加分类页面 设置字体 设置代码高亮主题（night eighties） 侧边栏社交链接 开启打赏功能 设置友情链接 腾讯公益404页面 此处官网提供的是 http模式的404页面，在https模式下蹦出的404页面会出现排版问题，如firefox会报 Mixed Active Content警告，如图： 两种解决方案，一种是关掉浏览器对此站点的保护功能，但却不是很实用，因为你不能要求所有人解除对你站点的保护。 第二种解决方案是，将官网提供的404页面的代码做一下修改，具体如下： 12345678910111213&lt;!DOCTYPE HTML&gt;&lt;html&gt;&lt;head&gt; &lt;meta http-equiv="content-type" content="text/html;charset=utf-8;"/&gt; &lt;meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" /&gt; &lt;meta name="robots" content="all" /&gt; &lt;meta name="robots" content="index,follow"/&gt;&lt;/head&gt;&lt;body&gt; &lt;script type="text/javascript" src="//qzonestyle.gtimg.cn/qzone/hybrid/app/404/search_children.js" homePageName="返回主页" homePageUrl="https://ymwangzhuan.com"&gt; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 可以看到，改版后的404页面的src字段并没有指明使用的是http协议还是https协议，会自动根据你的站点做适配，问题完美解决[注意将404.html放到站点根目录的source文件夹中]。 站点建立时间 订阅微信公众号 设置背景动画 3、NexT主题个性化设计3.1 设置网站图标 Favicon在网上找一张32*32大小的 ico 图标，当然，不是 ico 格式也是可以的，如 png 等。将图标放到目录 \thems\next\source\imges 文件夹中，然后修改主题配置文件即可，操作如下图： 作为抓包组中的一员，搭建的博客必须上 wireshark 图标啊，皮一波~~，效果如下图： 3.2 修改文章底部 # 号标签样式在 \themes\next\layout\_macro\post.swing 文件中搜索 rel=&quot;tag&quot;&gt;# ，将 # 号替换成 &lt;i class=&quot;fa fa-tag&quot;&gt;&lt;/i&gt;，如下图： 3.3 文章末尾添加 本文结束 标记添加本文结束标记的步骤，其实也是主题编写的基本步骤，主要分3步： 添加模板文件 在目录 themes\next\layout\_macro中新建名为 passage-end-tag.swig的文件，并添加如下代码： 1234567&lt;div&gt; &#123;% if not is_index %&#125; &lt;div style="text-align:center;color: #ccc;font-size:14px;"&gt; -------------本文结束&lt;i class="fa fa-paw"&gt;&lt;/i&gt;感谢您的阅读------------ &lt;/div&gt; &#123;% endif %&#125; &lt;/div&gt; 导入模板文件 在文件 themes\next\layout\_macro\post.swig中找到如下代码块（第332行）: 123&#123;#####################&#125;&#123;### END POST BODY ###&#125;&#123;#####################&#125; 在此代码块的上面添加如下代码： 12345&lt;div&gt; &#123;% if not is_index %&#125; &#123;% include 'passage-end-tag.swig' %&#125; &#123;% endif %&#125;&lt;/div&gt; 配置 在主题配置文件中添加 passage-end-tag 字段，并设置为 true ： 123# 文章末尾添加“本文结束”标记passage_end_tag: enabled: true 最终效果为： 3.4 添加顶部加载条在next主题的配置文件 _config.yml 中搜索关键词 pace ，设置为 true ，还可以设置加载条的样式，修改如下图所示： 3.5 隐藏网站底部 由hexo强力驱动方案一：在目录 themes\next\layout\_partials\中打开 footer.swig文件，将对应网站底部的描述部分给注释掉即可，html的注释符 &lt;!-- **** --&gt;： 方案二：在主题配置文件中，配置 powred字段和theme字段，将其用 #号注释掉： 两者都能实现下图所示的效果： 3.6 博文置顶使用 top 属性， top 值越大，排序就越靠前，如果文章不设置 top 属性，就按照博文的推送时间排序。如果使用的next主题在5.1之后，会自带此功能，修改站点配置文件中的 order_by字段即可；如果使用的是更老的版本，修改node_modules\hexo-generator-index\lib\generator.js中的内容即可，在var posts =那一行的后面添加如下博文排序函数： 12345678910111213posts.data = posts.data.sort(function(a, b) &#123; if(a.top &amp;&amp; b.top) &#123; // 两篇文章top都有定义 if(a.top == b.top) return b.date - a.date; // 若top值一样则按照文章日期降序排 else return b.top - a.top; // 否则按照top值降序排 &#125; else if(a.top &amp;&amp; !b.top) &#123; // 以下是只有一篇文章top有定义，那么将有top的排在前面（这里用异或操作居然不行233） return -1; &#125; else if(!a.top &amp;&amp; b.top) &#123; return 1; &#125; else return b.date - a.date; // 都没定义按照文章日期降序排&#125;); 这里我们使用第二种方案，每次写文章的时候，都要手动添加 top 属性，很麻烦，这里，我们可以修改 scaffolds\post.md 文件，修改后的内容如下，其实相当于创建了一个博文的初始模板。 到此，如果文章设置了 top 属性并有值得话，根据 top 值排序，没有的话，按照博文的推送时间排序。 3.7 添加分享NexT主题支持多种方式的分享，包括 Baidu Share 、duoshuo_share、needMoreShare2、jiathis等等，这里我们使用needMoreShare2，在主题配置文件中修改对应的字段如下图所示，资深抓包民工表示对这里的很多软件好熟悉~，怕是要被打~ 修改后，执行 hexo g -d指令，效果如图： 3.8 显示当前页面的浏览进度在主题配置文件中 ctrl+f 搜索 scrollpercent，将 false 改为 true。如果想把 top按钮放在侧边栏，可以把 b2t字段设置为true ，实现效果如图所示： 3.9 首页博文自动卷起在首页显示一篇文章的部分内容，并提供一个链接跳转到全文页面是一个常见的需求。NexT 提供三种方式来控制文章在首页的显示方式。也就是说，在首页显示文章的摘录并显示 阅读全文 按钮，可以通过以下方法： 在文章中使用 &lt;!-- more --&gt; 手动进行截断，Hexo 提供的方式 在文章的 front-matter中添加 description，并提供文章摘录 自动形成摘要，在主题配置文件中将 auto_excerpt设置成 true ，并自行设定自动截取长度（默认150） 这里，我们使用第一种方式，实现效果如下图： 3.10 实现鼠标点击出现桃心将 love.js文件添加到主题目录的\source\js\src 下，找到 \themes\next\layout\_layout.swig文件， 在文件的后面， &lt;/body&gt;标签之前 添加以下代码： 12&lt;!-- 页面点击小红心 --&gt;&lt;script type="text/javascript" src="/js/src/love.js"&gt;&lt;/script&gt; 实现效果为每次鼠标点击页面的时候，会出现一个彩色的桃心，如下图所示： 3.11 添加站内搜索NexT主题支持多种搜索插件，我们这里使用 hexo-generator-searchdb插件，原理是在本地生成一个search.xml文件，搜索的时候从这个文件中根据关键字检索出相应的链接。首先执行 npm install hexo-generatordb --save 指令进行插件的安装，之后将下面的代码复制进站点配置文件的末尾。 12345search: path: search.xml field: post format: html limit: 10000 然后将主题配置文件中的对应字段设置为 true 即可。 最终，会在网站的侧栏出现搜索 选项，搜索效果如下图所示： 3.12 生成站点地图站点地图是一种文件，可以通过该文件列出网站上的网页，从而可以将个人网站内容的组织架构告知 baidu、google等搜索引擎。搜索引擎的网页爬取工具会读取此文件，以便更加高效的爬取个人网站。 1、先安装对应的插件，以下两个插件对应的是 baidu 和 google 12npm install hexo-generator-sitemap --savenpm install hexo-generator-baidu-sitemap --save 2、在站点配置文件中添加如下代码： 12345# auto create sitemapsitemap: path: sitemap.xmlbaidusitemap: path: baidusitemap.xml 运行指令 hexo g -d ，在public目录下会发现生成了 sitemap.xml 和 baidusitemap.xml 两个文件，这表示成功了。接下来就是如何操作让百度、谷歌收录我们的博客了。 3、站点收录，由于并没有想被搜索引擎检索的需求，私下里自己先玩一玩，所以，此项，To Do…. 3.13 实现统计功能在Hexo的根目录下执行 npm install hexo-wordcount --save 指令，进行字数统计模块的安装，然后修改主题配置文件，将对应的开关打开，即 false 改为true。 使用 sublime打开文件 \themes\next\layout\_macro\post.swig ，ctrl+f搜索如下代码字段，并在后面添加字、分钟。 123456&lt;span title="&#123;&#123; __('post.wordcount') &#125;&#125;"&gt; &#123;&#123; wordcount(post.content) &#125;&#125; 字&lt;/span&gt;&lt;span title="&#123;&#123; __('post.min2read') &#125;&#125;"&gt; &#123;&#123; min2read(post.content) &#125;&#125; 分钟&lt;/span&gt; 最终的效果图，如下： 3.14 上传本地图片在站点配置文件中将 post_asset_folder字段设置为 true，同时安装对应的插件 npm install hexo-asset-image --save。以后运行hexo n &quot;xxxx&quot;来生成md博文时，/source/_posts文件夹内除了xxxx.md文件还有一个同名的文件夹，该文件夹用于存储本地图片。在xxxx.md中想引入图片时，先把图片复制到xxxx这个文件夹中，然后只需要在xxxx.md中按照markdown的格式引入图片：![你想输入的替代文字](xxxx\图片名.jpg) 3.15 添加近期文章模块将下面的代码贴在 next/layout/_macro/sidebar.swig 中的 if theme.links 对应的 endif 后面，就ok了，是不是很简单。 1234567891011121314151617&#123;% if theme.recent_posts %&#125; &lt;div class=&quot;links-of-blogroll motion-element &#123;&#123; &quot;links-of-blogroll-&quot; + theme.recent_posts_layout &#125;&#125;&quot;&gt; &lt;div class=&quot;links-of-blogroll-title&quot;&gt; &lt;!-- modify icon to fire by szw --&gt; &lt;i class=&quot;fa fa-history fa-&#123;&#123; theme.recent_posts_icon | lower &#125;&#125;&quot; aria-hidden=&quot;true&quot;&gt;&lt;/i&gt; &#123;&#123; theme.recent_posts_title &#125;&#125; &lt;/div&gt; &lt;ul class=&quot;links-of-blogroll-list&quot;&gt; &#123;% set posts = site.posts.sort(&apos;-date&apos;) %&#125; &#123;% for post in posts.slice(&apos;0&apos;, &apos;5&apos;) %&#125; &lt;li&gt; &lt;a href=&quot;&#123;&#123; url_for(post.path) &#125;&#125;&quot; title=&quot;&#123;&#123; post.title &#125;&#125;&quot; target=&quot;_blank&quot;&gt;&#123;&#123; post.title &#125;&#125;&lt;/a&gt; &lt;/li&gt; &#123;% endfor %&#125; &lt;/ul&gt; &lt;/div&gt;&#123;% endif %&#125; 为了配置方便，在主题的 _config.yml 中添加了几个变量，如下： 123recent_posts_title: 近期文章recent_posts_layout: blockrecent_posts: true 3.16 右上角加fork me on github点击这里或者这里挑选你喜欢的样式，修改成你的GitHub链接，复制到themes/next/layout/_layout.swig文件中的以下位置： 123&lt;div class="&#123;&#123; container_class &#125;&#125; &#123;% block page_class %&#125;&#123;% endblock %&#125;"&gt; &lt;div class="headband"&gt;&lt;/div&gt; &lt;a href="https://github.com/wangjibao" ......&lt;/a&gt; 3.17 添加 latex 数学公式支持在 next 主题中，已经自动支持 mathjax 了，只需要在配置文件中将开关打开即可，不用像很多博客说的换markdown渲染引擎，更改markdown和latex的语法冲突，安装mathjax插件等等那么麻烦。 在主题配置文件中搜索 mathjax ，将开关设置为 true ，其中的 per_page字段如果设置为 true ，那么只有主页和文章头部带有mathjax: true 字段的博文才会加载 mathjax引擎。这里注意下，要更改默认的 cdn 地址，之前的地址已经停用了。 详见：https://github.com/iissnan/hexo-theme-next/pull/1712 https://github.com/iissnan/hexo-theme-next/pull/887 3.18 启用点击下载功能在网站的source目录下，新建download目录，和_posts、About、tags、categories等目录并列。然后，将需要分享的文件或者图片统一放到该download下。在写文章时，通过诸如[点击下载](/download/xx.exe)这样的链接，直接写入。 效果图： 4、集成第三方服务4.1 Valine评论系统针对评论系统来讲的话，多说和网易云已经倒了，畅言需要备案，Disqus，Hypercomments和LiveRe等都是国外的，不仅加载速度慢还容易被墙，找来找去，决定使用valine（2017年8月诞生的一款基于LeanCloud的极简风评论系统）。NexT主题本身就已经集成了valine，所以设置起来也比较简单。 4.1.1 注册LeanCloud，获取appid和appkey在官网注册账号并创建应用，应用选择开发版即可，毕竟穷孩子，免费的好啊。应用名字随便起，创建完成后，在 设置 &gt;&gt; 应用key 中可以看到此应用的appid和appkey。 4.1.2 配置web安全域名为了数据安全，在 设置 &gt;&gt; 安全中心中设置web安全域名，如下图： 4.1.3 创建Class对象在 存储 &gt;&gt; 数据栏中，创建两个Class，一个名为Counter，用于记录统计每篇博文的阅读次数；另一名为Comment用于记录存储每篇博文的评论。注意，此处两个Class的名字是固定的，不能更改。 可以手动修改 Counter表中time字段的值，也就是修改了博文的阅读次数，美滋滋~~~ 4.1.4 修改主题配置文件搜索 leancloud字段，将 enable字段设置为 true，app_id和app_key填写之前获得的值，此时，就可以在页面中启用博文阅读次数统计功能。 搜索valine字段，将 enable字段设置为 true，app_id和app_key填写之前获得的值，此时，就可以在页面中启用博文评论及回复功能。其中的notify字段代表有评论时邮件提醒，verify字段代表开启验证码，avatar代表评论者的头像，placeholder字段代表初始评论框中显示的文字，等等。。。 4.1.5 最终效果展示后台数据管理： 阅读次数统计： 底部评论区： 4.1.6 邮件提醒功能配置至此，已经能够使用评论系统了，但它虽然支持邮件提醒（基于密码重置提醒邮件），功能却很弱，无法提示到具体文章，也无法给评论者进行有效的回复通知，通常别人留完言，怎么还会再来你的博客看你是否回复了呢？所以，这里我们引用GitHub上某位大佬的配置，它满足了： 完善的邮件通知，自定义 SMTP 发件频率和内容不再受限 基于 Akismet 的垃圾评论自动标注和过滤 评论管理，避免直接操作数据库 …… 邮件效果如下图所示： 管理界面如下图： 4.2 卜算子统计在主题配置文件中搜索 busuanzi_count，将开关打开，并做如下图修改，即可统计站点的 UV和PV： 实现效果如下图： 第一行的 Site words total count很是刺眼，改！之前的leancloud留下来的历史问题。在 \themes\next\layout\_partials\footer.swig中第19行做如下修改： 1#&#125;&#123;&#123; totalcount(site, '0,0.0a') &#125;&#125; 字&#123;# 在\themes\next\language\zh-Hans.yml文件中，修改第36行，如下： 1234#修改前： totalcount: Site words total count#修改后： totalcount: 本站共计 5、To DO List 侧边栏添加日历 点击查看教程链接 SEO优化 CND优化 静态资源压缩（github pages提供的免费空间有限） 添加动态萌宠 先安装必要的模块 12npm install --save hexo-helper-live2dnpm install live2d-widget-model-hijiki #此行不同的萌宠，对应不同的模块 在站点配置文件的末尾添加如下代码段： 1234567891011121314151617# live2d live2d: enable: true scriptFrom: local pluginRootPath: live2dw/ pluginJsPath: lib/ pluginModelPath: assets/ model: use: live2d-widget-model-hijiki/ display: position: left width: 80 height: 300 hOffset: 20 #水平相对位移 vOffset: -200 #垂直相对位移 mobile: show: true 代码区添加点击复制按钮 隐私博文加密访问 点击查看教程链接 设置背景及透明度 打开 \themes\next\source\css\_custom\custom.styl文件，添加如下代码即可： 1234567891011body &#123; background:url(https://source.unsplash.com/random/1920x1080); background-repeat: repeat; background-attachment:fixed; background-position:50% 50%;&#125;//改变背景色和透明度.main-inner &#123; background: #fff; opacity: 0.9;&#125; 添加网易云音乐 在网易云音乐网页版，找到自己想要的歌曲，点击生成播放外链，生成如下所示的代码，将iframe模块放到主题中 layout/_macro/sidebar.swig文件的适当位置即可。 1&lt;iframe frameborder=&quot;no&quot; border=&quot;0&quot; marginwidth=&quot;0&quot; marginheight=&quot;0&quot; width=298 height=52 src=&quot;//music.163.com/outchain/player?type=2&amp;id=570240588&amp;auto=0&amp;height=32&quot;&gt;&lt;/iframe&gt; 个性化字体设置–设置代码块字体大小 NexT 从 5.0.1 版本开始提供一个 字体定制特性，编辑主题下的 source/css/_variables/custom.styl 文件，新增如下代码： 12// 代码字体的大小$code-font-size = 15px 文章顶部添加最近更新时间 在主题设置文件中搜索update，将其设置为true即可。 个性设置文章间分割线 取消博文段落自动编号 将主题配置文件中的 toc ：number 字段设置为 false 安装PDF插件 执行命令 npm install hexo-pdf --save，之后编辑博客的时候即可使用 标签：引用本地的pdf文件。 。。。。。。 6、bug解决6.1 busuanzi统计失效问题前往 http://busuanzi.ibruce.info/ 卜算子官网，可以发现有提示说 因七牛强制过期『dn-lbstatics.qbox.me』域名，与客服沟通无果，只能更换域名到『busuanzi.ibruce.info』！。所以接下来的bug修复工作就十分简单了。在主题文件 themes/next/layout/_third-party/analytics/busuanzi-counter.swig 文件中，将 &lt;script&gt; 标签中的 src字段改为： src=&quot;//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js&quot; 即可解决。]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>笔记</tag>
      </tags>
  </entry>
</search>
