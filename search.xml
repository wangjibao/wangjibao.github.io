<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Go语言实战阅读笔记]]></title>
    <url>%2F2019%2F11%2F06%2FGo%E8%AF%AD%E8%A8%80%E5%AE%9E%E6%88%98%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[1、Go 语言更高效的利用计算机CPU上的所有核心，更高效的复用代码。 2、Go 语言自带垃圾回收器，不需要用户自己管理内存。 3、使用 goroutine 并发，使用 通道 避免其他语言中的共享内存访问的问题，减少了锁 或者 同步机制。 4、Go 语言的每个代码文件都属于一个包，一个包定义一组编译过的代码，包的名字类似于命名空间。处在同一个文件夹里的代码文件，必须使用同一个包名，按照惯例，包和文件夹同名。 5、Go 编译器为了让程序的可读性更强，不允许声名导入某个包却不使用。解决方法： 在导入的路径前加一个 下划线 ，这样它会调用对应包内的所有代码文件里定义的 init 函数，进行初始化操作。 6、每个代码文件里的 init 函数都会在 main 函数执行前调用。 7、Go 中，标识符（变量 or 函数等）要么从包里公开，要么不从包里公开。当代码导入了一个包时，程序可以直接访问这个包中任意一个公开的标识符。公开的标识符用 大写字母 开头，以 小写字母 开头的标识符是不公开的。 8、 在 Go 中，所有变量都会被初始化为其零值，如 指针 类型的零值为 nil ，引用类型的话，所引用的底层数据结构会被初始化为对应的零值，整个引用类型的变量会返回 nil 作为其值。 9、:= 运算符，用于声明一个变量并给这个变量赋予初始值。 10、如果需要声明初始值为零值的变量，应该使用 var 关键字声明变量；如果提供确切的非零值初始化变量或者使用函数返回值创建变量，应该使用简化变量声明运算符 := 。 11、Go 中声明常量的时候不需要指定类型。 12、关键字 defer 会将其后面的函数调用在函数返回时才执行。关键字 defer 可以保证这个函数一定会被调用，哪怕函数意外崩溃终止，还可以缩短打开文件和关闭文件之间间隔的代码行数，提高代码可读性。 13、如果声明函数的时候带有接收者，则意味着声明了一个方法，这个方法会和指定的接收者类型绑定在一起。接口实现多态 14、使用 指针 可以在 函数 间或者 goroutine 间共享数据。 15、Go 程序编译时，会使用声明 main 包的代码所在的目录的目录名作为二进制可执行文件的文件名。 16、创建并初始化 切片、映射 等，可以使用内置的 make 函数 或者 字面量 。[] 中指定长度的是 数组，不指定长度的是 切片。 17、在Go语言中，数组、切片、映射 在作为参数传入函数时，只有 数组 是将全部的值复制一份拷贝，切片、映射 仅拷贝元数据，其底层的存储用的是同一份。 18、切片、函数以及包含切片的结构类型这些类型由于具有引用语义，不能作为映射的键。 19、Go 语言是静态类型 的编程语言，也就是说，编译器需要在编译的时候就知道程序里每个变量的类型。 20、Go 编译器不会对不同类型的值做隐式转换。 21、关键字 func 和函数名之间的参数被称作 接收者, 将函数与接收者的类型绑在一起。如果一个函数有接收者，这个函数就被称为 方法 。Go 语言里有两种类型的接收者：值接收者 和 指针接收者 。如果使用值接收者声明方法，调用时会使用这个值的副本来执行，而指针接收者使用实际值来调用方法。 Go 语言既允许使用值，也允许使用指针来调用方法，不必严格符合接收者的类型。 22、方法，接口与方法集 在将数据类型与方法绑定时，值可以调用绑定值或者值指针的方法，值指针也可以调用绑定值或者值指针的方法，没什么影响，只取决于是否要更改变量的某些东西。 在数据类型实现接口中声明的函数（方法）时，如果将值与方法绑定，那么只能通过值调用该方法（将值传递给接口参数，接口.函数（））；如果将值指针与方法绑定，可以通过值或者值指针来调用该方法。原因是：不是总能获得一个值的地址，所以值的方法集只能包括使用值接收者实现的方法。 23、嵌入类型 嵌入类型是将已有的类型直接声明在新的结构类型里，被嵌入的类型被称为新的外部类型的内部类型。 要嵌入一个类型，只需要声明这个类型的名字就可以了。 通过嵌入类型，与内部类型相关的标识符会提升到外部类型上。这样被提升的标识符就像直接声明在外部类型里的标识符一样，也是外部类型的一部分。 外部类型可以通过声明与内部类型标识符同名的标识符来覆盖内部标识符的字段或者方法。 注意 自动提升， 如果外部类型实现了 某方法 , 内部类型的实现就不会被提升。不过内部类型的值一直存在，因此还可以通过直接访问内部类型的值，来调用没有被提升的内部类型实现的方法。 24、当一个标识符的名字以小写字母开头时，这个标识符就是未公开的，即包外的代码不可见。结构类型是公开的，里面的某个字段是未公开的，那么也不能在包外访问这个未公开的字段。 25、 Go 语言调度器在任何给定的时间，都会全面控制哪个 goroutine 要在哪个逻辑处理器上运行。用于在 goroutine 之间同步和传递数据的关键数据类型叫做 通道。 26、Go 语言在运行时，默认会为每个可用的物理处理器分配一个逻辑处理器。 27、goroutine 终止时无法获取函数的返回值。 28、Go 语言中一种消除竞争状态的办法是：使用Go 语言提供的 锁机制， 来锁住 共享资源 ，从而保证 goroutine 的同步状态。 原子函数 。 在 sync/atomic 库， atomic.AddInt()、atomic.LoadInt()、atomic.StoreInt() 互斥锁。 在 sync.Mutex 中， mutex.Lock()、mutex.Unlock() 29、有缓冲通道和无缓冲通道 无缓冲通道保证进行发送和接收的goroutine 会在同一时间进行数据交换。 有缓冲的通道， 只有在缓冲区满的时候，发送动作才会堵塞，只有在缓冲区空的时候，接收动作才会阻塞。 30、当通道关闭后，goroutine 依旧可以从通道接收数据，但是不能再向通道里发送数据。这允许通道关闭后依旧能取出其中缓冲的全部值，而不会有数据丢失。从一个已经关闭且没有数据的通道里获取数据，总会立刻返回，并返回一个通道类型的零值。如果在获取通道时还加入了可选的标志，就能得到通道的状态信息。 31、select 语句只能处理通道类型的数据，当有 default 语句时，前面的条件都不满足的时候执行 default 语句，当没有 default 语句的时候，程序进入阻塞状态。当有多个语句满足条件时，select 随机挑选一条执行，其他的忽略。 switch 语句可以处理各种类型的数据。 32、Go 语言中的通道类型分为 双向通道 和 单向通道。 双向：chan、只发送数据：&lt;-chan、只接收数据：chan&lt;-。 33、Go 语言中的断言 类型断言的本质，跟类型转换类似，都是类型之间进行转换 。 不同之处在于，类型断言是在接口之间进行 。 12&lt;目标类型的值&gt;，&lt;布尔参数&gt; := &lt;表达式&gt;.( 目标类型 ) // 安全类型断言&lt;目标类型的值&gt; := &lt;表达式&gt;.( 目标类型 ) //非安全类型断言 34、定制 日志记录器 ，可以将不同层次的日志记录到不同的路径中去。 方法：创建 log.Logger 指针，并使用 log.New() 初始化。 35、反序列化 : 将字符串转换成数据变量值， 序列化: 将数据变量值转换成字符串。 36、任何类型都实现了一个空接口 interface{}，声明一个 map 类型，其键是 string 类型，其值是 interface{} 类型，这意味着这个 map 类型可以使用任意类型的值作为给定键的值。 37、Go 语言的测试工具只会认为以 _test.go 结尾的文件是测试文件。一但测试工具找到了测试文件，就会查找里面的测试函数并执行。包的名字以 _test 结尾，那么测试代码只能访问包里的公开的标识符，即便测试代码文件和被测试代码文件的代码放在同一个文件夹中，也只能访问公开的标识符。 38、一个测试函数必须是公开的函数，并且以 Test 开头，并且函数的参数要接收一个指向 testing.T 类型的指针，并且不返回任何值。 39、Println 、Fatalln 、Panicln 这三个函数都有格式化的版本，值需要用 f 替换结尾的 ln。 Fatal 系列函数用来写日志消息，然后使用 os.Exit(1) 终止程序。 Panic 系列函数用来写日志消息，然后出发一个 panic ，除非程序执行 recover 函数，否则会导致程序打印调用栈后终止。 Print 系列函数是写日志消息的标准方法。 40、如果测试函数执行时没有调用过 t.Fatal 或者 t.Error 方法，就认为测试通过了。 41、基础单元测试、 表组测试 ： 测试可以接受一组不同的输入并产生不同的输出的代码。 42、结构类型 (struct) 在初始化时，如果是在同一行赋值的话，行尾不需要加逗号。如果每一行初始化一个字段，那么每一行末尾都需要加一个逗号。 43、基准测试 和单元测试文件一样，基准测试的文件名也必须以 _test.go 结尾，同时也必须导入 testing 包。基准测试函数必须以 Benchmark 开头，接受一个指向 testing.B 类型的指针作为唯一参数。 44、包中的示例代码，既能用于测试，也能用于文档。函数名以 Example 开头。]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode81-90]]></title>
    <url>%2F2019%2F10%2F24%2FLeetCode81-90%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[Docker实战笔记]]></title>
    <url>%2F2019%2F10%2F22%2FDocker%E5%AE%9E%E6%88%98%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[闲来没事苟着，顺手读读之前买的已经落灰的书《Docker实战》。 1、daemon（守护进程），运行中的 docker 由守护进程（服务端）和客户端组成(通过unix域间套接字通信），比如说，执行：docker ps -a 命令，是客户端将命令传送给守护进程，由守护进程发送对应的响应给前端，前端解析并显示。可以通过如下操作查看docker守护进程和客户端的通信过程:1234sudo socat -v UNIX-LISTEN:/tmp/dockerapi.sock UNIX-CONNECT:/var/run/docker.sock## 其中 socat 是 netcat(nc) 命令的升级版，-v 参数有助于人阅读 address1 address2 可以是 tcp、udp或 socket等docker -H unix:///tmp/dockerapi.sock ps -a## -H 参数指定 docker daemon socket(s) to connect to. 两者直接通过 HTTP 通信，客户端解析返回的 json 并显示，运行结果如下： 2、以服务方式在后台运行一个 docker 容器（docker最主要的功能之一），使用 docker run -p *** 命令。不然的话，需要使用类似 nohup docker run *** &amp; 的方式来实现此功能。 3、docker 中的端口映射—将容器的某端口暴露给宿主机的某端口，便于外界访问容器中的功能：1docker run -p 宿主机端口：容器端口 --name 容器名 使用的镜像名 4、给Docker打标签12docker tag IMAGE_ID（镜像id) REPOSITY:TAG（仓库：标签）docker commit CONTAINER [REPOSITY:TAG] 5、Docker挂载外部卷1docker run -v 宿主机目录：容器内目录 -it ubuntu /bin/bash 注意一点：镜像中即使存在需要映射的目录，容器的目录也会被建立映射，这意味着容器里映射的目录的原内容将会消失。当然，也可以通过网络映射其他机器上的卷。在容器里运行如下命令即可：123sshfs user@host_ip:remote_path local_path# 卸载fusermount -u local_path 6、想要在 Dockerfile 构建中从一个指定的点开始失效 Docker 构建缓存，可以：在某条Dockerfile命令后面加个注释，这样，该条命令及其后的指定的缓存就失效了。原理在于 Docker 将非空的更改均当做一行新的命令来对待。 7、bash 里的 “&lt; (命令）” 语法被称为进程替换，它允许把一个命令的输出结果作为一个文件，传给其他命令。 8、解绑容器的同时不停掉它，解决：按下 ctrl + p 然后再按 ctrl + q。原因：在使用 docker 时，会发现，打开一个交互式 shell，然后因为它是容器的主进程，所以一旦退出会话，容器便会被终止（可以使用 docker attach 再连接到容器）。 9、想要从镜像的分层历史中移除私密信息，解决：基于该镜像创建一个容器，将它导出再导入并打上标签。1docker export (容器ID) | docker import - (标签) docker import 会输出一个 文件系统的内容的一个TAR文件， “-”参数指明从标准输入读取 TAR 文件内容。 10、Dockerfile 指令Dockerfile中包括FROM、MAINTAINER、RUN、CMD、EXPOSE、ENV、ADD、COPY、ENTRYPOINT、VOLUME、USER、WORKDIR、ONBUILD等13个指令。VOLUME: 作用是创建在本地主机或其他容器可以挂载的数据卷，用来存放数据。ONBUILD : 该配置指定当所创建的镜像作为其他新建镜像的基础镜像时所执行的指令。ENTRYPOINT : 用于配置容器启动后执行的命令，这些命令不能被docker run提供的参数覆盖。和CMD一样，每个Dockerfile中只能有一个ENTRYPOINT，当有多个时最后一个生效。 11、Dockerfile 的逆向：12345678docker history reverseme | \awk '&#123;print $1&#125;' | \grep -v IMAGE | \tac | \sed "s/\(.*\)/docker inspect \1 | \jq -r \'.[0].ContainerConfig.Cmd[2] | tostring\'/" | \sh | \sed 's/^#(nop) //' 12、export 和 import 与 save 和 load 的对比如果要保留镜像的历史，可以使用 load 而不是 import， 这样其历史将在另一边的 Docker 守护进程上得到保留。 13、Docker compose 的使用，可节省大量的命令行操作。 14、使用 Blockade 及 Comcast 对容器网络状况进行控制。 15、多宿主机Docker的部署和编排 使用 Helios 手动管理多宿主机 Docker，涉及 Zookeeper 技术（一个分布式数据库，用来存储数据，用于 Helios 主机 和 Helios 代理之间的通信）。 docker + Swarm 想要跨宿主机管理 Docker 服务，使用 Kubernetes。 Mesos + Docker 使用 Marathon 细粒度管理 Mesos 16、OpenShift, 应用程序平台即服务（aPaaS）。使用Docker 作为容器技术，并用 Kubernetes 和 etcd 进行编排。一种安全管理的方式，去除用户直接运行docker的能力，同时又保持使用Docker的好处。 17、使用 cAdvisor 监控容器的性能。 18、限制容器 cpu 和 内存 的使用，使用 docker run -c -m 等参数。 19、在 bash 中，$? 给出最后一条执行命令的退出码。 20、strace 是一个工具，它允许嗅探一个进程对 Linux API 所做的调用。]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode71-80]]></title>
    <url>%2F2019%2F08%2F28%2FLeetCode71-80%2F</url>
    <content type="text"><![CDATA[71、简化路径模拟题123456789101112131415161718192021222324252627282930313233class Solution &#123;public: string simplifyPath(string path) &#123; for(int i=1; i&lt;path.length(); i++)&#123; if(path[i-1]=='/' &amp;&amp; path[i]=='/') path.erase(i--,1); &#125; if(path[path.length()-1]=='/') path.erase(path.length()-1); vector&lt;string&gt; fenduan; int pos = 0, index; while(pos&gt;=0 &amp;&amp; pos&lt;path.length())&#123; index = path.find('/', pos+1); fenduan.push_back(path.substr(pos, index-pos)); pos = index; &#125; string ans = ""; for(auto i : fenduan)&#123; if(i=="/.") continue; else if(i=="/..")&#123; index = ans.find_last_of('/'); if(index&gt;=0 &amp;&amp; index&lt;ans.size()) ans.erase(index); &#125; else ans += i; &#125; if(ans.size()==0) ans = "/"; return ans; &#125;&#125;; 72、编辑距离DP 题，状态转移方程如下: 123456789101112131415161718192021class Solution &#123;public: int minDistance(string word1, string word2) &#123; int len1 = word1.length(), len2 = word2.length(); int ans[len1+1][len2+1]; memset(ans, 0, sizeof(ans)); for(int i=0; i&lt;=len1; i++) ans[i][0] = i; for(int i=0; i&lt;=len2; i++) ans[0][i] = i; for(int i=1; i&lt;=word1.length(); i++)&#123; for(int j=1; j&lt;=word2.length(); j++)&#123; if(word1[i-1]==word2[j-1]) ans[i][j] = ans[i-1][j-1]; else ans[i][j] = 1+min(ans[i-1][j-1], min(ans[i-1][j], ans[i][j-1])); &#125; &#125; return ans[len1][len2]; &#125;&#125;; 73、 矩阵置零模拟题，O(1) 的空间的 trick ，使用矩阵的第一行和第一列记录该行/列中有无 0 元素，同时注意使用 col1_has_zero 和 row1_has_zero 两个变量记录第一行/列有无 0 元素。1234567891011121314151617181920212223242526272829303132333435363738class Solution &#123;public: void setZeroes(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) &#123; bool row1_has_zero = false, col1_has_zero = false; for(int i=0; i&lt;matrix.size(); i++) if(matrix[i][0]==0)&#123; col1_has_zero = true; break; &#125; for(int i=0; i&lt;matrix[0].size(); i++) if(matrix[0][i]==0)&#123; row1_has_zero = true; break; &#125; for(int i=1; i&lt;matrix.size(); i++)&#123; for(int j=1; j&lt;matrix[0].size(); j++)&#123; if(matrix[i][j]==0)&#123; matrix[0][j] = matrix[i][0] = 0; &#125; &#125; &#125; for(int i=1; i&lt;matrix.size(); i++)&#123; for(int j=1; j&lt;matrix[0].size(); j++)&#123; if(!matrix[0][j] || !matrix[i][0])&#123; matrix[i][j] = 0; &#125; &#125; &#125; if(row1_has_zero)&#123; for(int i=0; i&lt;matrix[0].size(); i++) matrix[0][i] = 0; &#125; if(col1_has_zero)&#123; for(int i=0; i&lt;matrix.size(); i++) matrix[i][0] = 0; &#125; &#125;&#125;; 74、搜索二维矩阵二分查找，先按照行查找，再按照列查找。123456789101112131415161718192021222324class Solution &#123;public: bool searchMatrix(vector&lt;vector&lt;int&gt;&gt;&amp; matrix, int target) &#123; if(matrix.size()==0 || matrix[0].size()==0) return false; int L = 0, R = matrix.size()-1, Middle = 0; // 二分查找 while(L&lt;R)&#123; Middle = (L+R) &gt;&gt; 1; if(target&lt;matrix[Middle][0]) R = Middle - 1; else if(target&gt;matrix[Middle][0])&#123; if(target&lt;=matrix[Middle][matrix[0].size()-1])&#123; L = Middle; break; &#125; L = Middle + 1; &#125; else return true; &#125; return binary_search(&amp;matrix[L][0], &amp;matrix[L][0]+matrix[0].size(), target); &#125;&#125;; 75、颜色分类三路快排原理: 123456789101112131415161718192021class Solution &#123;public: void sortColors(vector&lt;int&gt;&amp; nums) &#123; // 三路快排原理 int p0 = 0, p1 = 0, p2 = nums.size()-1; while(p1&lt;=p2)&#123; if(nums[p1]==0)&#123; swap(nums[p0], nums[p1]); p0++; p1++; &#125; else if(nums[p1]==1)&#123; p1++; &#125; else&#123; swap(nums[p1], nums[p2]); p2--; &#125; &#125; &#125;&#125;; 76、最小覆盖子串双指针 + 滑动窗口12345678910111213141516171819202122232425262728293031class Solution &#123;public: string minWindow(string s, string t) &#123; string ans = ""; if(s.size()==0 || t.size()==0) return ans; int left = 0, right = 0, matchs = 0; int minLen = INT_MAX; unordered_map&lt;char, int&gt; window, need; for(int i=0; i&lt;t.size(); i++) need[t[i]]++; int kinds = need.size(); while(right&lt;s.size())&#123; if( ++window[s[right]] == need[s[right++]] ) matchs++; if(matchs==kinds)&#123; while(left&lt;right)&#123; if( --window[s[left]] &lt; need[s[left++]] )&#123; matchs--; break; &#125; &#125; if(minLen&gt;right-(left-1))&#123; minLen = right - (left-1); ans = s.substr(left-1, minLen); &#125; &#125; &#125; return minLen==INT_MAX? "" : ans; &#125;&#125;; 77、组合简单深搜1234567891011121314151617181920212223242526class Solution &#123;public: void DFS(vector&lt;vector&lt;int&gt;&gt;&amp; ans, vector&lt;int&gt;&amp; tmp_ans, int position, int n, int k)&#123; if(n-position+1+tmp_ans.size() &lt; k) return ; if(tmp_ans.size()==k)&#123; ans.push_back(tmp_ans); return ; &#125; for(int i=position; i&lt;=n; i++)&#123; tmp_ans.push_back(i); DFS(ans, tmp_ans, i+1, n, k); tmp_ans.pop_back(); &#125; &#125; vector&lt;vector&lt;int&gt;&gt; combine(int n, int k) &#123; vector&lt;vector&lt;int&gt;&gt; ans; vector&lt;int&gt; tmp_ans; for(int i=1; i&lt;=n; i++)&#123; tmp_ans.push_back(i); DFS(ans, tmp_ans, i+1, n, k); tmp_ans.pop_back(); &#125; return ans; &#125;&#125;; 78、子集深搜，水题一道1234567891011121314151617class Solution &#123;public: void DFS(vector&lt;vector&lt;int&gt;&gt;&amp; ans, vector&lt;int&gt;&amp; tmp_ans, int position, vector&lt;int&gt;&amp; nums)&#123; ans.push_back(tmp_ans); for(int i=position; i&lt;nums.size(); i++)&#123; tmp_ans.push_back(nums[i]); DFS(ans, tmp_ans, i+1, nums); tmp_ans.pop_back(); &#125; &#125; vector&lt;vector&lt;int&gt;&gt; subsets(vector&lt;int&gt;&amp; nums) &#123; vector&lt;vector&lt;int&gt;&gt; ans; vector&lt;int&gt; tmp_ans; DFS(ans, tmp_ans, 0, nums); return ans; &#125;&#125;; 79、单词搜索基础深搜题，注意剪枝即可。123456789101112131415161718192021222324252627282930313233343536class Solution &#123;public: int direct[4][2] = &#123;&#123;0,1&#125;, &#123;0,-1&#125;, &#123;1,0&#125;, &#123;-1,0&#125;&#125;; bool judge(int n, int m, int row, int col)&#123; return row&gt;=0 &amp;&amp; row&lt;n &amp;&amp; col&gt;=0 &amp;&amp; col&lt;m; &#125; bool DFS(vector&lt;vector&lt;char&gt;&gt;&amp; board, string word, vector&lt;vector&lt;bool&gt;&gt;&amp; used, int row, int col, int pos)&#123; if(pos==word.size()-1) return true; used[row][col] = true; for(int i=0; i&lt;4; i++)&#123; int tmp_row = row + direct[i][0]; int tmp_col = col + direct[i][1]; if(judge(board.size(), board[0].size(), tmp_row, tmp_col) &amp;&amp; used[tmp_row][tmp_col]==false &amp;&amp; board[tmp_row][tmp_col]==word[pos+1])&#123; if(DFS(board, word, used, tmp_row, tmp_col, pos+1)) return true; &#125; &#125; used[row][col] = false; return false; &#125; bool exist(vector&lt;vector&lt;char&gt;&gt;&amp; board, string word) &#123; int n = board.size(), m = board[0].size(); vector&lt;vector&lt;bool&gt;&gt; used(n, vector&lt;bool&gt;(m, false)); for(int i=0; i&lt;n; i++)&#123; for(int j=0; j&lt;m; j++)&#123; if( board[i][j]==word[0] &amp;&amp; DFS(board, word, used, i, j, 0) ) return true; &#125; &#125; return false; &#125;&#125;; 80、删除排序数组中的重复项 II双指针的使用123456789101112131415class Solution &#123;public: int removeDuplicates(vector&lt;int&gt;&amp; nums) &#123; if(nums.size()&lt;=2) return nums.size(); int p_front=2, p_back=2; while(p_back&lt;nums.size())&#123; if(nums[p_back]==nums[p_front-2]) p_back++; else nums[p_front++] = nums[p_back++]; &#125; return p_front; &#125;&#125;;]]></content>
      <categories>
        <category>LeetCode</category>
        <category>LeetCode61-70</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode61-70]]></title>
    <url>%2F2019%2F08%2F28%2FLeetCode61-70%2F</url>
    <content type="text"><![CDATA[61、旋转链表模拟题 12345678910111213141516171819202122232425262728293031/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: ListNode* rotateRight(ListNode* head, int k) &#123; int len = 0; for(struct ListNode *ptr = head; ptr; ptr=ptr-&gt;next)&#123; len++; if(ptr-&gt;next==NULL)&#123; ptr-&gt;next = head; break; &#125; &#125; if(len==0) return NULL; k %= len; for(int i=1; i&lt;=len-k; i++) head = head-&gt;next; struct ListNode *ans = head; for(int i=1; i&lt;len; i++) head = head-&gt;next; head-&gt;next = NULL; return ans; &#125;&#125;; 62、不同路径排列组合，当 m 和 n 较大时，应该使用 Lucas 定理。 12345678910111213class Solution &#123;public: int uniquePaths(int m, int n) &#123; int total = m+n-2; int frac = min(m-1, n-1); long long fenzi = 1, fenmu = 1; for(int i=1; i&lt;=frac; i++)&#123; fenzi *= total-i+1; fenmu *= i; &#125; return fenzi/fenmu; &#125;&#125;; 63、不同路径 II同上一题，只不过加了障碍，判断一下即可。 12345678910111213class Solution &#123;public: int uniquePathsWithObstacles(vector&lt;vector&lt;int&gt;&gt;&amp; obstacleGrid) &#123; int n = obstacleGrid.size(), m = obstacleGrid[0].size(); vector&lt;long long&gt; ans(m, 0); for(int i=0; i&lt;n; i++)&#123; ans[0] = i==0? (obstacleGrid[i][0]+1)%2 : ((obstacleGrid[i][0]+1)%2 &amp;&amp; ans[0]); for(int j=1; j&lt;m; j++) ans[j] = obstacleGrid[i][j]==1?0:ans[j-1]+ans[j]; &#125; return ans[m-1]; &#125;&#125;; 64、最小路径和水 dp 1234567891011121314class Solution &#123;public: int minPathSum(vector&lt;vector&lt;int&gt;&gt;&amp; grid) &#123; int i, j; for(i=1; i&lt;grid.size(); i++) grid[i][0] += grid[i-1][0]; for(j=1; j&lt;grid[0].size(); j++) grid[0][j] += grid[0][j-1]; for(i=1; i&lt;grid.size(); i++) for(j=1; j&lt;grid[0].size(); j++) grid[i][j] += min(grid[i-1][j], grid[i][j-1]); return grid[grid.size()-1][grid[0].size()-1]; &#125;&#125;; 65、 有效数字见过的最恶心的题目 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748class Solution &#123;public: bool isNumber(string s) &#123; vector&lt;int&gt; num(10,0); s.erase(0,s.find_first_not_of(" ")); s.erase(s.find_last_not_of(" ") + 1); if(s[s.length()-1]=='e' || s[s.length()-1]=='+' || s[s.length()-1]=='-') return false; for(int i=0; i&lt;s.length(); i++)&#123; if(s[i]=='-' || s[i]=='+')&#123; num[0]++; if(i&gt;0 &amp;&amp; (s[i-1]=='-' || s[i-1]=='+')) return false; &#125; else if(s[i]=='e') num[1]++; else if(s[i]&gt;='0' &amp;&amp; s[i]&lt;='9') num[3]++; else if(s[i]=='.' &amp;&amp; num[1]==0)&#123; num[2]++; &#125; else return false; &#125; if(num[0]&gt;2 || num[1]&gt;1 || num[2]&gt;1 || s[0]=='e' || num[3]==0) return false; if(num[1]==1)&#123; int index = s.find('e'); if(index==s.length()-1 || (index==1 &amp;&amp; s[0]=='.') || (index&gt;0 &amp;&amp; (s[index-1]=='-' || s[index-1]=='+'))) return false; &#125; if(num[0])&#123; int index = s.find('-'); if(index&lt;0 || index&gt;=s.length()) index = s.find('+'); if(index==s.length()-1 || (index&gt;0 &amp;&amp; ((isdigit(s[index-1]) &amp;&amp; isdigit(s[index+1])) || s[index-1]=='.'))) return false; int sum = 0; for(int i=index+1; i&lt;s.length(); i++)&#123; if(s[i]&gt;='0' &amp;&amp; s[i]&lt;='9') sum++; &#125; if(sum==0) return false; &#125; return true; &#125;&#125;; 66、 加一模拟题，考虑下进位即可。 1234567891011121314class Solution &#123;public: vector&lt;int&gt; plusOne(vector&lt;int&gt;&amp; digits) &#123; int num = 1; for(int i=digits.size()-1; i&gt;=0.; i--)&#123; num += digits[i]; digits[i] = num % 10; num /= 10; &#125; if(num) digits.insert(digits.begin(), 1); return digits; &#125;&#125;; 67、二进制求和模拟题，考虑二进制进位即可。 12345678910111213141516171819class Solution &#123;public: string addBinary(string a, string b) &#123; string ans = ""; int flag = 0, sum = 0; int len_a = a.size(), len_b = b.size(); while(len_a&gt;0 || len_b&gt;0)&#123; sum = flag; if(len_a&gt;0) sum += a[--len_a]-'0'; if(len_b&gt;0) sum += b[--len_b]-'0'; flag = sum/2; ans.insert(ans.begin(), '0'+sum%2); &#125; if(flag) ans = '1' + ans; return ans; &#125;&#125;; 68、文本左右对齐模拟题，对空格数做判断。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051class Solution &#123;public: vector&lt;string&gt; fullJustify(vector&lt;string&gt;&amp; words, int maxWidth) &#123; vector&lt;string&gt; ans; vector&lt;vector&lt;string&gt;&gt; tmp; int len = 0, pos = 0, i; while(pos&lt;words.size())&#123; ans.clear(); i = pos; ans.push_back(words[i]); len = words[i++].length()+1; while(i&lt;words.size() &amp;&amp; len+words[i].length()&lt;=maxWidth)&#123; ans.push_back(words[i]); len += words[i++].length() + 1; &#125; tmp.push_back(ans); pos = i; &#125; ans.clear(); string tmp_ans; for(int k=0; k&lt;tmp.size()-1; k++)&#123; len = 0; tmp_ans = ""; for(int j=0; j&lt;tmp[k].size(); j++) len += tmp[k][j].length(); int konggeshu, yushu; if(tmp[k].size()==1)&#123; tmp_ans = tmp[k][0] + string(maxWidth-tmp[k][0].length(), ' '); &#125; else&#123; konggeshu = (maxWidth-len)/(tmp[k].size()-1); yushu = (maxWidth-len)%(tmp[k].size()-1); for(int i=0; i&lt;tmp[k].size()-1; i++)&#123; tmp_ans += tmp[k][i]+string(konggeshu, ' '); if(yushu&gt;0)&#123; tmp_ans += " "; yushu--; &#125; &#125; tmp_ans += tmp[k][tmp[k].size()-1]; &#125; ans.push_back(tmp_ans); &#125; tmp_ans = tmp[tmp.size()-1][0]; for(int i=1; i&lt;tmp[tmp.size()-1].size(); i++) tmp_ans += " " + tmp[tmp.size()-1][i]; tmp_ans += string(maxWidth-tmp_ans.length(), ' '); ans.push_back(tmp_ans); return ans; &#125;&#125;; 69、x 的平方根直接用库函数，思考如何自己手动计算一个数的平方根。 123456class Solution &#123;public: int mySqrt(int x) &#123; return int(sqrt(x)); &#125;&#125;; 70、爬楼梯斐波那契数列，这里使用矩阵快速幂加速。 12345678910111213141516171819202122232425262728293031323334353637struct transferMatrix&#123; long long matrix[2][2]; transferMatrix operator*(const transferMatrix&amp; matrix_tmp)&#123; transferMatrix matrix_ans; memset(matrix_ans.matrix, 0, sizeof(matrix_ans.matrix)); for(int i=0; i&lt;2; i++)&#123; for(int j=0; j&lt;2; j++)&#123; for(int k=0; k&lt;2; k++)&#123; matrix_ans.matrix[i][j] += matrix[i][k] * matrix_tmp.matrix[k][j]; &#125; &#125; &#125; return matrix_ans; &#125;&#125;;class Solution &#123;public: transferMatrix quick_pow(transferMatrix a, int n)&#123; transferMatrix ans; ans.matrix[0][0] = ans.matrix[1][1] = 1; ans.matrix[0][1] = ans.matrix[1][0] = 0; while(n)&#123; if(n%2) ans = ans*a; a = a*a; n /= 2; &#125; return ans; &#125; int climbStairs(int n) &#123; transferMatrix ans; ans.matrix[0][0] = ans.matrix[0][1] = ans.matrix[1][0] = 1; ans.matrix[1][1] = 0; ans = quick_pow(ans, n); return ans.matrix[0][0]; &#125;&#125;;]]></content>
      <categories>
        <category>LeetCode</category>
        <category>LeetCode61-70</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode51-60]]></title>
    <url>%2F2019%2F08%2F28%2FLeetCode51-60%2F</url>
    <content type="text"><![CDATA[51、N皇后回溯法 123456789101112131415161718192021222324252627282930313233class Solution &#123;public: int record[100]; bool check(int n, int step)&#123; for(int i=1; i&lt;step; i++) if(record[i]==record[step] || fabs(i-step)==fabs(record[i]-record[step])) return false; return true; &#125; void DFS(vector&lt;vector&lt;string&gt;&gt; &amp;ans, int n, int step)&#123; if(step&gt;n)&#123; vector&lt;string&gt; cur_ans(n,string(n,'.')); for(int i=1; i&lt;=n; i++) cur_ans[i-1][record[i]-1] = 'Q'; ans.push_back(cur_ans); return ; &#125; for(int i=1; i&lt;=n; i++)&#123; record[step] = i; if(check(n, step)) DFS(ans, n, step+1); &#125; &#125; vector&lt;vector&lt;string&gt;&gt; solveNQueens(int n) &#123; memset(record, 0, sizeof(record)); vector&lt;vector&lt;string&gt;&gt; ans; for(int i=1; i&lt;=n; i++)&#123; record[1] = i; DFS(ans, n, 2); &#125; return ans; &#125;&#125;; 52、N皇后 II同上一题 123456789101112131415161718192021222324252627282930class Solution &#123;public: int ans = 0; int record[100]; bool check(int n, int step)&#123; for(int i=1; i&lt;step; i++) if(record[i]==record[step] || fabs(i-step)==fabs(record[i]-record[step])) return false; return true; &#125; void DFS(int n, int step)&#123; if(step&gt;n)&#123; ans++; return ; &#125; for(int i=1; i&lt;=n; i++)&#123; record[step] = i; if(check(n, step)) DFS(n, step+1); &#125; &#125; int totalNQueens(int n) &#123; memset(record, 0, sizeof(record)); for(int i=1; i&lt;=n; i++)&#123; record[1] = i; DFS(n, 2); &#125; return ans; &#125;&#125;; 53、最大子序和12345678910111213class Solution &#123;public: int maxSubArray(vector&lt;int&gt;&amp; nums) &#123; long long max_sum = -9999999999999, sum = 0; for(auto i : nums)&#123; sum += i; max_sum = max(max_sum, sum); if( sum&lt;=0 ) sum = 0; &#125; return int(max_sum); &#125;&#125;; 54、螺旋矩阵模拟题 12345678910111213141516171819202122232425262728293031323334class Solution &#123;public: vector&lt;int&gt; spiralOrder(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) &#123; int direct[4][2] = &#123;&#123;0,1&#125;, &#123;1,0&#125;, &#123;0,-1&#125;, &#123;-1,0&#125;&#125;; int direction = 0, row = 0, col = 0, iter; vector&lt;int&gt; ans; if(matrix.size()==0) return ans; int total_nums = 0, rotal = 0; while(total_nums &lt; matrix.size() * matrix[0].size())&#123; if(direction%2) iter = matrix.size() - (2*(rotal/4) + 1); else iter = matrix[0].size() - (2*(rotal/4) + 1); if(direction==0 &amp;&amp; rotal&gt;0)&#123; row += 1; col += 1; &#125; if(matrix.size()*matrix[0].size()-total_nums==1)&#123; ans.push_back(matrix[row][col]); break; &#125; for(int i=1; i&lt;=iter; i++)&#123; ans.push_back(matrix[row][col]); total_nums++; row += direct[direction][0]; col += direct[direction][1]; &#125; rotal += 1; direction = (direction+1)%4; &#125; return ans; &#125;&#125;; 55、跳跃游戏判断能否到达最后一个位置，倒序遍历判断即可。 1234567891011121314class Solution &#123;public: bool canJump(vector&lt;int&gt;&amp; nums) &#123; int len = nums.size(); int pos = -1; for(int i=len-2; i&gt;=0; i--)&#123; if(nums[i]==0 &amp;&amp; pos==-1) pos = i; else if(pos-i &lt; nums[i]) pos = -1; &#125; return pos==-1? true : false; &#125;&#125;; 56、合并区间模拟题 12345678910111213141516171819202122232425class Solution &#123;public: static bool cmp(vector&lt;int&gt;&amp; vec1, vector&lt;int&gt;&amp; vec2)&#123; if(vec1[0]!=vec2[0]) return vec1[0] &lt; vec2[0]; return vec1[1] &lt; vec2[1]; &#125; vector&lt;vector&lt;int&gt;&gt; merge(vector&lt;vector&lt;int&gt;&gt;&amp; intervals) &#123; vector&lt; vector&lt;int&gt; &gt; ans; if(intervals.size()==0) return ans; sort(intervals.begin(), intervals.end(), cmp); vector&lt;int&gt; tmp_ans = intervals[0]; for(int i=1; i&lt;intervals.size(); i++)&#123; if(tmp_ans[1] &gt;= intervals[i][0]) tmp_ans[1] = max(intervals[i][1], tmp_ans[1]); else&#123; ans.push_back(tmp_ans); tmp_ans = intervals[i]; &#125; &#125; ans.push_back(tmp_ans); return ans; &#125;&#125;; 57、插入区间模拟题 12345678910111213141516171819202122232425262728293031323334353637class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; insert(vector&lt;vector&lt;int&gt;&gt;&amp; intervals, vector&lt;int&gt;&amp; newInterval) &#123; if(intervals.size()==0)&#123; intervals.push_back(newInterval); return intervals; &#125; int pos = -1, i = 0, j = 0; for(i=0; i&lt;intervals.size(); i++)&#123; if(newInterval[0]&gt;intervals[i][0])&#123; //²åÔÚ i+1 µÄÎ»ÖÃ pos = i; &#125; else break; &#125; pos++; for(i=pos-1; i&gt;=0; i--)&#123; if(intervals[i][1]&gt;=newInterval[0])&#123; newInterval[0] = min(intervals[i][0], newInterval[0]); newInterval[1] = max(newInterval[1], intervals[i][1]); &#125; else break; &#125; for(j=pos; j&lt;intervals.size(); j++)&#123; if(newInterval[1]&gt;=intervals[j][0])&#123; newInterval[0] = min(intervals[j][0], newInterval[0]); newInterval[1] = max(newInterval[1], intervals[j][1]); &#125; else break; &#125; intervals.erase(intervals.begin()+(i+1), intervals.begin()+j); intervals.insert(intervals.begin()+(i+1),newInterval); return intervals; &#125;&#125;; 58、最后一个单词的长度水题 12345678910111213class Solution &#123;public: int lengthOfLastWord(string s) &#123; s.erase(0, s.find_first_not_of(" ")); //find_ 返回下标 s.erase(s.find_last_not_of(" ")+1); if(s.size()==0) return 0; int index = s.find_last_of(" "); if(index==s.size()) return s.size(); return s.size()-index-1; &#125;&#125;; 59、螺旋矩阵 II模拟题 12345678910111213141516171819202122232425262728class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; generateMatrix(int n) &#123; vector&lt; vector&lt;int&gt; &gt; ans(n, vector&lt;int&gt;(n)); int direct[4][2] = &#123;&#123;0,1&#125;, &#123;1,0&#125;, &#123;0,-1&#125;, &#123;-1,0&#125;&#125;; int direction = 0, row = 0, col = 0, iter; int total_nums = 1, rotal = 0; while(total_nums&lt;=n*n)&#123; iter = n - (2*(rotal/4) + 1); if(direction==0 &amp;&amp; rotal&gt;0)&#123; row += 1; col += 1; &#125; if(n*n==total_nums)&#123; ans[row][col] = total_nums++; break; &#125; for(int i=1; i&lt;=iter; i++)&#123; ans[row][col] = total_nums++; row += direct[direction][0]; col += direct[direction][1]; &#125; rotal += 1; direction = (direction+1)%4; &#125; return ans; &#125;&#125;; 60、第k个排列逆康拓展开的应用, 康拓展开公式为：$$X=a[n]\times(n-1)!+a[n-1]\times(n-2)!+…+a[i]\times(i-1)!+…+a[1]\times0!$$其中 a[n] 代表当前位置之前比自己小的未出现过的数字的个数。例如： 计算34152 的康托展开值为：$$X = 2 \times 4! + 2 \times 3! + 0 \times 2! + 1 \times 1! + 0 \times 0! = 61$$ 123456789101112131415161718192021222324252627282930class Solution &#123;public: string getPermutation(int n, int k) &#123; string ans = ""; int nums[9] = &#123;1, 1, 2, 6, 24, 120, 720, 720*7, 720*56&#125;; bool book[10]; for(int i=0; i&lt;10; i++) book[i] = false; k = k-1; for(int i=n-1; i&gt;=0; i--)&#123; int large_num = k/nums[i]; k %= nums[i]; for(int i=1; i&lt;=n; i++)&#123; if(large_num==0)&#123; for(int j=i; j&lt;=n; j++)&#123; if(book[j]==false)&#123; ans += '0' + j; book[j] = true; break; &#125; &#125; break; &#125; if(book[i]==false) large_num--; &#125; &#125; return ans; &#125;&#125;;]]></content>
      <categories>
        <category>LeetCode</category>
        <category>LeetCode51-60</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[加密流量测量和分析]]></title>
    <url>%2F2019%2F07%2F07%2F%E5%8A%A0%E5%AF%86%E6%B5%81%E9%87%8F%E6%B5%8B%E9%87%8F%E5%92%8C%E5%88%86%E6%9E%90%2F</url>
    <content type="text"><![CDATA[一、加密与非加密流量识别1、利用 信息熵 的方法对加密流量进行识别。 对不同类型的文件，如文本、图片、压缩文件、加密文件等的前 1KB 数据的熵进行计算分析，可以发现文本文件的熵处于较低水平，压缩文件和加密文件的熵处于较高的水平，且两者较难区分。 多元组熵的定义： （1）n元字符组集合指以大小为 n 的滑动窗口对报文序列 P 进行切割后得到的字符串 $s_i (1 \le i \le L-n+1)$ 的集合，L 表示分析报文序列以 字节 为单位的长度：$$S_n = \lbrace s_1, s_2, …, s_{L-n+1} \rbrace$$ 如 “data.dat” 对应的二元字符组集合为 $S_2 = \lbrace da, at, ta, a., .d, da, at \rbrace​$。 （2）从 n 元字符组集合中各元素出现的频率进行考虑，选择 n 元字符组集合中出现频数高于 k 的元素 $s\prime_{i, k}(1 \le i \le m)$ ，并统计其在集合中出现的频数 $f_{i, k}$ ，组成 k 频 n 元字符组集合为：$$S\prime_{n,k} = \lbrace s\prime_{1,k}:f_{1,k} ,\ \ s\prime_{2,k}:f_{2,k},\ \dots \ ,s\prime_{m,k}:f_{m,k}\rbrace$$其中，频数阈值 k 为 [1, L-n+1] 区间内的整数， $m(0 \le m \le n)​$ 表示频数不小于 k 的不重复元素的个数。在上文例子中，若取 $n=2, k=1​$ ，则有 $S\prime_{2,1} = \lbrace da:2,\ at:2,\ ta:1,\ a.:1,\ .d:1\rbrace​$ ; 若取 n=2, k=2, 则有 $S\prime_{2,2} = \lbrace da:2, \ at:2\rbrace​$。 根据以上定义， k 频 n 元字符组集合 $S\prime_{n,k}​$ 的信息熵可以表示为：$$H_{n,k} = -\sum_{i=1}^{m} P(s\prime_{i,k}) log_2P(s\prime_{i,k})$$其中，$P\prime_{i,k} = f_{i,k}/\sum_{t=1}^{m}f_{t,k}​$。 （3）若对长度 n, 频数阈值 k 各取不同的值时，则可以得到一系列关于报文序列 P 的熵值特征，就构成了多元组熵值特征集：$$H = \lbrace H_{n,k} \ \rvert \ n \in[N_a, N_b], k \in [K_a, K_b] \rbrace$$其中，H 中元素(熵值) 的个数为 $(N_b - N_a) \times (K_b - K_a)​$ 。一般地，对 n, k 的取值区间分别定义为 $[1, N] 和 [1, K]​$ 。在上例中，取 N=2, K=2，则序列 “data.dat” 的多元熵值特征集为 $H = \lbrace H_{1,1}\approx1.906, \ H_{1,2}\approx0.835, \ H_{2,1}\approx1.514, H_{2,2}\approx1\rbrace​$。 2、利用 累加和检测 的方法对加密流量进行识别。 多元组熵是以字节为单位的随机性检测，其需要一定数量的数据，计算相对复杂；而累加和检验是以比特位单位的随机性检测，通常只需要较少的数据即可有较好的检验效果，且具有较快的计算速度。 累加和检验有正向和反向两种模式，两个模式的区别仅在于遍历顺序，其中，正向模式下的累加和检测的步骤如下： 将比特序列 $\varepsilon$ 调整为 $(-1, 1)$ 的形式的序列 X。 $X_i = 2\varepsilon_i - 1$ 计算序列 X 的前 k 项和 $S_k$ 计算正向模式下 $\lvert S_k \rvert$ 的最大值 z 计算检验值 P P 的取值一般在 $0\thicksim1$ 之间，其值越大，则待检测序列的随机性越高。通常情况下，设定一个 $\alpha$ 为阈值，当 $P &gt; \alpha$ ，接受检验序列为随机，反之，则拒绝随机性假设。 二、加密流量应用服务识别1、基于选择性集成的特征选择方法 该方法可以克服基于端口和深度包检测方法的不足，但特征属性中包含的冗余和不相关特征会增加模型复杂度、降低模型可信度，导致分类效果和效率同时下降。 算法流程：第一部分，将多个特征选择器选取的特征子集根据评价指标进行排序，再根据选择性集成策略选择部分特征选择器，从已有的特征选择器中将作用不大和性能不好的特征选择器剔除，将保留的特征选择器集成（特征的并集）。第二部分，采用朴素贝叶斯算法评估序列前向搜索（先选择一个最优的特征，再选择一个与其组合起来最优的特征，一直一个个特征往最优特征子集中加，直到判据值 $J$ 降低为结束准则）产生的特征子集，以分类准确率下降为结束准则，再比较多个数据集（同一目的的数据集，只是不同类别的分布状况不一样）的最优特征子集选出全局特征子集，提高特征子集的稳定性。流程如下图： 2、基于加权集成学习的自适应分类方法 针对 DPI 分类方法解析数据包负载内容侵犯隐私，且对加密业务无能为力，促使研究人员转向基于机器学习的流量分类方法。 如果能够准确地识别网络流的变化，就可以及时有效地更新分类器，从而避免仅根据经验设置固定的时间间隔频繁更新分类器。首先，多个集成的分类器根据他们的分类性能设置不同的权重（分类精度高的分类器权值大），然后，根据信息熵检测网络流的变化，一但网络流发生变化，再建立一个分类器，这个新的分类器是用最新的样本训练出来的，之后，用它替换掉原始多个分类器中权值最小的那个。 这样，一方面充分利用先前训练的分类器，另一方面在保留先前训练的分类器的基础上引入当前样本训练的分类器集成，并剔除性能下降的分类器，保证模型集成分类器的泛化能力。 Weka 3: Machine Learning Software in Java 3、non-VPN 和 VPN 加密流量分类方法 TCP 流通常在会话结束时（通过 FIN 数据包） 终止，而 UDP 流由流超时终止。 通过提取 流 中与时间相关的特征来识别 加密和VPN 流量，进行分类。用到的特征如下图： 三、TLS 加密流量分类方法1、基于Markov链的分类 识别SSL/TLS 加密应用，二阶Markov链和HMM 模型分别建立在 SSL/TLS 协议交互的握手过程和数据传输过程（使用握手过程中的报文类型和分组长度，数据传输过程中的数据包长度），然后建立加权集成分类器。每个每类器的权重与当前分类器的分类误差 成反比，具体的：$$MSE_i = \frac{1}{|S_n|} \sum_{(x,c) \in S_n }(1-f_c^i(x))^2$$ $$MSE_r = \sum_c p(c)(1-p(c))^2$$ $$第i个分类器的权重：w_i = MSE_r - MSE_i$$ 2、Tor 行为分析 默认情况下，Tor 服务器生成的证书的颁发者和证书主体都使用随机公共名称，主题 和 发布者 字段是独立生成的，因此彼此不同。主题和发行者字段都不包含证书中常见的（并有证书颁发机构强制要求）的其他信息，例如位置 或 公司名称。这些特征允许通过解析数据集中的 X.509 证书，然后在其 主题 和 颁发者 字段上匹配相应的正则表达式来识别 Tor 连接。 但以这种方式识别 Tor 连接的一个潜在缺陷在于 TLS 会话恢复，其跳过大多数TLS 握手，包括证书交换，用于连接到同一TLS 服务器的连接。但是，Tor 规范声名 Tor 客户端和服务器不能实现会话恢复。 四、HTTPS 加密流量分类方法1、HTTPS 加密流量的识别方法 会话（流）用五元组 (协议、源IP、目的IP、源端口、目的端口) 表示，标签是元组 (OS、浏览器、应用) 。提取特征，训练分类器对其进行识别。 2、HTTPS 协议语义推断 在不解密 HTTPS 流量的情况下，训练分类器识别 HTTPS 流中的某些字段，如状态码、方法、是否含有 Cookie 字段、Content-Type 字段的类型 等等。 3、识别TLS 连接拦截 如网络中间件和防病毒安全产品会对 TLS 连接进行拦截，其在本地客户端和远程服务器中间充当一个中间人。为了识别出是否发生了 TLS 连接拦截，可以通过 Client Hello 消息中宣称的浏览器类型和其中的TLS扩展、密码、椭圆曲线和压缩方法 等生成的指纹是否匹配来识别，因为每个浏览器虽然有不同的客户端类型和版本，但也可以为它们生成特定的指纹库。 当发生了拦截时，可进一步识别出是谁（什么设备）拦截了此TLS 连接，通过为市面上的大量产品生成一个设备指纹库，然后匹配被拦截修改后的 Client Hello 中的版本、密码、扩展、压缩方法、椭圆曲线和签名算法 等生成的指纹和库中的那个设备的指纹相匹配。 通过对 TLS 连接的安全性进行量化后，发现网络中间件或拦截产品降低了原始连接的安全性。 五、加密视频流量参数识别1、对视频 QoE 进行量化评估 1）视频是分块传输的，其中，视频源质量、初始缓冲时延和卡顿时长 是影响用户体验的最重要的外部因素。 视频源质量 sQuality 表示如下：$$sQuality = Qualitymax \times (1-\frac{1}{(1+VB \times VC \times \frac{CP}{VR})^2})$$其中，VC 代表 视频压缩算法，CP 代表 视频源编码等级， VR 代表 视频清晰度， VB 代表 码率， Qualitymax 代表当前清晰度视频源质量评分的最高值，对于清晰度为 4K, 2K, 1080P, 720P 和 360P 的视频，Qualitymax 值分别为 4.9, 4.8, 4.5, 4, 3.6 和 2.8。 2）初始缓冲时延(IBL)是从点击播放 到视频播放的等待时间，初始缓冲时延 sLatency 表示如下： 3）卡顿是指播放过程中缓冲的数据量被消耗完所产生的视频播放停止（与 卡顿时长、次数等相关），卡顿时长占比 sStalling 表示如下： 综合考虑视频源质量、初始缓冲时延和卡顿占比 3 个 KPIs 提出的 vMOS 模型对视频 QoE 进行客观评估，vMoS 表示如下：$$\begin{equation}vMoS =(1-0.092 \times (1+2e^{-sLatency})) \times (5-sLatency) \times sQuality - \0.018 \times (1+2e^{-sStalling}) \times (5-sStalling)\end{equation}$$2、基于视频块特征的视频 QoE 参数识别 SSL/TLS 加密 YouTube 流量识别模块、传输模式识别模块、QoE 参数识别模块以及视频QoE 评估模块。首先，根据 SSL/TLS 协议握手过程中 Client Hello 数据包中的未加密内容识别加密 YouTube 流量；然后，根据视频流的前几个包的特征识别出不同传输模式，在根据视频块统计特征建立分类模式识别视频块的码率和清晰度；最后，根据该视频参数和传输参数计算视频 QoE。 1）在 SSL/TLS 加密 YouTube 流量识别模块中，根据预先建立视频服务器 IP 白名单，过滤出混乱流量中的加密 YouTube 流量。 2）在传输模式识别模块中，当前加密 YouTube 自适应码流传输模式主要有 Apple HLS、MPEG DASH 和 HPD。在同一时间，HPD采用单流传输（视频和音频没有分离），而DASH 和 HLS 采用多条流传输，采用相邻两条流之间的 SYN-ACK 包的到达时间间隔来区分出 HPD 传输模式。 DASH 和 HLS 视频传输都是将视频进行分段后使用基于 TCP 的 HTTPS 流传输的，由于 TCP 的 MSS 所限制，视频片段被分割成大量 1.4KB 左右的数据包传输，而这些数据包响应的都是同一个请求，所以他们的 ACK Number 相同。但是在 DASH 传输模式下，服务器需要先向客户端发送 Initial Segment，Initial Segment 包含了视频解码器所需的初始化信息，然后再开始传输视频数据，在加密数据包中的表现就是经过 SSL/TLS 握手阶段后开始传输的前 P 个 Application data 数据包出现 S 种 ACK Number。可以利用此特征来区分 DASH 和 HLS 视频传输模式，统计发现 DASH 前 三 个数据包的 ACK Number 种类数为 2 或 3 ，而 HLS 和 HPD 的种类数都为 1。 3、加密视频 QoE 评估 影响自适应和经典视频流 QoE 的 3 个关键因素：卡顿、清晰度质量和质量切换。 研究发现，视频片段的大小和到达间隔时间的变化是影响质量的两个重要指标。 六、加密恶意流量识别1、处理数据类别不平衡问题 存在两种方法，一种是过采样：不断将少数类重新采样到训练数据集中的方法；另一种是欠采样：随机消除多数类数据的方法。 2、梯度稀释问题$$\frac{\partial Loss}{\partial \theta} = \sum_{M_i \in M}\sum_{A_{ik} \in M_i}\frac{\partial Loss_{A_{ik}}}{\partial \theta}$$M 代表训练数据集，$M_i$ 代表 M 的第 i 类，$A_{ik}$ 是 $M_i$ 的第 k 个数据， $Loss_{A_{ik}}$ 是数据 $A_{ik}$ 贡献的损失。可以看到参数 $\theta$ 相对于每个类的更新次数取决于每个类的大小。一旦数据的数量严重不同，模型将倾向于偏向多数类，因为总梯度将由多数类在频率方面贡献的梯度所支配。这种现象将导致模型对少数类的不敏感，因为模型很少更新关于少数类的参数。由少数群体贡献的梯度逐渐消失，好像被多数群体所贡献的那样稀释了，这种现象称为 梯度稀释。 3、零样本学习 网络社会中存在各种恶意软件，每天都有许多新的变种，所以不可能手机每个家族的数据样本。为了评估所提出模型的泛化性能，检查***模型识别从未训练过的一些恶意软件的能力，这种场景被创造为机器学习术语中的“零样本学习”。 4、字节分布特征 字节分布是长度为 256 的数组，它保持流中每个数据包的有效负载中遇到的每个字节值的计数。通过将字节分布计数除以在分组的有效载荷中的总字节数，可以容易地计算字节值概率。 完整的字节分布提供了大量有关数据编码的信息。 5、正常企业流量和恶意软件流量中的TLS连接的区别 密码套件。 一般企业流量中提供的密码套件安全性比较高，而恶意软件流量中提供的密码套件安全性低，两者存在比较大的区别。 TLS 扩展。 几乎一半的企业客户端会支持多达 9 个扩展，但恶意客户端只会一致地支持一个。 客户端的公钥长度。 大多数企业流量使用 512 位(ECDHE_RSA) 公钥，恶意软件几乎只使用 2048 位 (DHE_RSA) 公钥。 6、分类恶意 TLS 流量 DNS + HTTP + TLS 三者相关联，提取特征进行分类识别。 用到的特征: 可观察元特征。 包长及时间间隔转移矩阵，字节分布等。 TLS 数据。 密码套件、支持的扩展及公钥长度； 服务器选定的密码套件、支持的扩展、证书数量、有效天数及是否有自签名等。 统计出现的所有种类，然后onehot编码生成一个特征向量。 DNS 数据。 TTL 值、DNS响应中域名的数字字符数、非字母数字字符数、返回的 IP地址的个数、域名是否出现在 Alexa 列表前 100、 前1000、 前10000、 前 100000里等。 HTTP 数据。 Content-Type 、 User-Agent 、Accept-Language 、 Server 和 Code 等。]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTTP2协议解析及抓包分析]]></title>
    <url>%2F2019%2F07%2F05%2FHTTP2%E5%8D%8F%E8%AE%AE%E8%A7%A3%E6%9E%90%E5%8F%8A%E6%8A%93%E5%8C%85%E5%88%86%E6%9E%90%2F</url>
    <content type="text"><![CDATA[一、HTTP2协议简介1、HTTP2的帧格式HTTP2的所有帧都是由一个固定的9字节头部（payload之前）和一个指定长度的负载（payload）组成，如下图所示： 其中，Stream Identifier用作流控制，用31位无符号整数表示。客户端建立的sid必须为奇数，服务端建立的sid必须为偶数，值（0x0）保留给与整个连接相关联的帧（连接控制消息），而不是单个流。 Frame Payload是主体内容，有帧类型决定，HTTP2一共有10种类型的帧： 1234567891011 名称 描述 type值 HEADERS 报头帧 0x1 DATA 数据帧 0x0 PRIORITY 优先级帧 0x2RST_STREAM 流终止帧 0x3 SETTINGS 设置帧 0x4PUSH_PROMISE 推送帧 0x5 PING PING帧 0x6 GOAWAY GOAWAY帧 0x7WINDOW_UPDATE 窗口更新帧 0x8CONTINUATION 延续帧 0x9 实际上，HTTP2并没有改变HTTP1.x的语义，只是把原来HTTP1.x的Header和Body部分用Frame重新封装了一层而已。调试的时候浏览器设置会把HTTP2的Frame自动还原成HTTP1.x的格式。两者的帧格式对比如下图： 2、HTTP2的改进及优点 二进制分帧 帧是客户端和服务端之间通信的最小单位，比起HTTP1.x这样的文本协议，二进制协议解析起来更高效，且没有冗余字段（HTTP1.x 协议每个包都会有重复传输的头部字段），占用带宽少。 多路复用 可以并行交错地发送请求，请求之间互不影响； 可以并行交错地发送响应，响应之间互不干扰； 只使用一个连接即可并行发送多个请求和响应； 消除不必要的延迟，从而减少页面加载的时间； 增加了请求优先级字段，服务器可以根据流的优先级，控制资源分配，而在响应数据准备好之后，将优先级最高的帧发送给客户端。 增加了Header压缩，通信双方各自 cache 一份 header fields表。 增加了服务器推送，服务器可以对一个客户端请求发送多个响应，服务器向客户端推送资源无需客户端明确地请求。服务器推送通过PUSH那些它认为客户端将会需要的内容到客户端的缓存中，避免往返的延迟。比如，请求index.html，但服务器会把style.css, example.png等资源也发送给浏览器。 流量控制，每个HTTP2的流都拥有自己公示的流量窗口，它可以限制另一端发送数据。 二、配置Wireshark抓取HTTP2数据包1、在电脑里创建一个后缀名为 .log 的文件，记住其路径。 2、在电脑的系统变量里创建一个新的变量，名为SSLKEYLOGFILE。配置了此变量后，浏览器会到这里来记录通信过程中密钥。 3、在wireshark中，分析 &gt;&gt; 已解析的协议...中，启用HTTP2的解析。并在 编辑 &gt;&gt; 首选项 &gt;&gt; Protocols &gt;&gt; TLS 中，配置 (Pre)-Master-Secret 为之前创建的log文件，之后，wireshark就可以凭借此文件中的秘钥解密HTTP2中的各个加密字段，便于我们进行协议分析。 三、HTTP2协议数据包解析数据包点击下载 1、从上图可以看到，HTTP2协议的工作流程为：建立TCP连接、建立TLS连接、HTTP2通信，断开TCP连接 四个过程。在Client Hello中，客户端再扩展字段中会说明其所支持的协议，指定ALPN Next Protocol 为 h2 或 HTTP/1.1。之后，服务端在Server Hello中，回复所协商的接下来使用的应用层协议。如下图： 2、在TLS连接过程中，如果服务器支持session ticket，则发送New Session Ticket类型的握手报文，其中包含了能够恢复包括主密钥在内的会话信息。为了不让中间人可见，这个session ticket部分会进行编码、加密等操作，同时，还会指定此ticket的过期时间等。 3、从第一幅图中可以看出，在客户端发送Finished消息（#11）之后，就开始将HTTP封装到Application Data协议中发送给服务器（#12，#13，#14，#15，#16）了，此时，TLS握手还没有完全完成。 HTTP2中基本的协议单位是帧，每个帧都有不同的类型和用途。例如，报头(HEADERS)和数据(DATA)帧组成了基本的HTTP请求和响应；其他帧如设置(SETTINGS)，窗口更新(WINDOW_UPDATE)和推送承诺(PUSH_PROMISE)是用来实现HTTP2的其他功能。 4、（#12）帧分析：在HTTP2请求创建连接发送SETTINGS帧初始化之前有一个Magic帧，为建立HTTP2请求的前言(connection preface)，此前言作为对所使用协议的最终确认，并确定HTTP2连接的初始设置。在发送完前言后，双方都得向对方发送带有ACK标识的SETTINGS帧标识确认，对应图中的#21 和 #22 号帧： 12号帧，组合了Magic、SETTINGS和WINDOW_UPDATE三种帧为一个数据包，其中包含的参数如下图： WINDOW_UPDATE中的stream identifier为0表示此窗口更新帧作用于整个连接，指定其他具体值可使其作用于某个特定的单独连接。 5、（#13）号帧分析，客户端在发送完连接前言后，可立即跟上一个请求(request)。这里客户端向服务器发送GET /HEADERS，HEADERS帧用来打开一个流或携带一个首部块片段，此HEADERS帧包括了请求行和请求头的内容，属于1 号流： 其中，Exclusive：一个比特位声明流的依赖性是否是排它的，这里为 1，代表此流不依赖其他的流。Weight：代表当前流的优先级权重。End Headers：这里为 1 代表header块结束。Priority设置为 1，代表存在Exclusive、Stream Dependency 和 Weight。 6、(#19) 号包分析，服务器向客户端发送SETTINGS 和 WINDOW_UPDATE 帧，SETTINGS帧为连接前言 (connection preface)，帧中设置了最大并行流数量、初始窗口大小、最大帧长度，WINDOW_UPDATE 给出扩大窗口的大小。这两个帧属于 0 号流。 7、DATA 帧，服务器向客户端发送DATA帧，即响应主体。DATA 帧用来装填主体信息，可以用一个或多个DATA 帧来返回一个请求的响应主体。 上图左边为HEADERS帧，服务器向客户端返回响应(response)，此报头帧包含了状态行和响应头的内容，此帧属于 3 号流。 Status: 200 OK 表示状态码为 200，客户端请求成功。此外，响应头还给出了服务器所使用的的服务器型号、内容类型等。注意观察图中的标志位 End Stream 和 End Headers 的变化。]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IPSec VPN搭建及协议解析]]></title>
    <url>%2F2019%2F07%2F02%2FIPSec-VPN%E6%90%AD%E5%BB%BA%E5%8F%8A%E5%8D%8F%E8%AE%AE%E8%A7%A3%E6%9E%90%2F</url>
    <content type="text"><![CDATA[一、IPSec协议简介IPSec是IETF制定的为保证在Internet上传送数据的安全保密性能的三层隧道加密协议。IPSec是应用于IP层上网络数据安全的一整套体系结构，他包括报文首部认证协议（ Authentication Header, AH）、封装安全载荷协议(Encapsulating Security Payload, ESP)、互联网间密钥交换协议(Internet Key Exchange, IKE) 和一些用于网络认证及加密的算法等。IPSec协议本身定义了如何在IP数据包中增加字段来保证IP包的完整性、私有性和真实性，以及如何加密数据包。 IPSec有传输(transport)和隧道(tunnel)两种工作方式，其中，传输模式适用于主机之间建立IPSec安全传输，隧道模式更适合网关之间的通信，常用来实现虚拟专用网VPN。 二、IPSec-VPN搭建详细教程请参考：https://github.com/hwdsl2/setup-ipsec-vpn/blob/master/README-zh.md 以 Ubuntu 16.04为例，首先执行： 1wget https://git.io/vpnsetup -O vpnsetup.sh 之后，在vpnsetup.sh文件中，设置YOUR_IPSEC_PSK, YOUR_USERNAME 和 YOUR_PASSWORD三个字段，如下图： 最后，通过命令 sudo sh vpnsetup.sh 启动服务器的 ipsec vpn服务。接下来，就是客户端的配置，以安卓手机为例： 选择对应的 VPN 添加类型，其中IPSec Xauth 类型也称 Cisco IPsec 模式，更加高效一些。填写好服务器地址、预共享密钥(PSK) 、用户名和密码后，即可使用该 VPN，如果服务器在香港或国外的话，即可实现翻墙的功能。 三、IPSec协议解析IPSec主要包括两部分协议，分别是 ISAKMP 协议和 ESP协议，可使用wireshark采集以上两种协议的报文。 (1) ISAKMP协议 第一阶段，通信双方彼此间建立一个已通过身份认证和安全保护的通道，即建立一个ISAKMP SA。第一阶段有主模式（Main Mode）和野蛮模式（Aggressive Mode）两种IKE交换方法。 第二阶段，使用在第一阶段建立的安全隧道为IPsec协商安全服务，即为IPsec协商具体的SA，建立用于最终的IP数据安全传输的IPsec SA。 第一阶段的主模式交换过程： 对应的数据包为点我下载： 消息①和②用于策略交换（包为明文） 发起方发送一个或多个IKE安全提议，响应方查找最先匹配的IKE安全提议，并将这个IKE安全提议回应给发起方。匹配的原则为协商双方具有相同的加密算法、认证算法、认证方法和Diffie-Hellman组标识。 消息③和④用于密钥信息交换（包为明文） 双方交换Diffie-Hellman公共值和nonce值，用于IKE SA的认证和加密密钥在这个阶段产生。 消息⑤和⑥用于身份和认证信息交换（包为密文） 双方使用生成的密钥发送信息，双方进行身份认证和对整个主模式交换内容的认证。 第二阶段的IPSEC SA协商: 上图中的 8、9、10 号包使用快速模式，进行IPSec SA的协商。 最后的 11、12、13、14号数据包为断开连接。 (2) ESP协议 因为 IPSec协议要求通信双方建立单工的安全联盟，所以两个SPI 分别标识了两个方向的通信报文。 四、IPSec穿越NATIPSec VPN中标准身份标识是IP地址，NAT处理过程中会改变IP地址，因此IPSec的身份确认机制必须能够适应IP地址变化。IPSec的身份确认最常见是通过IKE协议代劳，IKE支持的身份认证机制有两种: 数字证书方式，通过CA数字证书体系确认身份，是最为安全、可靠的方式。 身份标识+预共享密钥方式，通过发起方和响应方预先配置相同的密钥，完成双方对彼此身份的认证，这是最为常见的方式。在预共享秘密钥认证机制中，身份标识则可以分为几类： 指定IP地址，使用IP地址作为身份标识，是IKE的默认方式，响应方只允许指定IP地址发起协商，安全性比较高。 指定IP地址范围，这种方式依然使用IP地址作为身份标识，由于发起方必须要指定IP地址，否则无法发起协商，指定IP地址范围是响应方特性，如响应方可以指定2.0.0.0/8范围内的地址都可以发起协商，而不是只允许2.1.1.2发起协商，能够减少配置，但安全性略有下降。 什么都不指定，也是使用IP地址作为身份标识，但允许任意IP地址发起协商，只要预共享密钥一致，双方就能够通过身份确认，这种方式虽然不是非常安全，但是可以简化配置，安全性再次下降； 指定对端名字，发起方和响应方都预先配置好本端名字，使用该名字作为身份标识，与指定IP地址类似，通过指定对端名字方式，即使双方预共享密钥一致，只要对端名字不合法，立即中断协商，由于名字未与IP地址进行绑定，而且名字在网络中明文传递，故安全性不如指定IP地址方式高，但这种身份标识方式可以穿NAT。 具体过程如下： 1、开启NAT穿越时，协商第一阶段的前两个消息会发送标识NAT穿越（NAT Traversal，简称NAT-T）能力的Vendor ID载荷。用于检查通信双方是否支持NAT-T。 当双方都在各自的消息中包含了该载荷时，才会进行相关的NAT-T协商。 2、主模式消息3和消息4中发送NAT-D（NAT Discovery）载荷。NAT-D载荷用于探测两个要建立IPSec隧道的网关之间是否存在NAT网关以及NAT网关的位置。 通过协商双方向对端发送源和目的的IP地址与端口的Hash值，就可以检测到地址和端口在传输过程中是否发生变化。若果协商双方计算出来的Hash值与它收到的Hash值一样，则表示它们之间没有NAT。否则，则说明传输过程中对IP或端口进行了NAT转换。 第一个NAT-D载荷为对端IP和端口的Hash值，第二个NAT-D载荷为本端IP和端口的Hash值。 3、发现NAT网关后，后续ISAKMP消息的端口号转换为4500。ISAKMP报文标识了“Non-ESP Marker”。 4、在第二阶段会启用NAT穿越协商。在IKE中增加了两种IPSec报文封装模式：UDP封装隧道模式报文（UDP-Encapsulated-Tunnel）和UDP封装传输模式报文（UDP-Encapsulated-Transport）。通过为ESP报文封装UDP头，当封装后的报文通过NAT设备时，NAT设备对该报文的外层IP头和增加的UDP头进行地址和端口号转换。UDP报文端口号修改为4500。 五、IPSec协议流量特征分析 在上图 4.14 (a) 中，IPSec流量与原始流量几乎完全重合，这符合ESP协议的特性，即一一对应，一条ESP报文封装一条原始报文，然后进行转发。折线的重合说明IPSec不会对原始流量进行分片等操作，且自身不会产生大量与传输内容无关的流量，它在得到一条原始报文后，仅对其进行加密并加上IPSec头部，然后忠实地发送到目的地。 在上图 4.14 (b) 中，IPSec流量与原始流量基本重合，但是IPSec流量的字节数到达速率在每个峰值处均比原始流量高。这说明IPSec每条报文的大小都要大于原始报文，这符合IPSec协议的封装特征。加密与完整性保护会产生额外的数据开销，同时无论在隧道模式还是传输模式下，IPSec协议都会对报文进行重新封装，再加上额外的头部，使得讲IPSec处理后的报文数据量大于原始报文。 在上图 4.15 (a) 中，不论是IPSec流量还是原始流量，其报文大小分布都是U形，即报文大小多集中在0--200字节与1400--1500字节之间，尤其是1400--1500的部分，而200--1400字节的报文数量明显较少。U形分布原因有以下几点：1、有大量数据正在传输；2、网络状况理想，TCP链路极少堵塞，可以持续以较大的发送窗口传输数据；3、左边部分为大量的ACK报文与相关协议的控制报文，以及数据量较小的报文。然后再对比IPSec流量与原始流量，可以观察到其报文大小分布模式及其相似，原始流量相较IPSec流量整体左偏，说明原始流量的报文教IPSec流量较小，这和折线图的结论一致。 在上图 4.15 (b) 中，可以看到横坐标的报文到达时间间隔范围较大。这与流量采集的方法与环境相关，偶发性的网络阻塞，可能瞬间将报文到达时间间隔提升到千毫秒级。当然，还有很多原因会导致报文到达时间间隔发生异常，因此，报文到达时间间隔时间是一种很不稳定的特征。从图中还可以看到，大部分的到达间隔时间极小，且IPSec流量和原始流量的到达间隔时间分布及其相似。]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode41-50]]></title>
    <url>%2F2019%2F05%2F09%2FLeetCode41-50%2F</url>
    <content type="text"><![CDATA[41、缺失的第一个正数数组中元素互换，让元素大小与下标相对应。数值小于0或者大于数组长度的元素值，直接略过，之后遍历整个数组，第一次出现数值和下标不相等的位置就是ans，如果全部满足，返回数组长度即可。 1234567891011121314151617class Solution &#123;public: int firstMissingPositive(vector&lt;int&gt;&amp; nums) &#123; nums.push_back(-1); // 添加一个无用元素，方便后续操作 for(int i=0; i&lt;nums.size(); i++)&#123; if( nums[i]&lt;0 || nums[i]&gt;=nums.size() || nums[nums[i]]==nums[i] ) continue; swap(nums[nums[i]], nums[i]); i--; &#125; for(int i=1; i&lt;nums.size(); i++)&#123; // i 从 1 开始，保证正整数 if( nums[i]!=i ) return i; &#125; return nums.size(); &#125;&#125;; 42、接雨水先找到全局最高的那个柱子，然后从两边往最高柱靠近，靠近过程中不断更新当前最高柱，并根据当前最高柱的值来计算当前遍历点能够接雨水的量。 123456789101112131415161718192021222324252627282930class Solution &#123;public: int trap(vector&lt;int&gt;&amp; height) &#123; if(height.size()==0) return 0; int ans = 0; int max_index = 0; for(int i=1; i&lt;height.size(); i++)&#123; if( height[max_index]&lt;height[i] ) max_index = i; &#125; int cur_max = height[0]; for(int i=1; i&lt;max_index; i++)&#123; if( height[i]&gt;=cur_max )&#123; cur_max = height[i]; continue; &#125; ans += cur_max - height[i]; &#125; cur_max = height[height.size()-1]; for(int i=height.size()-2; i&gt;max_index; i--)&#123; if( height[i]&gt;=cur_max )&#123; cur_max = height[i]; continue; &#125; ans += cur_max - height[i]; &#125; return ans; &#125;&#125;; 43、字符串相乘模拟题，使用字符串模拟乘法运算即可。 123456789101112131415161718192021222324252627282930313233343536373839404142434445class Solution &#123;public: string multiply(string num1, string num2) &#123; string ans, cur_multi; int multiplier, product_step; for(int i=num2.size()-1; i&gt;=0; i--)&#123; cur_multi = num1; multiplier = num2[i] - '0'; product_step = 0; for(int j=cur_multi.size()-1; j&gt;=0; j--)&#123; product_step += (cur_multi[j]-'0')*multiplier; cur_multi[j] = product_step%10 + '0'; product_step /= 10; &#125; if(product_step) cur_multi.insert(cur_multi.begin(), product_step+'0'); for(int j=0; j&lt;num2.size()-1-i; j++) cur_multi += "0"; // 计算 cur_multi + ans int m=0, n=0, sum=0; for(m=ans.size()-1, n=cur_multi.size()-1; m&gt;=0&amp;&amp;n&gt;=0; m--,n--)&#123; sum += (ans[m]-'0') + (cur_multi[n]-'0'); ans[m] = sum%10 + '0'; sum /= 10; &#125; while(m&gt;=0)&#123; sum += (ans[m]-'0'); ans[m] = sum%10 + '0'; sum /= 10; m--; &#125; while(n&gt;=0)&#123; sum += (cur_multi[n]-'0'); ans.insert(ans.begin(), sum%10+'0'); sum /= 10; n--; &#125; if(sum) ans.insert(ans.begin(), sum+'0'); &#125; while(ans.size()&gt;0 &amp;&amp; ans[0]=='0') //过滤前导 0 ans.erase(ans.begin()); return ans.size()==0? "0" : ans; &#125;&#125;; 44、通配符匹配dp 题，写出状态转移方程即可。根据 * 号考虑各种情况。 1234567891011121314151617181920class Solution &#123;public: bool isMatch(string s, string p) &#123; int lenS = s.length(), lenP = p.length(); bool match[lenS+1][lenP+1] = &#123;true&#125;; for(int i=1; i&lt;=lenS; i++) match[i][0] = false; for(int i=1; i&lt;=lenP; i++) match[0][i] = p[i-1]=='*' &amp;&amp; match[0][i-1]; for(int i=1; i&lt;=lenS; i++)&#123; for(int j=1; j&lt;=lenP; j++)&#123; if( p[j-1]=='*' ) match[i][j] = match[i][j-1] || match[i-1][j]; //匹配 0 个或多个 else match[i][j] = (s[i-1]==p[j-1] || p[j-1]=='?') &amp;&amp; match[i-1][j-1]; &#125; &#125; return match[lenS][lenP]; &#125;&#125;; 45、跳跃游戏 II贪心题，每次选择下次跳的最远的位置。 123456789101112131415161718192021class Solution &#123;public: int jump(vector&lt;int&gt;&amp; nums) &#123; int pos = 0, ans = 0; while(pos &lt; nums.size()-1)&#123; int max_step = -1, max_index = -1; for(int i=1; i&lt;=nums[pos]; i++)&#123; if(pos+i==nums.size()-1) return ans+1; if(max_step &lt;= i+nums[pos+i])&#123; max_step = i + nums[pos+i]; max_index = i; &#125; &#125; ans++; pos = pos + max_index; //cout &lt;&lt; max_index &lt;&lt; " " &lt;&lt; pos &lt;&lt; endl; &#125; return ans; &#125;&#125;; 46、全排列直接上 next_permutation 库函数。 1234567891011class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; permute(vector&lt;int&gt;&amp; nums) &#123; vector&lt; vector&lt;int&gt; &gt; ans; sort(nums.begin(), nums.end()); do&#123; ans.push_back(nums); &#125;while(next_permutation(nums.begin(), nums.end())); return ans; &#125;&#125;; 47、全排列 II之所以出现重复是因为相同的元素的排列导致的，DFS 实现全排列并去重。 1234567891011121314151617181920212223242526class Solution &#123;public: vector&lt; vector&lt;int&gt; &gt; ans; void DFS(vector&lt;int&gt;&amp; nums, vector&lt;bool&gt;&amp; book, vector&lt;int&gt;&amp; temp_ans)&#123; if(nums.size() == temp_ans.size())&#123; ans.push_back(temp_ans); return ; &#125; for(int i=0; i&lt;nums.size(); i++)&#123; if(book[i]==true) continue; if(i&gt;0 &amp;&amp; nums[i-1]==nums[i] &amp;&amp; book[i-1]==false) continue; book[i] = true; temp_ans.push_back(nums[i]); DFS(nums, book, temp_ans); temp_ans.pop_back(); book[i] = false; &#125; &#125; vector&lt;vector&lt;int&gt;&gt; permuteUnique(vector&lt;int&gt;&amp; nums) &#123; sort(nums.begin(), nums.end()); vector&lt;bool&gt; book(nums.size(), false); vector&lt;int&gt; temp_ans; DFS(nums, book, temp_ans); return ans; &#125;&#125;; 48、旋转图像模拟题，计算好对应的位置即可。 1234567891011121314151617181920212223class Solution &#123;public: void rotate(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) &#123; int len = matrix[0].size(); for(int row=0; row&lt;len/2; row++)&#123; for(int col=row; col&lt;len-1-row; col++)&#123; int tmp_val = matrix[row][col]; int row1 = row, col1 = col; matrix[row1][col1] = matrix[len-1-col1][row1]; int row2 = len-1-col1, col2 = row1; matrix[row2][col2] = matrix[len-1-col2][row2]; int row3 = len-1-col2, col3 = row2; matrix[row3][col3] = matrix[len-1-col3][row3]; int row4 = len-1-col3, col4 = row3; matrix[row4][col4] = tmp_val; &#125; &#125; &#125;&#125;; 49、字母异位词分组水题，直接用 map 或者 sort 后使用 vector都可以。 123456789101112131415161718192021222324252627282930313233class Solution &#123;public: static bool compare(string s1, string s2)&#123; sort(s1.begin(), s1.end()); sort(s2.begin(), s2.end()); return s1 &lt; s2; &#125; vector&lt;vector&lt;string&gt;&gt; groupAnagrams(vector&lt;string&gt;&amp; strs) &#123; vector&lt;string&gt; tmp_ans; vector&lt; vector&lt;string&gt; &gt; ans; sort(strs.begin(), strs.end(), compare); for(auto str : strs)&#123; if(tmp_ans.size()==0)&#123; tmp_ans.push_back(str); continue; &#125; string s1 = tmp_ans.back(); string s2 = str; sort(s1.begin(), s1.end()); sort(s2.begin(), s2.end()); if( s1!=s2 )&#123; ans.push_back(tmp_ans); tmp_ans.clear(); tmp_ans.push_back(str); &#125; else tmp_ans.push_back(str); &#125; if(tmp_ans.size()&gt;=1) ans.push_back(tmp_ans); return ans; &#125;&#125;; 50、Pow(x, n)快速幂 123456789101112131415class Solution &#123;public: double myPow(double x, int n) &#123; int flag = n&gt;=0? 1 : -1; long long N = (long long)(flag)*(long long)(n); double ans = 1; while(N)&#123; if(N%2) ans *= x; x *= x; N /= 2; &#125; return flag==-1? 1.0/ans : ans; &#125;&#125;;]]></content>
      <categories>
        <category>LeetCode</category>
        <category>LeetCode41-50</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode31-40]]></title>
    <url>%2F2019%2F05%2F09%2FLeetCode31-40%2F</url>
    <content type="text"><![CDATA[31、下一个排列偷个懒，直接使用库函数next_permutation。 123456class Solution &#123;public: void nextPermutation(vector&lt;int&gt;&amp; nums) &#123; next_permutation(nums.begin(), nums.end()); &#125;&#125;; 32、最长有效括号用栈进行括号匹配消除，在消除过程中记录最大长度值。 123456789101112131415161718class Solution &#123;public: int longestValidParentheses(string s) &#123; int ans = 0; stack&lt; pair&lt;char, int&gt; &gt; st; st.push(make_pair('#', -1)); for(int i=0; i&lt;s.length(); i++)&#123; if( st.top().first=='(' &amp;&amp; s[i]==')' )&#123; st.pop(); ans = max(ans, i-st.top().second); &#125; else&#123; st.push(make_pair(s[i], i)); &#125; &#125; return ans; &#125;&#125;; 33、搜索旋转排序数组变形的二分搜索，关键点一：判断mid到底位于数组的前半段还是后半段；关键点二：判断下一步的搜索方向。 123456789101112131415161718192021222324252627282930313233343536373839class Solution &#123;public: int search(vector&lt;int&gt;&amp; nums, int target) &#123; int l = 0, r = nums.size()-1, mid; while(l&lt;=r)&#123; mid = (l+r)&gt;&gt;1; if( nums[mid] &gt;= nums[l] )&#123; //落在左边 if( target &gt; nums[mid] ) l = mid + 1; else if( target &lt; nums[mid] )&#123; if( target&gt;nums[l] ) r = mid - 1; else if( target&lt;nums[l] ) l = mid + 1; else return l; &#125; else return mid; &#125; else if( nums[mid] &lt;= nums[r] )&#123; //落在右边 if( target &lt; nums[mid] ) r = mid - 1; else if( target &gt; nums[mid] )&#123; if( target&lt;nums[r] ) l = mid + 1; else if( target&gt;nums[r] ) r = mid - 1; else return r; &#125; else return mid; &#125; &#125; return -1; &#125;&#125;; 34、在排序数组中查找元素的第一个和最后一个位置使用模板库里的二分查找函数，lower_bound查找第一个大于或等于某个元素的位置，upper_bound查找第一个大于某个元素的位置。 1234567891011class Solution &#123;public: vector&lt;int&gt; searchRange(vector&lt;int&gt;&amp; nums, int target) &#123; int l = lower_bound(nums.begin(), nums.end(), target) - nums.begin(); int r = upper_bound(nums.begin(), nums.end(), target) - nums.begin(); vector&lt;int&gt; ans&#123;l,r-1&#125;; if(l==r) ans[0] = ans[1] = -1; return ans; &#125;&#125;; 35、搜索插入位置同样偷懒使用库提供的二分查找函数lower_bound。 123456class Solution &#123;public: int searchInsert(vector&lt;int&gt;&amp; nums, int target) &#123; return lower_bound(nums.begin(), nums.end(), target) - nums.begin(); &#125;&#125;; 36、有效的数独搞个book数组记录，然后直接暴力循环判断就行了。 1234567891011121314151617181920212223class Solution &#123;public: bool isValidSudoku(vector&lt;vector&lt;char&gt;&gt;&amp; board) &#123; bool book_row[9][9], book_col[9][9], book_cell[9][9]; memset(book_row, 0, sizeof(book_row)); memset(book_col, 0, sizeof(book_col)); memset(book_cell, 0, sizeof(book_cell)); int num; for(int i=0; i&lt;9; i++)&#123; for(int j=0; j&lt;9; j++)&#123; if(board[i][j]=='.') continue; num = board[i][j] - '0' - 1; if(book_row[i][num] || book_col[j][num] || book_cell[i/3*3+j/3][num]) return false; book_row[i][num] = true; book_col[j][num] = true; book_cell[i/3*3+j/3][num] = true; &#125; &#125; return true; &#125;&#125;; 37、解数独深搜入门题，注意期间的剪枝操作。 123456789101112131415161718192021222324252627282930313233343536373839404142434445class Solution &#123;private: bool book_row[9][9]; bool book_col[9][9]; bool book_cell[9][9];public: bool mySolve(vector&lt; vector&lt;char&gt; &gt;&amp; board, int position)&#123; if( position==81 ) return true; int row = position/9; int col = position%9; if(board[row][col]!='.') return mySolve(board, position+1); for(int i=0; i&lt;9; i++)&#123; if( !book_row[row][i] &amp;&amp; !book_col[col][i] &amp;&amp; !book_cell[row/3*3+col/3][i] )&#123; board[row][col] = '1'+i; book_row[row][i] = true; book_col[col][i] = true; book_cell[row/3*3+col/3][i] = true; if(!mySolve(board, position+1))&#123; board[row][col] = '.'; book_row[row][i] = false; book_col[col][i] = false; book_cell[row/3*3+col/3][i] = false; &#125; else return true; //唯一解 &#125; &#125; return false; &#125; void solveSudoku(vector&lt;vector&lt;char&gt;&gt;&amp; board) &#123; for(int i=0; i&lt;9; i++)&#123; for(int j=0; j&lt;9; j++)&#123; if( board[i][j]!='.' )&#123; int num = board[i][j] - '0' - 1; book_row[i][num] = true; book_col[j][num] = true; book_cell[i/3*3+j/3][num] = true; &#125; &#125; &#125; mySolve(board, 0); &#125;&#125;; 38、报数模拟题 1234567891011121314151617181920212223class Solution &#123;public: string countAndSay(int n) &#123; string ans = "1"; for(int step=1; step&lt;n; step++)&#123; string tmp_ans; int sum = 1; char ch = ans[0]; for(int i=1; i&lt;ans.size(); i++)&#123; if( ch == ans[i] )&#123; sum++; continue; &#125; tmp_ans += (to_string(sum) + ch); ch = ans[i]; sum = 1; &#125; tmp_ans += (to_string(sum) + ch); ans = tmp_ans; &#125; return ans; &#125;&#125;; 39、组合总和深搜入门题，注意期间的剪枝操作。 123456789101112131415161718192021222324class Solution &#123;private: vector&lt; vector&lt;int&gt; &gt; ans;public: void DFS(vector&lt;int&gt;&amp; candidates, int target, int position, vector&lt;int&gt;&amp; tmp_ans)&#123; if(target==0)&#123; ans.push_back(tmp_ans); return ; &#125; for(int i=position; i&lt;candidates.size(); i++)&#123; if( target&gt;=candidates[i] )&#123; //一个小剪枝 tmp_ans.push_back(candidates[i]); DFS(candidates, target-candidates[i], i, tmp_ans); tmp_ans.pop_back(); &#125; &#125; &#125; vector&lt;vector&lt;int&gt;&gt; combinationSum(vector&lt;int&gt;&amp; candidates, int target) &#123; sort(candidates.begin(), candidates.end()); // 排序为了后期剪枝用 vector&lt;int&gt; tmp_ans; DFS(candidates, target, 0, tmp_ans); return ans; &#125;&#125;; 40、组合总和 II在39题的基础上稍微改一下即可，一是13行的禁止元素重复使用，二是15行的去重操作。 123456789101112131415161718192021222324252627class Solution &#123;private: vector&lt; vector&lt;int&gt; &gt; ans;public: void DFS(vector&lt;int&gt;&amp; candidates, int target, int position, vector&lt;int&gt;&amp; tmp_ans)&#123; if(target==0)&#123; ans.push_back(tmp_ans); return ; &#125; for(int i=position; i&lt;candidates.size(); i++)&#123; if( target&gt;=candidates[i] )&#123; //一个小剪枝 tmp_ans.push_back(candidates[i]); DFS(candidates, target-candidates[i], i+1, tmp_ans); tmp_ans.pop_back(); while(i+1&lt;candidates.size() &amp;&amp; candidates[i+1]==candidates[i]) // 去重操作 i++; &#125; &#125; &#125; vector&lt;vector&lt;int&gt;&gt; combinationSum2(vector&lt;int&gt;&amp; candidates, int target) &#123; sort(candidates.begin(), candidates.end()); // 排序为了后期剪枝用 vector&lt;int&gt; tmp_ans; ans.clear(); DFS(candidates, target, 0, tmp_ans); return ans; &#125;&#125;;]]></content>
      <categories>
        <category>LeetCode</category>
        <category>LeetCode31-40</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[双仓库部署实现博客访问加速]]></title>
    <url>%2F2019%2F04%2F22%2F%E5%8F%8C%E4%BB%93%E5%BA%93%E9%83%A8%E7%BD%B2%E5%AE%9E%E7%8E%B0%E5%8D%9A%E5%AE%A2%E8%AE%BF%E9%97%AE%E5%8A%A0%E9%80%9F%2F</url>
    <content type="text"><![CDATA[博客停更了将近半年的时间，然后近期闲着打算接着写写记录下日常学习过程，其中被同学吐槽，你这访问太慢了啊，页面好大会转不出来，怎么回事小老弟？github pages国内访问的话，速度还是很慢的，想要更好的提升访问速度，得将博客迁移到国内才行，幸运的是，国内的coding.net也提供pages服务。下面，我们主要讲解如何实现个人博客的双仓库部署。 1、注册 coding 账号，创建一个和注册名一样的仓库，部署公钥，此处部署的公钥一定要和github pages上的公钥一致。运行 ssh -T git@git.coding.net 指令，测试公钥是否添加成功，如下图所示，代表成功添加了公钥。 2、deploy部署配置，更改本地 根目录下的_config.yml文件，如下图，这样才可以实现两个仓库的同步推送。 配置完成后，hexo clean; hexo g -d 将博客内容同步到两个仓库，在 coding.net中记得同步完成后开启pages 服务，此时便可以访问地址 localdomain.coding.net来浏览博客内容了。 3、Pages 服务 &gt;&gt; 设置中，绑定个人域名。我对此步骤的理解是，因为后期要将自己个人域名的CNAME指向这里，所以要绑定一下个人域名来实现验证的效果，如果没有验证的话，任何人买个域名，然后设置CNAME指向这里，就可以通过其他人的域名肆意访问我的资源了，这是不能容忍的。通过绑定机制，属于我的资源我可以控制通过哪些域名可以来访问。 4、之前在 阿里云 买的域名， 设置域名解析如图： 当在国内访问 www.wangjibao.com.cn时，会解析国内的localdomain.coding.net，这样速度比较快。 无论在国内还是国外访问wangjibao.com.cn时，会直接返回185.199.111.153的github.io的地址，虽然速度可能有些慢，但这样实现了无论加不加www的头都可以访问博客的目的。 当在国外访问www.wangjibao.com.cn时，会解析国外的wangjibao.github.io的地址，对外国人来说的话， 速度也不慢。 5、上图中的 nslookup印证了我们的想法，接下来使用站长之家的网站测速功能，查看改造前与改造后的访问速度效果图，如下： 看着就舒坦啊，要想生活过得去，就需要来点绿。穷X一枚，等后期有空看看能不能通过免费的CDN再加速一波。]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ubuntu个性美化]]></title>
    <url>%2F2019%2F04%2F20%2FUbuntu%E4%B8%AA%E6%80%A7%E7%BE%8E%E5%8C%96%2F</url>
    <content type="text"><![CDATA[1、安装VMware Tools 在VMware中安装虚拟机后，记得安装VMware Tools。在虚拟机中找到名为VMwareTools…tar.gz的压缩包（一般在media文件夹中），复制到某个文件夹中后执行：tar -xvzf VMwareTools…tar.gz进行解压。之后会看到一个 ./vmware-install.pl的执行程序，执行后安装，一路默认即可，安装完成后，重启虚拟机。 2、卸载自带软件 123dpkg --list # 查看自带已安装程序sudo apt-get --purge remove &lt;programname&gt; # 卸载程序和所有配置文件sudo apt-get remove &lt;programname&gt; # 只卸载程序 当然也可以在软件管理中进行查看已安装软件，卸载软件等操作。 3、GTK,GTK+,Qt, KDE,GNOME, Unity的区别与联系 Linux本身没有图形界面，Linux现在的图形界面系统只是Linux下的应用程序。 GTK, GTK+, Qt是图形界面开发库(GUI Toolkit)，用户可以使用这些开发库编写GUI应用。 KDE，GNOME，Unity是linux下的桌面环境(Desktop Environment)，其中KDE使用Qt开发，GNOME使用GTK+开发，Unity是基于GNOME开发的一个桌面环境。 从 Ubuntu 16.04 LTS 到Ubuntu 18.04 LTS 最显著的变化是 Unity 用户界面被替换为了GNOME 桌面环境。 4、安装美化主题 参考博客，本文用到的主题工具包下载 美化过程中涉及的两个目录：/usr/share/themes 和 /usr/share/icons。 1）安装 TweakTool 工具： 123sudo apt-get updatesudo apt-get install gnome-tweak-toolsudo apt-get install gnome-shell-extensions # 解决Tweaks中shell无法设置的问题 2）安装GTK主题，修改图标，更改桌面shell，下载网址，将主题和桌面shell放到/usr/share/themes/目录下，图标包放到/usr/share/icons/文件夹下，之后在Tweaks工具中，即可选择使用它们 效果图如下： 3）更改开机动画，下载网址 1234将下载的开机动画解压并拷贝到： usr/share/plymouth/themessudo update-alternatives --install /usr/share/plymouth/themes/default.plymouth default.plymouth /usr/share/plymouth/themes/***/***.plymouth 100sudo update-alternatives --config default.plymouth # 选择对应序号即可，*号代表当前使用sudo update-initramfs -u 4）更改登录界面的背景（也可只修改css文件中对应的图片链接即可） 12345cp 下载的登录界面.jpg /usr/share/backgrounds/# 备份自带登录css文件cp /usr/share/gnome-shell/theme/ubuntu.css /usr/share/gnome-shell/theme/ubuntu.css.bakcp 下载的并更名为ubuntu.css的文件 /usr/share/gnome-shell/theme/reboot 效果图： 4）修改桌面shell的宽度和字体等。]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ubuntu官方源和PPA源简介]]></title>
    <url>%2F2019%2F04%2F20%2FUbuntu%E5%AE%98%E6%96%B9%E6%BA%90%E5%92%8CPPA%E6%BA%90%E7%AE%80%E4%BB%8B%2F</url>
    <content type="text"><![CDATA[在ubuntu中，软件的安装主要有3种方式： 通过apt包管理工具从官方软件源安装 通过deb格式的软件包安装，以安装搜狗输入法为例： 1234下载 sogou.debsudo dpkg -i sogou.deb #出现安装不成功，需要依赖sudo apt-get install -f #安装依赖sudo dpkg -i sogou.deb 使用软件的源码手动编译安装 下面我们主要介绍第一种安装方式，即apt命令从软件源安装。软件源分为 Ubuntu官方软件源 和 PPA软件源 两种。 1）Ubuntu 官方软件源，其中包含了系统中绝大多数的软件，对应的目录为 /etc/apt/sources.list，如下所示： 一般情况下，我们会将其改成国内的镜像源，因为访问国外的资源太慢了，国内开源镜像站点汇总。 安装和卸载软件也非常的简单： 12sudo apt-get install &lt;package-name&gt; # 安装sudo apt-get remove &lt;package-name&gt; # 卸载 每当通过 install 命令去安装一个软件时，apt 包管理工具就会从系统中的/etc/apt/sources.list文件或/etc/apt/sources.list.d文件夹中去读取软件源的网址信息，查找可以包含该软件的软件源的网址，然后就从这个网址上把指定的软件给下载下来，然后由 apt 包管理工具在本地进行一些解压和安装的其他操作。 2）PPA(Personal Package Archives)个人软件包集，它出现的原因是：系统自带的源是非常有限的 ，如果通过deb直接安装其他软件的话，得不到更新和维护，所以此时PPA软件源就应运而生。它其实是一个网站，开发者们在上面建立自己的仓库，上传开发的软件供用户安装。 12sudo add-apt-repository ppa:user/ppa-name # 添加ppa软件源sudo add-apt-repository --remove ppa:user/ppa-name # 删除ppa软件源 当添加完某个ppa软件源后，会在系统的 /etc/apt/sources.list.d 目录下生成对应的源文件： 可见，此操作就是在文件里添加了一个和软件源一模一样的东西，以 notepad++ 的使用为例： 1234567# 安装sudo add-apt-repository ppa:notepadqq-team/notepadqqsudo apt-get update # 记得此时要更新一下软件源sudo apt-get install notepadqq# 卸载sudo apt-get remove notepadqqsudo add-apt-repository --remove ppa:notepadqq-team/notepadqq 3）上面两个东西，其实要实现的功能是一样的，之所以在系统中存在/etc/apt/sources.list和/etc/apt/sources.list.d两套东西，是系统为了区分官方源与第三方源，毕竟第三方源存在安全问题的可能性比较大。]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTTP抓包实战]]></title>
    <url>%2F2018%2F11%2F13%2FHTTP%E6%8A%93%E5%8C%85%E5%AE%9E%E6%88%98%2F</url>
    <content type="text"><![CDATA[开始读《HTTP抓包实战》，在这个作业满天飞的日子里，计划1周读完，本篇博文对其中的部分知识点做一下简单的记录。 1、HTTP抓包分析使用的工具不再是wireshark（研究TCP/IP协议使用），而是使用 fiddler，版本4。其实 fiddler 做HTTP数据包分析的原理就是相当于一个web代理，如下图： fiddler在中间，可以记录所用的HTTP流量。fiddler启动时，会偷偷把 Internet 选项中的代理修改为 ：127.0.0.1,端口： 8888; fiddler在关闭时，会自动在Internet选项中取消代理，这样就不会对其他程序产生影响。如下图： fiddler界面如下图，使用方法请自行百度或google. 2、在 fiddler中抓取 https 的流量，需要做如下图配置并安装证书。 像 IE，chrome等浏览器都是使用windows证书库来验证证书，但是firefox浏览器是自己维护一个证书列表，所以需要在firefox中单独安装 fiddler证书。在上图中的action选项中可以下载fiddler的根证书到桌面，firefox &gt;&gt; 工具 &gt;&gt; 选项 &gt;&gt; 隐私与安全 &gt;&gt; 证书 &gt;&gt; 查看证书 &gt;&gt; 证书机构中可以导入证书，这里，fiddler的作者开了个玩笑，证书名叫DO_NOT_TRUST_FiddlerRoot。 3、在抓包时，我们经常能看到 tunnel to的握手包，这对我们分析数据包没啥作用，可以在fiddler &gt;&gt; rules &gt;&gt; hide connects中设置其隐藏掉。 4、Win+R输入certmgr.msc查看windows证书管理库 5、https://www.wangjibao.com.cn/2018/11/13/HTTP%E6%8A%93%E5%8C%85%E5%AE%9E%E6%88%98/#more 上面是个url的例子，https协议，www.wangjibao.com.cn为域名，这里使用的是默认80端口，所以省略端口显示，后面的/2018/11/13/HTTP%E6%8A%93%E5%8C%85%E5%AE%9E%E6%88%98/代表资源的路径，后面的#号代表啥呢，其实这是个 锚点(anchor)，我们知道，当一个页面非常长的时候，我们可以在页面中根据锚点直接定位到我们需要的地方。 6、HTTP的状态码，200类是成功，300类代表重定向，400类代表客户端错误，500类错误代表服务器错误。 其中的206(Partial Content)代表的是部分内容，迅雷、HTTP下载工具就是使用206状态码来实现的断点续传。 当遇到301 或 302的响应时，浏览器会自动根据response中的重定向url重新访问资源地址。如下图（京东之前叫360buy)： 先访问www.360buy.com返回301说这个网址已经move permanently了，给了个http://www.jd.com，然后，浏览器就是访问这个网址，但是服务器说302，代表说，这次对了，但是为了安全，去访问另一个网址吧https://www.jd.com吧，接着就会发现，129号中显示了tunnel to，代表开始握手协商了。 其实，这里301或302还是有区别的，301代表旧url已经永久移除了，搜索引擎会把权重计算到新的url上。但302代表旧url还在，只是临时重定向到新url上，搜索引擎会把权重计算到旧url上。 7、常用的HTTP请求方法就是 get和post。 我们登录国科大的选课网站，在 fildder中，可以清楚的看到，用户名和密码被包含在post请求的body中，发送给了服务器。同样，如果是get请求，包含在url中?后面的字段可以在QueryString中看到对应的Name--Value字段。 8、可以在fiddler &gt;&gt; tools &gt;&gt; user-agent中修改User-Agent字段的值，如下图，再浏览某些网页时，就变成了对应的显示模式。 9、Ajax (Asynchronous Javascript And XML”: 异步 JavaScript 和 XML）,是一种在无需重新加载整个网页的情况下，能够更新部分网页的技术。 10、在 Rules &gt;&gt; Automatic Breakpoint &gt;&gt; after/before Response中可以设置拦截HTTP请求。比如，我可以设置拦击HTTP的响应，然后在raw中修改页面的title字段，点击Run to Completion发成修改后的发送。 1号包中的红色代表拦截到了，这时别忘了，之前设置的全局断点给取消掉，不然会影响其他请求的发送和接收。效果如下图： 注意：修改操作必须在raw选项框里。当然，也可以设置局部断点，bpu www.baidu.com设置只拦截百度的请求，取消拦截在页面左下角的命令框中输入bpu即可；bpafter www.baidu.com拦截响应，bpafter取消拦截响应。 11、浏览器中的缓存 如下图，浏览器想请求某个资源的时候，先检查本地缓存，如果本地缓存存在这个文件的时候，直接获取该文件的最后修改时间等信息，构造数据包发送请求（内含有If-Modified-Since字段和If-None-Match字段）给服务器，服务器根据这两个值，结合自身的Last-Modified字段和Etag字段来判断需不需要发送数据给浏览器，如果不需要（1、Request中的If-Modified-Since的时间大于或等于Resonse中的Last-Modified的时间；2、ETag值和If-None-Match相匹配，说明hash值不变文档没改变），则服务器发送 304 Response给浏览器，告诉它，直接使用缓存就行了，节省时间加快网页加载速度。 当然，我们也可以 ctrl + F5强制刷新浏览器，告诉服务器，我不使用缓存，请发送最新的数据资源给我。 其中的pragma是HTTP1.0中使用的，Cache-Control是现在HTTP1.1用的，同时存在这两个字段，完全是为了兼容。 12、URL只能使用英文字母、数字或者某些标点符号，URL Encode(URL 编码)就是把所有非英文字母、数字字符都替换成百分号（%）后加两位十六进制数。如： https://www.wangjibao.com.cn/2018/11/13/HTTP抓包实战 编码后变成了如下模式， 1https://www.wangjibao.com.cn/2018/11/13/HTTP%E6%8A%93%E5%8C%85%E5%AE%9E%E6%88%98/ 13、Fiddler提供了丰富的插件，可以在https://www.telerik.com/fiddler/add-ons中下载安装使用，如`Java Script Formatter、Gallery、WinDiff`（比较两个session的不同）等等。 14、 Fiddler中可以在线调试 JavaScript文件，使用的是AutoResponder功能，如下图，其原理就是当命中某个文件时，自动替换成我们设置的文件返回给客户端，就不去服务器索取了。 当然，不仅可以替换 JS 文件，还可以替换网页中的图片为本地我们设置的图片。 15、我们还可以直接编辑Fiddler Script来修改HTTP请求或者响应，并且不中断程序（之前介绍的设置断点的方式，会使得程序中断）。Rules &gt;&gt; Coustomize Rules中，打开Fiddler ScriptEditor来编辑CustomRules.js文件，如图： 16、HTTP的Cookie机制 因为HTTP协议是无状态的，可以通过Cookie来维持会话。登录 http://piaoweb.sstm.org.cn，可以在fiddler中看到cookie的运行机制，如下图： 浏览器把Cookie通过HTTP请求中的Header发送给服务器，同时，服务器通过HTTP响应中的Header(Set-Cookie机制)把Cookie发送给浏览器。 上图中的 HttpOnly字段是说通过JavaScript脚本无法读取到Cookie信息，可以有效防止XSS攻击。 浏览器根据服务器返回的Set-Cookie设置好本地Cookie以后，浏览器每次请求服务器的资源时，就在Header中将Cookie附加上，这样，服务器就认为浏览器是登录状态。 17、Cookie劫持攻击 这里我们使用豆瓣网为例，演示一下Cookie劫持攻击。 （1）登录豆瓣网，用Fiddler抓取登录过程产生的数据包，可以看到一个如下图中的包，里面含有我们需要的cookie。 （2）我们打开这个会话的session，可以看到用户的cookie，其中的dbcl2是和用户登录相关的。 （3）我们在该会话上右键，replay &gt;&gt; Reissue and Edit，将cookie中的此字段删除，然后Run to Completion放行，可以看到此时我们现在是非登录状态，并且跳转到了登录界面，服务器返回302。 （4）现在我们知道，这个cookie字段就是和用户登录相关的，并且已经劫持到了，那么如何利用它呢？可以利用之前提到的Fiddler Script，编写脚本，每次发送数据包的时候，自动加上这个cookie不就行了，并且这个操作不会有任何中断。 在 Fiddler Script中的OnBeforeRequest函数中添加如下代码段： 1234if(oSession.uriContains("douban.com"))&#123; var sCookie = "dbcl2=\"170842457:NW8ZWiZHFUU\""; oSession.oRequest["Cookie"] = sCookie;&#125; 再次访问豆瓣网，发现自己已经处于登录状态了。 18、HTTP基本验证 把用户名+冒号+密码用Base64编码后生成字符串，放在header中的Authorization字段中，发送给服务器。 19、手机Fiddler抓包 手机和电脑处于同一局域网中，在fiddler &gt;&gt; Tools &gt;&gt; Options &gt;&gt; Connections中将allow remote computers to connect勾选上，同时在手机的wlan设置中，将其代理设置成电脑，IP为电脑IP，端口为8888；同时，在手机的安全设置中可以安装之前下载的fiddler root根证书，这样，就可以捕获到手机的https数据包了。 20、Replay菜单的详细说明： Reissue Requests：重新发送请求，和菜单栏上的Replay按钮是一样的功能。 Reissue Unconditionally：无条件反复发送选中的请求。 Reissue and Edit：把选中的请求以原来的形式重新发送，在每个新的Session中设置断点，在请求发送给服务器之前，可以修改请求。 Reissue and Verify：重新发送请求，检查响应，如果响应和上一个请求一样，就会变成绿色。 Reissue Sequentially：选中多个Session会按顺序一个一个重新发送请求，是单线程模式。 Reissue from Composer：在Composer中编辑该请求。 Revisit in IE：在IE浏览器中用Get方法访问这个请求。 21、重放攻击，在Fiddler中，可以使用Composer编辑数据包并进行发送。 其实，重放攻击危害很大，比如说，某网站的投票或者点赞功能，当我们抓取到某个点赞的包时，我们可以重复发送这个数据包来进行刷票。再比如说，某些软件的注册，当我们抓取到某个注册请求包的时候，我们进行大量重复发送，对app造成的损失还是很大的。 解决方案：在HTTP请求中，添加时间戳stamp和数字签名sign。数字签名保证有效性，时间戳保证时效性。 22、后面的3–4个章节是使用JMeter对网站做自动化测试和压力测试的，在此略过。]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[小知识科普]]></title>
    <url>%2F2018%2F11%2F12%2F%E5%B0%8F%E7%9F%A5%E8%AF%86%E7%A7%91%E6%99%AE%2F</url>
    <content type="text"><![CDATA[本篇博文记录一下平时生活中遇到的小知识，不定期更新。 1、判断USB接口类型晚上同学过来借扩展坞，看了眼USB接口的颜色，问，这是2.0的口吗？很明显，本渣渣耗费 199大洋 采购的东东，怎么能不是 3.0 的口呢。其实凭借USB接口的颜色能够一定程度上判断接口类型，但并不一定准确。 准确的做法是：看接口的针脚数 ，USB2.0 的针脚数目是 4 个，USB3.0 的针脚数目是 9 个。如下图： 上图是本渣18年从青大毕业时，学院发的纪念U盘，4个引脚，USB2.0的接口。为啥发U盘呢，18年在青岛开上合峰会的时候正值毕业季，各种大型活动统统不让搞，往年的毕业歌会也被无情的取消，那么办晚会的钱就拿来每人发个U盘吧，反正大家都是搞计算机的，以后也用得到，话说要发好歹也发个3.0口的u盘呗，吐槽一下。不过，当时每个U盘里都拷了毕业纪念视频，还是挺走心的，这个得表扬一波。 多说一句，信息安全班里当时毕业没有毕业聚餐你敢相信！？？其实知道现在想起来，还是耿耿于怀，原因大家也都心知肚明，怎么说，无愧于心就好！ 上图是3.0 的口，9个引脚能看清不，外面 5 个，里面 4 个。想一下，为啥2.0的东西插到3.0的口也能正常使用，是不就是使用的里面那4个引脚，外面那5个是闲着的，当插入3.0的东西时，这9个引脚会全部起作用。]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[树莓派搭建智能路由器]]></title>
    <url>%2F2018%2F11%2F12%2F%E6%A0%91%E8%8E%93%E6%B4%BE%E6%90%AD%E5%BB%BA%E6%99%BA%E8%83%BD%E8%B7%AF%E7%94%B1%E5%99%A8%2F</url>
    <content type="text"><![CDATA[使用树莓派搭建一个小智能路由器，文档为当年做本科毕业设计时写的，单纯的一个环境搭建记录，放出来，喜欢玩的小伙伴说不定可以参考一下。]]></content>
      <categories>
        <category>资料</category>
      </categories>
      <tags>
        <tag>资料</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[算法课第三次作业]]></title>
    <url>%2F2018%2F11%2F12%2F%E7%AE%97%E6%B3%95%E8%AF%BE%E7%AC%AC%E4%B8%89%E6%AC%A1%E4%BD%9C%E4%B8%9A%2F</url>
    <content type="text"><![CDATA[1、书面作业懒得将 latex 转成 markdown了，直接传个PDF得了。 5、Cross the river贪心的基本思想：最重的人和最轻的人如果不超载重，就一起过河，如何超重，就最重的人自己一条船单独过河。 123456789101112131415161718192021222324252627282930313233#include &lt;bits/stdc++.h&gt;#include &lt;string&gt;#include &lt;vector&gt;#include &lt;stack&gt;#include &lt;map&gt;#include &lt;stdlib.h&gt;#include &lt;stdio.h&gt;#include &lt;algorithm&gt;using namespace std;int main()&#123; int n,l; int weight[50005]; cin &gt;&gt; n &gt;&gt; l; for( int i=0; i&lt;n; i++ )&#123; scanf("%d",weight+i); &#125; sort(weight,weight+n); int ans = 0, left = 0, right = n-1; while( left&lt;=right )&#123; ans++; if( weight[right]+weight[left] &lt;= l )&#123; left++; right--; &#125; else&#123; right--; &#125; &#125; cout &lt;&lt; ans &lt;&lt; endl; return 0;&#125; 6、Assign banana to monkeys贪心的基本思路：先按照位置排序，位于第 i 个位置的猴子就拿第 i 个位置的香蕉就好。 123456789101112131415161718192021222324252627282930313233343536#include &lt;bits/stdc++.h&gt;#include &lt;string&gt;#include &lt;vector&gt;#include &lt;stack&gt;#include &lt;map&gt;#include &lt;stdlib.h&gt;#include &lt;stdio.h&gt;#include &lt;algorithm&gt;using namespace std;int monkey[5000005];int banana[5000005];int main()&#123; int n=0; char ch; do&#123; scanf("%d",monkey+n); n++; &#125;while( (ch=getchar())!='\n' ); sort(monkey, monkey+n); n=0; do&#123; scanf("%d",banana+n); n++; &#125;while( (ch=getchar())!='\n' ); sort( banana, banana+n ); int ans = 0; for( int i=0; i&lt;n; i++ )&#123; ans = max( ans, abs(monkey[i] - banana[i]) ); &#125; cout &lt;&lt; ans &lt;&lt; endl; return 0;&#125;]]></content>
      <categories>
        <category>作业</category>
        <category>算法课第一次作业</category>
      </categories>
      <tags>
        <tag>作业</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[wireshark网络分析的艺术]]></title>
    <url>%2F2018%2F11%2F07%2Fwireshark%E7%BD%91%E7%BB%9C%E5%88%86%E6%9E%90%E7%9A%84%E8%89%BA%E6%9C%AF%2F</url>
    <content type="text"><![CDATA[1、Linux服务器在收到 SSH 访问请求时，会先查询该客户端 IP 所对应的 PTR 记录（ IP 反向解析，由 IP 地址 获得对应的DNS，常用在垃圾邮件过滤）。假如经过5秒钟还没有收到回复，就再发一次查询。如果第二次查询还是等了5秒还没回复，就彻底放弃查询。 解决方式： cat /etc/ssh/sshd_config | grep -i usedns ，如果显示 usedns yes ,将其设置成 no即可。 其中 grep是文本处理工具，同 sed、awk被称为文本处理三剑客。-i 代表忽略大小写的区别（ignore)。 2、启用 TCP SACK（ selective acknowledgement) 功能，在大量丢包时，不需要每个重传包都确认一次。可以在 ack 数据包中，告知对方哪些包我已经收到了，比如说，当前 ack = 100 ，包中的 sack 字段等于 107--120，那么可以一次性完成 100--106 号包的重传，节约时间。 3、延迟确认 当要发送一个 ack 数据包的时候，因为纯粹的ack数据包只是单纯的确认，不含有其他有用信息。启用延迟确认，当收到一个 seq时，不立即发送 ack，而是稍等一会，当本地有数据要发送时，将信息加在 ack数据包里，就一起带过去了，节省带宽。 4、数据接收方可以积累一些包才对发送方 ack 一次。 5、愚笨窗口综合症（silly window syndrome)—“小包问题“ 123456789101112纳格（Nagle)算法:if 有新数据要发送 if 数据量超过 MSS (即一个 TCP 包所能携带的最大数据量，通常为 1500-20tcp头-20ip头) 立即发送 else if 之前发出去的数据尚未确认 把新数据缓存起来，凑够 MSS 或等确认到达再发送 else 立即发送 end if end ifend if 6、延迟确认和 nagle 算法不能一起用，容易造成网络延迟大的要命 7、虽然说是 TCP 的三次握手，四次挥手，但是有时候，四次挥手，并不一定就是4个数据包，有可能是3个，即中间的 2号包的 ACK 和3号包的 FIN 结合在一起，形成一个数据包。 8、NTLM（ NT LAN Manager）,一种身份认证协议 客户端向服务器发送一个 NTLM 协商请求，然后服务器立即回复一个随机字符串作为 challenge。 客户端收到 challenge 之后，向服务器回复 用户名，以及两个 response(用hash过的用户密码对 challenge加密得到的) 服务器不知道如何验证真假，所以将 challenge 和 两个response 都转发给 域控Domain Controller ，让域控去帮忙验证真假。 域控收到后，也用 hash过的用户密码对 challenge进行加密。如果加密结果和 reponse一样，说明密码正确，身份验证通过。 由于从数据包里就能看到 challenge 和 response ，算法也是固定的，所以并不安全。 9、Kerberos（安全认证协议） 认证过程如下图，kerberos 认证是个双向的过程，即client可以验证server，server 也可以认证 client。 $\blacksquare$ 相关名词解释 KDC ( key distributed center ): 整个安全认证过程的票据生成管理服务，包括 AS 和 TGS 服务。 AS ( authentication service ): 为 client 生成TGT的服务。 TGS( ticket granting service ): 为 client 生成某个服务器的 ticket。 TGT ( ticket-granting ticket ): 用于获取 ticket 的票据。 $\blacksquare$ 认证过程 (1) client 向 KDC 中的 AS 发送数据，表明自己的身份，AS对client的身份进行验证，验证通过后返给 client一个 TGT. (2) client 拿着这个 TGT，给TGS发送数据，说我想访问某个 server。然后TGS会将会话密钥$K_{client-server}$用 client master key加密后传送给client；与此同时，TGS也会将会话密钥$K_{client-server}$连同client的基本信息打包用server master key加密也发client，并经client转发给server，至此client与KDC的交互完成。 (3) client用自己的 master key 解密 TGS 传过来的第一个包，解密后获得会话密钥$K_{client-server}$，并用这个密钥加密自己的的信息和时间戳打包后传送给server。 (4) server会收到两个数据包，一个用会话密钥加密，一个用自己的master key加密，server先用自己的masterkey解密获取会话密钥和一份关于client的信息，然后server拿到解密后获取到的会话密钥再解开另外一个数据包，获得另一份关于client的信息和时间戳，对比一下这两份数据，一样即可验证通过。 详细过程请参照：https://blog.csdn.net/yangyang19920306/article/details/51673460 10、TCP Fast Retransmission ，当发送方收到3个及以上 [TCP Dup ACK] 时，就立刻重传它。 [TCP window Full] 和 [TCP zerowindow] ，前者表示这个包的发送方暂时没办法再发送数据了（比如说接收方之前告诉我，接收窗口是100，我把100个数据发送过去了，但是都没有收到回复，可能在去的途中，所以为了保险起见，我不能再接着发送了）。后者表示这个包的发送方没办法再接收数据了（告诉对方，我的接收窗口满了，别再发了）。 11、LSO（ large segment offload） 传统的网络工作方式是这样的：应用层把产生的数据交给TCP层，TCP层再根据MSS大小进行分段（有CPU负责）,然后再交给网卡。而启用LSO之后，TCP层就可以把大于MSS的数据块直接传给网卡，让网卡来负责分段的工作。其实在数据量较大时，数据分段计算校验和等简单操作也挺浪费CPU资源的。在计算机的网卡，高级设置里可以启用这一功能，如下图： 详细说明：https://www.cnblogs.com/tcicy/p/8442225.html 12、TCP中的拥塞控制机制 了解其中的 慢开始、拥塞避免、快重传、快恢复机制。 详细说明：https://blog.csdn.net/jtracydy/article/details/52366461 13、有一种 拥塞窗口的计算方式： $ cwnd = cwnd + MSS*\frac{n \times MSS}{cwnd} $ . n 代表当前接收到的 ack 的个数，当每个数据片返回一个 ack的时候，这个算法是没问题的，即 $\frac{n \times MSS}{cwnd} = 1$ , 每次拥塞窗口增大一个，如上图中的“拥塞避免”状态。但是，我们之前说过，并不是每个数据片都会返回一个 ack 的，有可能攒了好几个才 ack 一次，所以，这种计算方法存在问题，解决方法是关掉网卡中的 Large Receive Offload。 14、前面逼逼了辣么多，真实环境抓几个包说道说道。 就拿上面截图的数据包说事吧，数据包下载链接 185.199.109.153 为服务器端，192.168.199.160 为 客户端。 (1) 通信过程详解 首先，1203号包服务器端发送了seq = 939400，len = 1460。 紧接着客户端回复 1204号包，说我已经收到了 ack = 939400+1460 = 940860号包。 正常情况下，服务器接着应该发送 seq = 940860的包给客户端，但是，在 1205号包中，客户端却收到了 seq = 942320 , len = 1460 的数据包，wireshark显示 [ TCP Previous segment not captured ]，说明前一个包（seq = 940860的数据包）可能丢了。 既然数据包丢了，客户端就得发送 ack 接着请求，所以，在1206号包中，客户端第二次要求服务器端发送 seq = 940860 的数据，wireshark显示 [ TCP Dup ACK 1204#1 ]，代表这是1204号包的再一次请求。 接着，1207号包，客户端收到了 seq = 943780，len = 1460 的数据包（ 942320 + 1460 = 943780） 。 1208号包，还没收到 seq = 940860 的数据包，客户端那个气啊，妹的，我再一次重复要求服务器重发 ack = 940860，出现了[ TCP Dup ACK 1204#2 ]. 在1209号包中，客户端收到了 seq = 946700 ， len = 1460 的数据包，现在问题比较大了，两个应该收到的数据包却没有收到，分别是 seq = 940860, seq = 945240 (1207中：943780+1460 = 945240）。同样的，wireshark显示 [ TCP Previous segment not captured ]。 接着，问题得到了改善，在1210号包中，客户端收到了本应该早收到的 seq = 945240, len = 1460 的数据包。wireshark显示 [ TCP Out-Of-Order ]，这也说明了，在真实的网络环境中，数据包并不一定是按序到达的。 客户端收到了 seq = 945240 ，seq = 946700(945240+1460) 的数据包，应该发送确认，直到此时，那个 seq = 940860 的包还是没给我发来，丫丫的，在1211号包 和 1212号包中客户端再一次发送 ack = 940860，要求服务器发送 seq = 940860号包给我，wireshark显示[ TCP Dup ACK 1204#3 ]，[TCP Dup ACK 1204#4 ]。 在下面的1213 ( seq = 946700+1460 = 948160 )、1214、1215 (seq = 948160+1460 = 949620 )、1216、1217 ( seq = 949620+1460 = 951080 )、1218号，6个数据包还是重演之前的画面，客户端收到的是后面的数据包，每收到一个包，就重复确认一次 ack = 940860, 于是出现了图中的 [ TCP Dup ACK 1204#5 ] 、 [ TCP Dup ACK 1204#6 ]、 [ TCP Dup ACK 1204#7 ] 。 最终，好现象终于出现，1219号包，服务器终于发来了盼望已久的 seq = 940860， len = 1460 。一起顺利，所有问题已经解决。由于是乱序到达的，wireshark显示 [ TCP Out-Of-Order ]。 在 1220号包中，客户端发送对 seq = 940860 的确认，因为之前已经接收到了 seq = 951080+1460 = 952540，所以此时就显示的 ack = 952540 。 接下来，一切正常。 (2) SACK字段展示 拿 1211 号数据包详细说一下之前提到的 SACK 字段。1211数据包是 ack 1209号数据包的吧。有个事实是：我本应该收到 seq = 940860 的，但是，从1205和1207号包中，我收到的是 seq = 942320, seq = 943780 ，所以此时，1211的TCP头部可选字段的 sack : 942320---945240 (943780+1460 = 955240)。从1209号数据包中我收到的是 seq = 946700，所以 1211数据包的TCP头部字段记录第二个 sack : 946700---948160 (946700+1460 = 948160) 。 在TCP的头部可选字段记录这个两个字段值，花掉了 20 字节，所以TCP的头部长度变成了 20 + 20 = 40 Bytes. 同样的，当客户端收到了 1210 号数据包的时候，是不是就把这两个字段中间空缺的那 1460 ( 946700-945240 = 1460 ) 字节给补上了。所以，在 1212号 ack 数据包中，sack : 942320---948160 ,如上图所示。 那么当之前没收到的 seq = 940860 也收到的时候，这个 sack字段就没啥意义了，直接没有了，如 1220号ack包展示的那样。到此，一切那么的完美。 sack字段在变化，同样的，ack 数据包的头部长度也在变化，如上图中： 74 &gt;&gt; 66 &gt;&gt; 54。每次 ack 都会 浪费 一定的带宽，所以，出现了下面的收到多个 seq ，客户端才 ack 一次。 (3) 之前说过，真实的环境中，并不会每个数据包都 ack 一次，如下图，在这里是每收到 2 个数据包才发送一个 ack。 15、TCP在三次握手的时候，客户端与服务器之间会协商 MSS 的大小，防止应用层发送的数据在 IP 层被分片。虽然，分片有时候是不可控的，比如数据包中间经过路由器时，也有可能被路由器分片。 协商过程如下图： 客户端说我的 MSS = 1460， 但是服务器说他的 MSS = 1370，所以，在接下来的数据包中，应用层的数据按照 MSS= 1370 的大小来传输。 16、通过如下命令构造分片的包 1ping &lt;ip&gt; -l 9000 -n 4 其中的 -l 参数指定发送的 ping 包的大小，9000 Bytes，所以会被分片处理，如下图所示。 -n指定发送的包的个数，还可以使用 -f 参数，指定发送的包不允许分片，即 DF = 1。 可以看到，分片数据包的 off 偏移字段，客户端可以根据 ID 字段，识别这是属于哪一个数据的分片包。那么，客户端如何确定什么时候开始重组这些分片的数据包？可以根据分片数据包的 MF 字段，最后一个分片包的 MF = 0 ，代表这是最后一个数据包了，后面没有数据了，这时，客户端就可以重组这些分片的数据包了。 有一种网络的攻击方式： 往客户端持续发送 MF = 1 的数据包，导致客户端一直缓存分片，导致内存耗尽。 17、TCP中避免拥塞的方式有： 接收端通过接收窗口的大小来通知发送端，告知其数据接收能力。同时，发送端 通过拥塞控制算法来动态调整自己的数据发送量。其中： 1当前数据发送量 = min( 接收窗口大小， 拥塞控制值大小 ) 18、因为TCP头中只给接收窗口预留了16个比特（因为当时设计的时候，全世界的带宽都很小）,这就意味着它最大只能表示$2^{16} - 1 = 65535$ 字节，网络发展到今天明显不够用啊。后来，想到了一个解决方案，在TCP三次握手的时候，在可选字段中告知对方一个叫 window scale 的值，对方将这个值当做 2 的指数，算出来的值再作为接收窗口的系数。有了这个系数，就可以把接收窗口扩展好多倍了。 从上图中可以看出，客户端告诉服务器，自己的 Win = 65535,放大倍数为 2 倍；接着服务器告诉客户端，自己的 Win = 13600, 放大倍数为 WS = 128 倍。 数据包详情如下图： 19、思考：一个服务器是如何使用 80 端口同时为多个客户端提供服务的？根据连接建立时创建的五元组区分。详细点可以看 多路 I/O复用 epoll。 20、在网络层，也就是IP层头部，有那么几个字段：identification、flags、offset 。因为IP层是无连接的，每产生一个数据报，identification就加 1 ，如果中途的路由器将其分片后，接收端可以根据 flags 中的 MF、DF字段以及片偏移字段，将同一个 identification 的数据报重新组装起来。 21、一种流量劫持的手段如下图所示： 实线代表真实的流量，虚线代表劫持的流量。实现的原理就是，我假的服务比你真的服务先响应客户端，这样，等到真的数据来的时候，就会被用户无情的丢弃掉了。 可以通过查看数据包中的 TTL 值，分析流量是否存在被劫持的可能性。 22、HTTP &gt;&gt; HTTP1.1 &gt;&gt; SPDY &gt;&gt; HTTP2.0 QUIC(基于UDP) 23、[ TCP zerowindow ] 表示这个包的发送方已经没有办法再接收数据了，对应包中显示 win = 0 。 [ TCP window Full ] 表示这个包的发送方暂时没有办法再发送数据了，已经把对方声称的接收窗口已经发满了确没收到ack，只能先暂停。计算在途字节数 24、书上午看完了，总得来说，作业没有在刻意的讲述知识点，通过一个个案例，真实的说明网络知识是如何应用到现实生活的，内容比较基础，对初学者来说不错的书！ 屁股后面跟着一堆作业，就这样吧。找个时间，读一下 tshark 的官方文档，感觉功能很强，用得好的话可以省很多事。https://www.wireshark.org/docs/man-pages/tshark.html 之前当当搞活动，加上双十一，买了好多书，下一本：《python黑帽子 黑客与渗透测试编程之道》。]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[VSCode配置Latex]]></title>
    <url>%2F2018%2F11%2F05%2FVSCode%E9%85%8D%E7%BD%AELatex%2F</url>
    <content type="text"><![CDATA[因为CTeX套装自带WinEdt编辑器难用、收费且不能实时编译显示pdf效果，本笔记主要记录如何在VSCode中编辑Tex文件，实现代码自动补全及实时查看文本编辑效果等功能。 1、软件下载CTEX下载地址：http://www.ctex.org/HomePage，建议下载完整版套装。 VSCode下载地址：https://code.visualstudio.com/ 2、软件配置在VSCode中安装对应的插件 更改配置文件在file &gt;&gt; preferences &gt;&gt; setting &gt;&gt; User Setting &gt;&gt; Extensions &gt;&gt; LaTex Workshop configuration &gt;&gt; active 中，打开 Edit in setting.json 文件。在文件中添加如下字段： 12345678910"latex-workshop.latex.recipes": [&#123; "name": "xelatex", "tools": ["xelatex"]&#125;, &#123; "name": "latexmk", "tools": ["latexmk"]&#125;, &#123; "name": "pdflatex -&gt; bibtex -&gt; pdflatex*2", "tools": ["pdflatex", "bibtex", "pdflatex", "pdflatex"]&#125;], 1234567891011121314151617"latex-workshop.latex.tools": [&#123; "name": "latexmk", "command": "latexmk", "args": ["-synctex=1", "-interaction=nonstopmode", "-file-line-error", "-pdf", "%DOC%"]&#125;, &#123; "name": "xelatex", "command": "xelatex", "args": ["-synctex=1", "-interaction=nonstopmode", "-file-line-error", "%DOC%"]&#125;, &#123; "name": "pdflatex", "command": "pdflatex", "args": ["-synctex=1", "-interaction=nonstopmode", "-file-line-error", "%DOC%"]&#125;, &#123; "name": "bibtex", "command": "bibtex", "args": ["%DOCFILE%"]&#125;], 1"latex-workshop.view.pdf.viewer": "tab", 1"latex-workshop.latex.clean.fileTypes": ["*.aux", "*.bbl", "*.blg", "*.idx", "*.ind", "*.lof", "*.lot", "*.out", "*.toc", "*.acn", "*.acr", "*.alg", "*.glg", "*.glo", "*.gls", "*.ist", "*.fls", "*.log", "*.fdb_latexmk"], 1"latex-workshop.latex.clean.enabled": false, 添加后的效果如下图所示： 3、开启自动保存，实时查看编辑效果在 file中将 auto saved勾选上即可。效果如下图：]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据科学导论作业]]></title>
    <url>%2F2018%2F11%2F04%2F%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E5%AF%BC%E8%AE%BA%E4%BD%9C%E4%B8%9A%2F</url>
    <content type="text"><![CDATA[第一次作业：点击下载 怎么说，对这门课就是默默告诉自己，习惯就好。默默贴个 github 地址： https://github.com/justmarkham/DAT8 第二次作业：点击下载 同样，还是贴几个github链接地址： https://github.com/lamalor/ds100/blob/182feda62685b0988f4b4afb52c85256f4ac7d92/hw6/hw6.ipynb https://github.com/Dhanush123/data100/blob/master/hw6/hw6.ipynb https://github.com/iewaij/introDataScience/blob/1eb96b44721ed6cc40761a7e3003f11a5c243cc3/legacy/material/homework/DS100%20SP17/hw5/hw5_solution.ipynb https://github.com/dovahcrow/ds100/blob/30d629246c87f2fafbf10c155545c30344be23e6/sp17/hw/hw5/hw5_solution.ipynb 1、更改juypter默认工作路径在 anaconda prompt 中执行命令： 1jupyter notebook --generate-config 即可查看 jupyter_notebook_config.py 配置文件的位置，打开配置文件 jupyter_notebook_config.py，搜索关键字 notebook_dir ，将值设置为自己想要的工作目录并取消注释即可（注意路径中不能有中文）； 然后右击 jupyter notebook 快捷方式，将属性中的 “目标” 字段的值，去掉末尾的 %USERPROFILE% ，点击 应用，确定即可。 2、jupyter使用anaconda虚拟python环境打开 anaconda prompt，激活之前创建的某个python虚拟环境，在当前虚拟环境中执行 conda install nb_conda。重启 juypter notebook 服务器即可出现想要的虚拟环境 kernal 。 3、jupyter两种工作模式及其快捷键 分为命令模式（边框蓝色) 和 编辑模式(边框绿色) 命令模式中， M 进入markdown编辑模式， Y 进入代码编辑模式 4、代码自动补全注意，下面的所有操作是在 base 环境中安装的，在其他虚拟环境中安装好像并不起作用。 安装nbextensions 12pip install jupyter_contrib_nbextensionsjupyter contrib nbextension install --user 安装nbextensions_configurator 12pip install jupyter_nbextensions_configuratorjupyter nbextensions_configurator enable --user 重启 jupyter，在弹出的主页面里，能看到增加了一个Nbextensions标签页，在这个页面里，勾选Hinterland即启用了代码自动补全。 5、pandas教程[pan(el)-da(ta)-s]1、pandas中的数据分为三种： 一维数据 Series、二维数据 DataFrame、以及三维数据 Panel。 Series相当于一个字典。 123data = np.random.randn(5) # 一维随机数index = ['a', 'b', 'c', 'd', 'e'] # 指定索引s = pd.Series(data, index) 二维数据，1. 带Series的字典 2.列表构成的字典 3.带字典的列表 12345d = &#123;'one' : pd.Series([1., 2., 3.], index=['a', 'b', 'c']),'two' : pd.Series([1., 2., 3., 4.], index=['a', 'b', 'c', 'd'])&#125; #one做列d = &#123;'one' : [1, 2, 3, 4], 'two' : [4, 3, 2, 1]&#125; #one做列d = [&#123;'a': 1, 'b': 2&#125;, &#123;'a': 5, 'b': 10, 'c': 20&#125;] #a,b,c做列df = pd.DataFrame(d) # 新建 DataFrameprint(df） 列的选择，添加与删除 ​ df[‘列名’] df.pop(‘列名’) df.insert(添加列位置索引序号, ‘添加列名’, 数值) 行的选取，列的选取，块的选取 123456789101112df.index df.columns df.values df.values df.describes() df.T df.dtypesdf.sort_index() df.sort_values()df.head() df.tail()df[行选取] df[列名] df.loc[[行选取],[列选取]]#df.iloc df.iatdf.drop(&apos;行名&apos;)df.append()df.shape df.size df.ndim df.sum(axis=1 =0 =default) df.mean() df.std()表明智函数应用：pipe() #对所有元素起作用行或列函数应用：apply() #对行或者列起作用元素函数应用：applymap() #对某一个元素起作用 python中使用 type(var) 查看变量的数据类型 6、juypter显示行号view &gt;&gt; toggle line numbers 7、juypter中matplotlib画图中文显示乱码https://blog.csdn.net/u014465934/article/details/80377470]]></content>
      <categories>
        <category>作业</category>
        <category>数据科学导论大作业</category>
      </categories>
      <tags>
        <tag>作业</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[网络数据挖掘作业]]></title>
    <url>%2F2018%2F10%2F31%2F%E7%BD%91%E7%BB%9C%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98%E4%BD%9C%E4%B8%9A%2F</url>
    <content type="text"><![CDATA[NMF(非负矩阵分解)，nature论文原文： 个人理解PPT：]]></content>
      <categories>
        <category>作业</category>
        <category>网络数据挖掘作业</category>
      </categories>
      <tags>
        <tag>作业</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[算法课第二次作业]]></title>
    <url>%2F2018%2F10%2F28%2F%E7%AE%97%E6%B3%95%E8%AF%BE%E7%AC%AC%E4%BA%8C%E6%AC%A1%E4%BD%9C%E4%B8%9A%2F</url>
    <content type="text"><![CDATA[一、Money robbing1、optimal substructure and DP equation对于第 i 家，有两种选择，抢或者不抢。如果抢第 i 家，那么最大收益为：value[i] + 抢前 i-2 家的最优收益； 如果第 i 家不抢，那么最大收益为：抢前 i-1 家的最优收益。 状态转移方程可写为：$$dp[i] = max( dp[i-1], dp[i-2]+value[i] )$$ 2、 pseudo-codeLeetCode 198题 12345678910111213141516class Solution &#123;public: int rob(vector&lt;int&gt;&amp; nums)&#123; if( nums.size()==0 ) return 0; else if( nums.size()==1 ) return nums[0]; vector&lt;int&gt; dp(nums.size(),0); dp[0] = nums[0]; dp[1] = max( nums[0], nums[1] ); for( int i=2; i&lt;nums.size(); i++ )&#123; dp[i] = max( dp[i-1], dp[i-2]+nums[i] ); &#125; return dp[nums.size()-1]; &#125;&#125;; 3、 correctness of algorithm如果暴力求解的话，每一家都有可能抢或者不抢，枚举每一种可能性，那么总的时间复杂度为 $O(2^n)$ ，且最后算出来的最优解一定是正确的。现在，我们采用动态规划思想中的 memory 数组，记录前 i-1 家的最优值，当计算第 i 家最优值时，其依赖的 OPT[i-1] 和 OPT[i-2] 已经求出，可直接计算当前最优值，故算法是正确的。 4、 complexity of algorithm代码中的 dp 数组，每个元素只计算了一遍，故算法的时间复杂度为 $ O(n) $。 注： 当房屋变成一个环的时候，也就是相当于在原有问题上添加了一个限制条件：第1家和第n家不能同时抢。那么，分别计算抢第二家到最后一家与抢第一家到倒数第二家的最大值，取两个值中更大的那个就是结果。 LeetCode 213题 123456789101112131415161718192021222324class Solution &#123;public: int rob(vector&lt;int&gt;&amp; nums) &#123; if( nums.size()==0 ) return 0; else if( nums.size()==1 ) return nums[0]; return max( func(nums, 0), func(nums, nums.size()-1 )); &#125; int func( vector&lt;int&gt; nums, int pos )&#123; nums.erase(nums.begin()+pos); if( nums.size()==0 ) return 0; else if( nums.size()==1 ) return nums[0]; vector&lt;int&gt; dp(nums.size(),0); dp[0] = nums[0]; dp[1] = max( nums[0], nums[1] ); for( int i=2; i&lt;nums.size(); i++ )&#123; dp[i] = max( dp[i-1], dp[i-2]+nums[i] ); &#125; return dp[nums.size()-1]; &#125;&#125;; 二、Node selection1、optimal substructure and DP equation对于当前根节点，有两种可能性，选取或者不选取。如果选取了当前的根节点，那么其孩子节点就不能选取，即最优值变为：root-&gt;value + 4个孙子的最优值之和； 如果当前根节点没有选取，最优值变为：两个孩子节点最优值之和。 给定任意一个根，假设我们能够得到当前根选取与不选取的最优值，结果保存在一个长度为2的数组里，array[0]代表根节点不选取，array[1]代表根节点选取，那么最优解为： 2、 pseudo-codeLeetCode 337题 1234567891011121314151617class Solution &#123;public: int rob(TreeNode* root) &#123; vector&lt;int&gt; ans = solve( root ); return max( ans[0], ans[1] ); &#125; vector&lt;int&gt; solve( TreeNode* root )&#123; vector&lt;int&gt; ans(2,0); if( !root ) return ans; vector&lt;int&gt; left_ans = solve( root-&gt;left); vector&lt;int&gt; right_ans = solve( root-&gt;right ); ans[0] = max( left_ans[0], left_ans[1] ) + max( right_ans[0], right_ans[1] ); //根节点不选 ans[1] = root-&gt;val + left_ans[0] + right_ans[0]; //选择根节点 return ans; &#125;&#125;; 3、correctness of algorithm当前节点的最优值，依赖于其儿子节点的最优值（当前节点没选，最优值等于选其左孩子节点最优值+选其右孩子节点最优值）或其孙子节点的最优值（选取了当前节点，最优值等于根节点值+其左孩子不选左根的最优值+右孩子不选右根的最优值），由此可知算法的正确性。 4、complexity of algorithm整个算法相当于一个深度优先搜索（DFS），树中的每个节点都会遍历一次，故算法的时间复杂度为$O(n)$。 三、Decoding1、optimal substructure and DP equationdp[i]表示从字符0~i的字符串包含最多的编码种数。不考虑特殊情况，该题的递推式是$dp[i]=dp[i-1]+dp[i-2]$，因为一个数字可以表示一个编码，两个数字也有可能表示一个编码，所以dp[i]应该等于0~i-1的字符串包含的最多编码种数加上0~i-2的字符串包含的最多编码种数。但是考虑到一共只有26种基础编码加上特殊情况0，所以递推式可以表示为： 2、 pseudo-codeLeetCode 91题 123456789101112131415class Solution &#123;public: int numDecodings(string s) &#123; if( s.length()==0 || s[0]=='0' ) return 0; vector&lt;int&gt; dp(s.length()+1,0); dp[0] = dp[1] = 1; for( int i=1; i&lt;s.length(); i++ )&#123; if( s[i]!='0' ) dp[i+1] += dp[i]; if( s[i-1]!='0' &amp;&amp; (s[i-1]-'0')*10+(s[i]-'0')&lt;=26 ) dp[i+1] += dp[i-1]; &#125; return dp[s.length()]; &#125;&#125;; 3、correctness of algorithm首先该问题包含最优子结构的性质，求0~n的字符串包含最多的编码种数包含了求0~n-1的字符串包含最多的编码种数或0~n-2的字符串包含最多的编码种数。其次该问题包含重叠子性质，大量子问题会重复计算，如求dp[5]需要计算dp[4]或dp[3],求dp[4]需要求dp[3]或dp[2]，因此dp[3]被重复计算。综上该问题可以用动态规划方法解且求解方程正确。 4、complexity of algorithm整个求解过程只遍历了一遍字符串，故算法时间复杂度为$O(n)$。 六、OJ第一题LIS，DP入门第一题，没啥好说的，只要想清楚为啥每次将新来的数据往 ans 数组里插入，最后出来的就一定是最长的就可以了。 123456789101112131415161718192021222324#include &lt;bits/stdc++.h&gt;using namespace std;int main()&#123; int num, T, N; int length, index; int ans[100005]; cin &gt;&gt; T; for( int t = 0; t&lt;T; t++ )&#123; cin &gt;&gt; N; length = 0; memset(ans, -1, sizeof(ans)); for( int i=0; i&lt;N; i++ )&#123; scanf("%d",&amp;num); index = lower_bound( ans, ans+length, num ) - ans; ans[index] = num; if( index==length ) length++; &#125; cout &lt;&lt; length &lt;&lt; endl; &#125; return 0;&#125; 七、OJ第二题入门级题目外加了求 K 个最优值的条件，昨晚1点多打开题目，感觉随便码一码随便A掉，于是上床 睡觉，躺床上拍脑袋理论AC。仔细一想，K个最优值的状态转移，有点问题啊，带着疑问入睡不咋舒坦，大半夜将题目发到315群，杨老师帅气得给出了解决方案，顺带嘲笑了一波数据；炸老师看了数据量也嘲讽了一波；早上起来交了一发，发现 0 ms的时候，也疯狂鄙视一波，数据真的弱得不行。 想起来当年 ycb 的誓言： 1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;bits/stdc++.h&gt;using namespace std;int m, n, k;int num;priority_queue&lt;int&gt; ans[105], cur_ans, tmp_ans;//默认大堆int main()&#123; ans[1].push(0); cin &gt;&gt; m &gt;&gt; n &gt;&gt; k; for( int i=1; i&lt;=m; i++ )&#123; for( int j=1; j&lt;=n; j++ )&#123; scanf("%d", &amp;num); while( !cur_ans.empty() )&#123; //清空cur_ans cur_ans.pop(); &#125; tmp_ans = ans[j-1]; while( !ans[j-1].empty() )&#123; cur_ans.push(ans[j-1].top()+num); ans[j-1].pop(); &#125; ans[j-1] = tmp_ans; while( !ans[j].empty() )&#123; cur_ans.push(ans[j].top()+num); ans[j].pop(); &#125; while( ans[j].size()&lt;k &amp;&amp; !cur_ans.empty() )&#123; ans[j].push(cur_ans.top()); cur_ans.pop(); &#125; &#125; &#125; cout &lt;&lt; ans[n].top(); ans[n].pop(); while( !ans[n].empty() )&#123; cout &lt;&lt; " " &lt;&lt; ans[n].top(); ans[n].pop(); &#125; return 0;&#125;]]></content>
      <categories>
        <category>作业</category>
        <category>算法课第二次作业</category>
      </categories>
      <tags>
        <tag>作业</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode21-30]]></title>
    <url>%2F2018%2F10%2F20%2FLeetCode21-30%2F</url>
    <content type="text"><![CDATA[21、合并两个有序链表两个有序链表的合并，本渣代码充分利用原有空间，没开辟新的内存存储新链。 1234567891011121314151617181920212223242526272829303132/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: ListNode* mergeTwoLists(ListNode* l1, ListNode* l2) &#123; ListNode *ans = (ListNode*)malloc(sizeof(ListNode)), *tmp = ans; ans-&gt;next = NULL; while( l1&amp;&amp;l2 )&#123; if( l1-&gt;val &gt; l2-&gt;val )&#123; tmp-&gt;next = l2; l2 = l2-&gt;next; &#125; else&#123; tmp-&gt;next = l1; l1 = l1-&gt;next; &#125; tmp = tmp-&gt;next; tmp-&gt;next = NULL; &#125; if( l1 ) tmp-&gt;next = l1; if( l2 ) tmp-&gt;next = l2; return ans-&gt;next; &#125;&#125;; 22、括号生成生成的种类数是个卡特兰数，因此 n 的值不会太大。卡特兰数在计算机中是个特别重要的数串，像：三角剖分、n个叶节点树的种类、n个数字的进出栈、括号匹配、矩阵链乘等等都有卡特兰数的应用。 卡特兰数的通项公式：$$h(n) = C_{2n}^n - C_{2n}^{n-1}$$递推公式为：$$h(n) = h(n-1)*\frac{4n-2}{n+1}$$其实，求组合数时，当 n 很大的时候，计算也是个问题，好在有 Lucas定理 可以解决这事，当然以上这些与解决本题没啥关系。 本题做法是直接递归一下即可，每次放左括号（第16行）或右括号（第17行），递归的退出条件是放了n个左括号和n个右括号（第9行），剪枝条件是放的右括号数量大于左括号数量了，明显会造成非法串，直接返回退出（第13行）。 12345678910111213141516171819class Solution &#123;public: vector&lt;string&gt; generateParenthesis(int n) &#123; vector&lt;string&gt; ans; func(ans, "", n, n); return ans; &#125; void func(vector&lt;string&gt;&amp; ans, string tmp_ans, int left, int right)&#123; if( left==0 &amp;&amp; right==0 )&#123; ans.push_back(tmp_ans); return; &#125; if( right&lt;left ) //相当于剪枝，2^n剪到katalan(n) return; if( left&gt;0 ) func( ans, tmp_ans+'(', left-1, right ); func( ans, tmp_ans+')', left, right-1 ); &#125;&#125;; 23、合并K个排序链表合并的关键点在于如何快速找到当前最小值，最小堆可以帮我们快速实现这一点。 12345678910111213141516171819202122232425262728293031323334353637/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; */ struct cmp&#123; bool operator()(ListNode* a, ListNode* b)&#123; return a-&gt;val &gt; b-&gt;val; &#125; &#125;;class Solution &#123;public: ListNode* mergeKLists(vector&lt;ListNode*&gt;&amp; lists) &#123; ListNode *ans = new ListNode(0); ListNode *p = ans, *tmp; priority_queue&lt;ListNode*, vector&lt;ListNode*&gt;, cmp&gt; pq; for(int i=0; i&lt;lists.size(); i++)&#123; if(lists[i]) pq.push(lists[i]); &#125; while(pq.size()&gt;1)&#123; tmp = pq.top(); pq.pop(); p-&gt;next = tmp; if(tmp-&gt;next) pq.push(tmp-&gt;next); p = p-&gt;next; p-&gt;next = NULL; &#125; if(pq.size()==1) p-&gt;next = pq.top(); return ans-&gt;next; &#125;&#125;; 24、两两交换链表中的节点处理好两个指针之间的关系即可。 1234567891011121314151617class Solution &#123;public: ListNode* swapPairs(ListNode* head) &#123; if( head==NULL || head-&gt;next==NULL ) return head; ListNode *p1=head, *p2=head-&gt;next, *tmp; head = head-&gt;next; while( p1 &amp;&amp; p2)&#123; tmp = p1; p1-&gt;next = p2-&gt;next==NULL? NULL:p2-&gt;next-&gt;next==NULL? p2-&gt;next:p2-&gt;next-&gt;next; p1 = p2-&gt;next; p2-&gt;next = tmp; p2 = p1==NULL? NULL:p1-&gt;next; &#125; return head; &#125;&#125;; 25、k个一组翻转链表采用一个大小为 k 的栈来实现翻转。 1234567891011121314151617181920212223242526272829class Solution &#123;public: ListNode* reverseKGroup(ListNode* head, int k) &#123; int len = 0; ListNode *tmp_head = head, *ans, *cur_ans; while(tmp_head)&#123; len++; tmp_head = tmp_head-&gt;next; &#125; int num_roll = len / k; ans = new ListNode(-1); cur_ans = ans; stack&lt;ListNode*&gt; s; tmp_head = head; for(int i=0; i&lt;num_roll; i++)&#123; for(int j=0; j&lt;k; j++)&#123; s.push(tmp_head); tmp_head = tmp_head-&gt;next; &#125; for(int j=0; j&lt;k; j++)&#123; cur_ans-&gt;next = s.top(); s.pop(); cur_ans = cur_ans-&gt;next; &#125; &#125; cur_ans-&gt;next = tmp_head; return ans-&gt;next; &#125;&#125;; 26、删除排序数组中的重复项直接使用 STL 中的 unique 函数即可，unique 函数的具体说明如下： iterator unique(iterator it_1,iterator it_2); 两个参数表示对容器中[it_1，it_2)范围的元素进行去重(注：区间是前闭后开，即不包含it_2所指的元素),返回值是一个迭代器，它指向的是去重后容器中不重复序列的最后一个元素的下一个元素。注意，unique函数的去重过程实际上就是不停的把后面不重复的元素移到前面来，也可以说是用不重复的元素占领重复元素的位置，而不是将重复的元素往后移动。 123456class Solution &#123;public: int removeDuplicates(vector&lt;int&gt;&amp; nums) &#123; return unique(nums.begin(), nums.end()) - nums.begin(); &#125;&#125;; 27、移除元素双指针，执行调换过程即可，注意，如果前后调换后，nums[pFront] 可能依然等于 val，通过第11行的 continue语句巧妙的解决该问题。 1234567891011121314151617class Solution &#123;public: int removeElement(vector&lt;int&gt;&amp; nums, int val) &#123; if(nums.size()==0) return 0; int pFront=0, pEnd = nums.size()-1; while(pEnd&gt;pFront)&#123; if(nums[pFront]==val)&#123; swap(nums[pFront], nums[pEnd]); pEnd--; continue; &#125; pFront++; &#125; return nums[pFront]==val? pFront:pFront+1; &#125;&#125;; 28、实现strStr()可以直接暴力，时间复杂度为$O(n^2)$。线性时间复杂度算法为 KMP 算法或 BM 算法。KMP 算法的关键是理解 next 数组的求解过程。 1234567891011121314151617181920212223242526272829303132333435class Solution &#123;private: int next[100000];public: void solve_next(string needle)&#123; memset(next, -1, sizeof(next)); int len = needle.size(); int k = -1, j = 0; while(j&lt;len-1)&#123; if( k==-1 || needle[j]==needle[k] ) next[++j] = ++k; else k = next[k]; &#125; &#125; int strStr(string haystack, string needle) &#123; if(needle.size()==0) return 0; solve_next(needle); int len_haystack = haystack.size(); int len_needle = needle.size(); int i = 0, j = 0; while( i&lt;len_haystack &amp;&amp; j&lt;len_needle)&#123; if(j==-1 || haystack[i]==needle[j])&#123; i++; j++; &#125;else&#123; j = next[j]; &#125; &#125; if(j==len_needle) return i-j; return -1; &#125;&#125;; 29、两数相除使用移位操作模拟乘法，用减法代替除法。 123456789101112131415161718192021222324class Solution &#123;public: int divide(int dividend, int divisor) &#123; if( dividend==INT_MIN &amp;&amp; divisor==-1 ) return INT_MAX; int flag1 = dividend&gt;0? 1:-1; int flag2 = divisor&gt;0? 1:-1; long long _dividend = abs((long long)dividend); long long _divisor = abs((long long)divisor); int n = 0; while(_divisor&lt;&lt;(n+1) &lt;= _dividend &amp;&amp; _divisor&lt;&lt;(n+1) &gt;= 0) n++; long long ans = 0; for(int i=n; i&gt;=0; i--)&#123; if( _dividend &gt;= _divisor&lt;&lt;i )&#123; ans += (long long)1&lt;&lt;i; _dividend -= _divisor&lt;&lt;i; &#125; &#125; if(flag1+flag2==0) return -ans&gt;=INT_MAX? INT_MAX:int(-ans); return ans&gt;=INT_MAX? INT_MAX:ans; &#125;&#125;; 30、串联所有单词的子串words中单词长度固定，将s串按照固定长度切分保存进vector&lt;string&gt;中，之后使用两个map和滑动窗口实现匹配过程，详见代码： 12345678910111213141516171819202122232425262728293031323334353637383940class Solution &#123;public: vector&lt;int&gt; findSubstring(string s, vector&lt;string&gt;&amp; words) &#123; vector&lt;int&gt; ans; if(s.size()==0 || words.size()==0) return ans; unordered_map&lt;string, int&gt; mp1; for(auto str : words) mp1[str] = mp1.find(str)==mp1.end()? 1:mp1[str]+1; int str_len = words[0].length(); for(int i=0; i&lt;str_len; i++)&#123; vector&lt;string&gt; word_vec; int position = i; while( position + str_len &lt;= s.length() )&#123; word_vec.push_back(s.substr(position, str_len)); position += str_len; &#125; unordered_map&lt;string, int&gt; mp2; int left = 0; for(int j=0; j&lt;word_vec.size(); j++)&#123; if(mp1.find(word_vec[j])==mp1.end())&#123; mp2.clear(); left = j+1; continue; &#125; mp2[word_vec[j]] = mp2.find(word_vec[j])==mp2.end()? 1:mp2[word_vec[j]]+1; while(mp2[word_vec[j]] &gt; mp1[word_vec[j]]) mp2[word_vec[left++]] -= 1; if( j-left+1 == words.size() )&#123; ans.push_back(left*str_len+i); mp2[word_vec[left]] -= 1; if(mp2[word_vec[left]]==0) mp2.erase(word_vec[left]); left++; &#125; &#125; &#125; return ans; &#125;&#125;;]]></content>
      <categories>
        <category>LeetCode</category>
        <category>LeetCode21-30</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[背包九讲]]></title>
    <url>%2F2018%2F10%2F17%2F%E8%83%8C%E5%8C%85%E4%B9%9D%E8%AE%B2%2F</url>
    <content type="text"><![CDATA[大二入门动态规划时，最先学得就是 LCS , LIS 和各种背包问题，后来接触二维DP和各种无厘头DP（数位DP啊，插头DP啊，状压DP啊，树状DP啊等等），以我这种智商水平，听听名字就好了。最近的算法课讲到了 DP 专题，找出了之前看的 背包九讲看了看，放出来，纪念一发当年的岁月吧。]]></content>
      <categories>
        <category>资料</category>
      </categories>
      <tags>
        <tag>资料</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ubuntu中配置SS多用户模式并限制每个用户的流量]]></title>
    <url>%2F2018%2F10%2F12%2FUbuntu%E4%B8%AD%E9%85%8D%E7%BD%AESS%E5%A4%9A%E7%94%A8%E6%88%B7%E6%A8%A1%E5%BC%8F%E5%B9%B6%E9%99%90%E5%88%B6%E6%AF%8F%E4%B8%AA%E7%94%A8%E6%88%B7%E7%9A%84%E6%B5%81%E9%87%8F%2F</url>
    <content type="text"><![CDATA[1、更新软件并安装vim123sudo apt-get updatesudo apt-get upgradesudo apt-get install vim 2、更改 SSH 默认端口1234sudo vim /etc/ssh/sshd_config找到 Port 字段，将其修改为自己想要的端口值sudo service ssh restart #重启ssh服务sudo netstat -tunlp | grep ssh #查看ssh服务监听的端口 这里将ssh端口改成了22222，如下图（PS:不要问我为啥强行改22号端口，就是任性，额，其实有点其他用途，青大校友表示当年我就是靠这个强行免费使用校园网）： 3、安装shadowsocks-python版本 123sudo apt-get install python-pip#在ubuntu16.04中，可以通过pip安装pyhon版的shadowsocks，但是好像已经不维护更新了，停留在了2.8.2版本sudo pip install shadowsocks 然后创建一个 json 文件并在其中填写个人配置信息即可，比如在 /home/my_ss_config.json 中，填写如下信息： 123456789&#123;"server" : "your_server_ip", #自己服务器的IP"server_port" : 8388, #服务器端口"local_address" : "127.0.0.1", "local_port" : 1080, "password" : "yourpassword", #密码"timeout" : 300, "method" : "aes-256-cfb" #加密方式&#125; 只要更改后面带 # 号的一些字段值即可，如果想多用户的话，可以将 password 字段改成如下模式（ss使用端口值识别不同的用户）： 1234"port_password": &#123; "端口1": "密码1", "端口2": "密码2"&#125;, 一切准备就绪，接下来使用如下命令即可运行 SS 服务，实现 Cross the Great Fire Wall 。 1sudo ssserver -c /home/my_ss_config.json -d start 4、多用户模式流量统计说一下我为啥要搞这么个功能，前天，我TM大半夜的正嗨呢，突然，网断了！于是乎，打开4G，还是无法操作，这。。。。我手纸都准备好了，竟然发生这样的事？（开玩笑，哈哈，根正苗红的科研知识分子，油管看科研视频的好吧，为科研奉献全身！）收到邮件，告诉我流量用完了，呵。。。 于是乎，大家公用的情况下，私开个个人账号，每到月末的时候应急用。于是乎用到了上面讲到的多用户模式，但是这样还不行，为每个用户限制流量使用上限才能达到目的。 找了找，发现国内的某度关于这方面是真的干净，上某歌，查到可以使用 ss-bash 实现，github上有，实现的原理就是：不同的用户分配不同端口，使用iptables规则获取各端口的流量，脚本循环运行，在固定时间间隔根据iptables结果统计流量使用情况，并在流量超过限制时，添加对应端口的iptables reject规则以禁用端口。 安装shadowsocks与ss-bash之后，shadowsocks就不用做任何配置了，省去了上面的步骤，由ss-bash管理shadowsocks，包括配置的文件等等。有个缺点就是，ss-bash目前只支持python版Shadowsocks，只支持统计ipv4流量，但这问题影响不大。 执行如下指令： 12345apt-get install unzip #下载解压工具apt-get install bc #安装计算器，后面统计流量用wget https://github.com/hellofwy/ss-bash/archive/master.zip #下载软件包unzip master.zipcd ss-bash-master/ 现在就可以使用相关命令配置 SS 了，具体操作指令如下（可通过 ./ssadmin.sh 命令查看）： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253用法： 显示版本： ssadmin.sh -v|v|version 显示帮助： ssadmin.sh [-h|h|help] 启动ss: ssadmin.sh start 停止ss： ssadmin.sh stop 查看ss状态： ssadmin.sh status 重启ss： ssadmin.sh restart 软重启ss： ssadmin.sh soft_restart 在不影响现有连接的情况下重启ss服务。用于ss服务参数修改， 和手动直接修改配置文件后，重启ss服务。 添加用户： ssadmin.sh add port passwd limit port：端口号, 0&lt;port&lt;=65535 passwd：密码, 不能有空格，引号等字符 limit：流量限制，可以用K/M/G/T、KB/MB/GB/TB等（不区 分大小写）。支持小数。比如10.5G、10.5GB等。 1KB=1024 bytes，以此类推。 示例： ssadmin.sh add 3333 abcde 10.5G 显示用户流量信息： ssadmin.sh show port 显示所有用户流量信息： ssadmin.sh show 显示用户密码信息： ssadmin.sh showpw port 显示所有用户密码信息： ssadmin.sh showpw 删除用户： ssadmin.sh del port 修改用户： ssadmin.sh change port passwd limit 修改用户密码： ssadmin.sh cpw port passwd 修改用户流量限制： ssadmin.sh clim port limit 修改所有用户流量限制： ssadmin.sh change_all_limit limit 用户流量使用量置零： ssadmin.sh rused limit 所有用户流量使用量置零： ssadmin.sh reset_all_used 用户流量限制置零： ssadmin.sh rlim port 全部用户流量限制置零： ssadmin.sh reset_all_limit 显示已添加的iptables规则： ssadmin.sh lrules 添加完账户后，./ssadmin.sh start启动后，./ssadmin.sh show 即可查看每个用户的当前流量使用情况。如下图： ssadmin文件夹中的各个文件的含义如下： 123456789ssadmin.sh #管理程序，所有命令通过该程序执行sscounter.sh #流量统计程序。由ssadmin.sh自动调用执行，注意：不要手动运行该程序sshelpsslib.sh #包含一些参数配置和流量统计函数。由ssadmin.sh自动调用执行，注意：不要手动运行该程序ssmlt.json #根据用户列表和ssmlt.template生成的ssserver实际使用的配置文件ssmlt.template #ssserver的配置文件sstraffic #用户流量使用情况，包括流量限制，已用流量，剩余流量等。ssadmin.sh show 命令，显示该文件内容。ssusers #用户列表traffic.log #用户流量记录，供程序内部使用。 备注： 1、默认的流量采样间隔为5分钟，流量间隔可根据实际需求调整，但最好不要太小，比如小于10秒。可打开文件sslib.sh ，修改INTERVEL 的值，单位为秒。 2、如果shadowsocks不是使用apt-get或者pip安装，无法自动找到 ssserver 文件时，请手动指定程序的具体位置。打开文件 sslib.sh ，修改 SSSERVER 的值，比如 ssserver 的路径为 /usr/local/bin/ssserver 时，修改为: 1SSSERVER=/usr/local/bin/ssserver 5、To Do List既然身为抓包组里的一员，就要干点抓包相关的事，是不是。比如说，十分好奇为啥大家流量用得那么多呢，肯定看视频了，看啥视频了呢，奥特曼大战葫芦娃.avi ？初步打算在服务器上进行流量采样，比如万分之一的采样率，然后记录下对应账户的 DNS请求的 query 字段值，client hello中的SNI字段等。 最近比较忙（其实就是懒），回头抽空搞一发。。。嘻嘻]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode11-20]]></title>
    <url>%2F2018%2F10%2F09%2FLeetCode11-20%2F</url>
    <content type="text"><![CDATA[11、盛最多水的容器双指针，算法中一个很重要的技巧，之前的三数求和就用到了双指针的技巧。 我们在由线段长度构成的数组中使用两个指针，一个放在开始，一个置于末尾。 此外，我们会使用变量 maxArea 来持续存储到目前为止所获得的最大面积。 在每一步中，我们会找出指针所指向的两条线段形成的区域，更新 maxArea，并将指向较短线段的指针向较长线段那端移动一步。 123456789101112131415class Solution &#123;public: int maxArea(vector&lt;int&gt;&amp; height) &#123; int maxArea = 0; int frontPoint = 0, endPoint = height.size()-1; while( frontPoint&lt;endPoint )&#123; maxArea = max( maxArea, (endPoint-frontPoint)*min(height[frontPoint], height[endPoint]) ); if( height[frontPoint]&lt;height[endPoint] ) frontPoint++; else endPoint--; &#125; return maxArea; &#125;&#125;; 12、整数转罗马数字水题一个，模拟一下即可。 123456789101112131415161718192021222324252627class Solution &#123;public: string intToRoman(int num) &#123; vector&lt; pair&lt;int,string&gt; &gt; mp; mp.push_back( make_pair(1000,"M") ); mp.push_back( make_pair(900,"CM") ); mp.push_back( make_pair(500,"D") ); mp.push_back( make_pair(400,"CD") ); mp.push_back( make_pair(100,"C") ); mp.push_back( make_pair(90,"XC") ); mp.push_back( make_pair(50,"L") ); mp.push_back( make_pair(40,"XL") ); mp.push_back( make_pair(10,"X") ); mp.push_back( make_pair(9,"IX") ); mp.push_back( make_pair(5,"V") ); mp.push_back( make_pair(4,"IV") ); mp.push_back( make_pair(1,"I") ); string ans = ""; for( vector&lt; pair&lt;int,string&gt; &gt;:: iterator it = mp.begin(); it!=mp.end(); it++ )&#123; while( num&gt;=(*it).first )&#123; ans += (*it).second; num -= (*it).first; &#125; &#125; return ans; &#125;&#125;; 13、罗马数字转整数水题，直接模拟 12345678910111213141516171819202122class Solution &#123;public: int romanToInt(string s) &#123; map&lt;char, int&gt; mp; mp['I'] = 1, mp['V'] = 5, mp['X'] = 10, mp['L'] = 50; mp['C'] = 100, mp['D'] = 500, mp['M'] = 1000; vector&lt;int&gt; nums; for( int i=0; i&lt;s.length(); i++ ) nums.push_back( mp[s[i]] ); nums.push_back(0); int ans = 0; for( int i=0; i&lt;nums.size()-1; i++ )&#123; if( nums[i]&lt;nums[i+1] )&#123; ans += nums[i+1]-nums[i]; i++; &#125; else ans += nums[i]; &#125; return ans; &#125;&#125;; 14、最长公共前缀没啥好方案，直接暴力即可。暴力的方式有多种，一种像这里直接每次一个字符一个字符的得出 ans ，也可以挨个字符串直接与 ans（初值为字符串strs[0]） 比较，逐渐缩小 ans 的长度，直到最后得出结果。 12345678910111213141516171819202122class Solution &#123;public: string longestCommonPrefix(vector&lt;string&gt;&amp; strs) &#123; if( strs.size()==0 ) return ""; int lens = 0, i = 0; string ans = ""; char ch; while(1)&#123; if( strs[0].length() &gt; lens ) ch = strs[0][lens]; else return ans; for( i=1; i&lt;strs.size(); i++ )&#123; if( strs[i][lens]!=ch ) return ans; &#125; ans += ch; lens++; &#125; &#125;&#125;; 15、三数之和三数之和其实和前面的两数之和原理一样，都是使用的双指针。这里的三数，其实可以直接固定一数，然后调用前面写的两数之和的代码。唯一的一点 trick 可能就是在去重上。 12345678910111213141516171819202122232425262728293031323334353637383940class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; threeSum(vector&lt;int&gt;&amp; nums) &#123; vector&lt; vector&lt;int&gt; &gt; ans; if( nums.size()&lt;3 ) return ans; //对 nums 进行排序并去重(此处去重不合适) sort( nums.begin(), nums.end() ); //vector&lt;int&gt;:: iterator it = unique( nums.begin(), nums.end() ); //nums.erase( it, nums.end() ); for( int i=0; i&lt;nums.size()-2; i++ )&#123; if( i&gt;0 &amp;&amp; nums[i-1]==nums[i] ) continue; findTwoSum( nums, i+1, nums.size()-1, i, ans ); &#125; return ans; &#125; void findTwoSum( vector&lt;int&gt;&amp; nums, int s, int e, int target, vector&lt; vector&lt;int&gt; &gt;&amp; ans )&#123; vector&lt;int&gt; step_ans; while( s&lt;e )&#123; if( nums[s]+nums[e] == -nums[target] )&#123; step_ans.clear(); step_ans.push_back(nums[target]); step_ans.push_back(nums[s]); step_ans.push_back(nums[e]); ans.push_back(step_ans); s++; e--; while( s &lt; e &amp;&amp; nums[s]==nums[s-1] ) s++; while( e &gt; s &amp;&amp; nums[e]==nums[e+1] ) e--; &#125; else if( nums[s]+nums[e] &gt; -nums[target] ) e--; else s++; &#125; &#125;&#125;; 16、最接近的三数之和和三数之和的原理一样，排序后使用双指针遍历找最优解。 123456789101112131415161718192021class Solution &#123;public: int threeSumClosest(vector&lt;int&gt;&amp; nums, int target) &#123; sort( nums.begin(), nums.end() ); int nearest = nums[0]+nums[1]+nums[2], tmpSum; for( int i=0; i&lt;nums.size()-2; i++ )&#123; int f = i+1, e = nums.size()-1; while( f&lt;e )&#123; tmpSum = nums[f] + nums[e] + nums[i]; nearest = abs(target-nearest)&gt;abs(target-tmpSum)? tmpSum:nearest; if( tmpSum==target ) return target; else if( tmpSum &gt; target ) e--; else f++; &#125; &#125; return nearest; &#125;&#125;; 17、电话号码的字母组合一行深搜代码解决，2年没写搜索了，敲的时候好生疏。 1234567891011121314151617181920212223242526272829class Solution &#123;public: vector&lt;string&gt; letterCombinations(string digits) &#123; vector&lt;string&gt; mp,ans; string cur_ans; mp.push_back(""); mp.push_back(""); mp.push_back("abc"); mp.push_back("def"); mp.push_back("ghi"); mp.push_back("jkl"); mp.push_back("mno"); mp.push_back("pqrs"); mp.push_back("tuv"); mp.push_back("wxyz"); if( digits.length() ) digitsToString( mp, digits, ans, cur_ans ); return ans; &#125; void digitsToString( vector&lt;string&gt;&amp; mp, string digits, vector&lt;string&gt;&amp; ans, string cur_ans )&#123; if( digits.length()==0 )&#123; ans.push_back( cur_ans ); return ; &#125; for( int i=0; i&lt;mp[digits[0]-'0'].length(); i++ )&#123; digitsToString( mp, digits.substr(1), ans, cur_ans+mp[digits[0]-'0'][i] ); &#125; &#125;&#125;; 18、四数之和还是双指针操作（发现一个规律就是，前面这些和双指针操作相关的题目，一个典型的特点就是数组要先排个序），算法复杂度 $ O(n^3) $ ，其实有很多种解题方式。 第一种：双指针操作，先固定两个位置，然后 $ O(n) $ 的时间复杂度遍历剩下的元素，找解的过程中就去除可能存在的重复解，体现在代码中就是一片形式相同的while循环。 第二种：还是双指针操作，在求解的过程中，我不管解是否存在重复，一一加到ans里面，最后再进行一个去重处理。优点是编码简单，缺点是空间复杂度高，最坏情况下为$n^4$的空间复杂度（nums全为0，target也为0）。 第三种：以空间换时间，利用$ O(n^2) $的空间先求出两个数字的和，然后变成 两数之和 问题。 第四种：使用深搜操作，理论上来讲，此种方法可以求 m 数之和，时间复杂度为 $ O(n^{m-1}) $。 方案一代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; fourSum(vector&lt;int&gt;&amp; nums, int target) &#123; vector&lt; vector&lt;int&gt; &gt; ans; if( nums.size()&lt;4 ) return ans; sort( nums.begin(), nums.end() ); for( int i=0; i&lt;nums.size()-3; i++ )&#123; for( int j=i+1; j&lt;nums.size()-2; j++ )&#123; int f = j+1, e = nums.size()-1; while( f&lt;e )&#123; int sum = nums[i]+nums[j]+nums[f]+nums[e]; if( sum==target )&#123; vector&lt;int&gt; tmp_ans; tmp_ans.push_back(nums[i]); tmp_ans.push_back(nums[j]); tmp_ans.push_back(nums[f]); tmp_ans.push_back(nums[e]); ans.push_back( tmp_ans ); f++; while( f&lt;e &amp;&amp; nums[f-1]==nums[f] )&#123; f++; &#125; e--; while( e&gt;f &amp;&amp; nums[e+1]==nums[e] )&#123; e--; &#125; &#125; else if( sum&gt;target )&#123; e--; while( e&gt;f &amp;&amp; nums[e+1]==nums[e] )&#123; e--; &#125; &#125; else&#123; f++; while( f&lt;e &amp;&amp; nums[f-1]==nums[f] )&#123; f++; &#125; &#125; &#125; while( j+1&lt;nums.size()-2 &amp;&amp; nums[j+1]==nums[j] )&#123; j++; &#125; &#125; while( i+1&lt;nums.size()-3 &amp;&amp; nums[i+1]==nums[i] )&#123; i++; &#125; &#125; return ans; &#125;&#125;; 19、删除链表的倒数第N个节点一遍遍历即可，其实也是双指针的思想. 123456789101112131415161718192021222324/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: ListNode* removeNthFromEnd(ListNode* head, int n) &#123; ListNode *dummy = (ListNode*)malloc(sizeof(ListNode)); dummy-&gt;next = head; ListNode *f = dummy, *e = dummy; for( int i=1; i&lt;=n; i++ ) e = e-&gt;next; while( e-&gt;next )&#123; f = f-&gt;next; e = e-&gt;next; &#125; f-&gt;next = f-&gt;next-&gt;next; return dummy-&gt;next; &#125;&#125;; 20、有效的括号水题，使用栈匹配一下即可，遇到左括号进栈，遇见右括号出栈，最后判断栈是否为空。 123456789101112131415161718class Solution &#123;public: bool isValid(string s) &#123; stack&lt;char&gt; ans; ans.push('#'); //加栈底后期就不用判断空不空了 for( int i=0; i&lt;s.length(); i++ )&#123; if( s[i]=='(' || s[i]=='[' || s[i]=='&#123;' ) ans.push(s[i]); else&#123; if( (s[i]==')'&amp;&amp;ans.top()!='(') || (s[i]==']'&amp;&amp;ans.top()!='[') || (s[i]=='&#125;'&amp;&amp;ans.top()!='&#123;') ) return false; else ans.pop(); &#125; &#125; return ans.top()=='#'; &#125;&#125;;]]></content>
      <categories>
        <category>LeetCode</category>
        <category>LeetCode11-20</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[colab免费云GPU使用教程]]></title>
    <url>%2F2018%2F10%2F04%2Fcolab%E5%85%8D%E8%B4%B9%E4%BA%91GPU%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[谷歌coLab免费云GPU搭建教程网上教程的链接知乎 https://zhuanlan.zhihu.com/p/34436045 cnblogs http://www.cnblogs.com/kid551/p/8544908.html 1、注意第11步的代码替换成下列的代码： 1234567891011121314151617!apt-get install -y -qq software-properties-common software-properties-common module-init-tools!add-apt-repository -y ppa:alessandro-strada/ppa 2&gt;&amp;1 &gt; /dev/null!apt-get update -qq 2&gt;&amp;1 &gt; /dev/null!apt-get -y install -qq google-drive-ocamlfuse fusefrom google.colab import authauth.authenticate_user()from oauth2client.client import GoogleCredentialscreds = GoogleCredentials.get_application_default()import getpass!google-drive-ocamlfuse -headless -id=&#123;creds.client_id&#125; -secret=&#123;creds.client_secret&#125; &lt; /dev/null 2&gt;&amp;1 | grep URLvcode = getpass.getpass()!echo &#123;vcode&#125; | google-drive-ocamlfuse -headless -id=&#123;creds.client_id&#125; -secret=&#123;creds.client_secret&#125; 网上很多教程第一句中使用的是python-software-properties包，但是colab提供的操作系统是最新的18.04 ubuntu，使用该包会出错，显示E: Package &#39;python-software-properties&#39; has no installation candidate。所以改成使用software-properties-common。具体的，software-properties-common 包是 python-software-properties 的备用包，当系统版本在12.04一下，使用 python-software-properties，当系统版本在12.10以上，使用software-properties-common。 2、将google云盘当成一个盘符挂载到colab上 使用 google-drive-ocamlfuse 将云盘文件夹和远程的VM链接起来，方便文件共享操作。 12!mkdir -p drive!google-drive-ocamlfuse drive 路径：\content\drive\...,后期文件操作啥的就可以与云盘交互了。 3、取消挂载 1fusermount -u ***pathName*** 注意，colab一次只能免费使用最多12小时，过期会自动释放掉之前配置的虚拟环境，那么就需要每次使用时都执行上述操作，可以将其保存成一个文件，每次使用执行一下即可。]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ubuntu16.04安装Tensorflow-GPU]]></title>
    <url>%2F2018%2F10%2F04%2FUbuntu16-04%E5%AE%89%E8%A3%85Tensorflow-GPU%2F</url>
    <content type="text"><![CDATA[一、Ubuntu安装及TensorFlow-Gpu安装1、UEFI启动的ubuntu要将 \boot分区设置成 EFI分区，这样会在bios中出现启动项。注意EFI模式只识别FAT32的U盘启动盘。 2、安装 搜狗输入法 12345下载 sogou.debsudo dpkg -i sogou.deb #出现安装不成功，需要依赖sudo apt-get install -f #安装依赖sudo dpkg -i sogou.deb然后在设置里按照自己的需求设置 3、设置息屏时间 4、注意一定要安装好对应的显卡版本，在 设置 &gt;&gt; 软件和更新 &gt;&gt; 附加驱动里进行选择对应的显卡驱动nvidia；命令 nvidia-smi查看GPU驱动信息。 5、安装更新 sudo apt-get update sudo apt-get install vim 6、安装 及卸载Anaconda 官网下载对应的安装包，执行命令 bash Anaconda2-4.4.0-Linux-x86_64.sh 即可进行安装，期间会选择安装路径啥的，默认即可。 安装完成后，重启 命令窗口，执行 python 命令即可看到已经安装成功。如果不成功，执行 source ~/.bashrc命令，使 bashrc生效。 卸载的话： 删除整个anaconda的目录 rm -rf anaconda* 将 ~/.bashrc文件中的关于 anaconda的行注释掉 生效 source ~/.bashrc 7、命令 anaconda-navigator进入图形界面的操作。其实主要还是命令行操作，下面是 conda的常用命令。注意 conda是python的环境管理工具，兼具包管理；pip只是python的包管理工具而已。 8、conda常用命令： 12345678910111213141516171819202122232425262728293031323334353637conda --help #查看帮助conda update conda #升级condaconda update anaconda #升级anacondaconda --version 或者 conda -V #查看conda的版本conda info --envs #查看本地已创建的python运行环境，带*号的代表当前环境#创建python运行环境conda create --name &lt;env_name&gt; python=2.7/3.5/3.6#列出当前环境下所有活跃的包conda list#安装Python包conda install --name &lt;env_name&gt; &lt;package_name&gt;=version或者直接 activate 进入对应的环境中执行conda install &lt;package_name&gt;#更新python包conda update --name &lt;env_name&gt; &lt;package_name&gt;或者进入对应的环境执行conda update &lt;package_name&gt;#更新所有的包conda update --all#移除整个环境或者环境中的包conda remove --name &lt;env_name&gt; &lt;package_name&gt; #进去到对应的环境就可以不指定&lt;env_name&gt;conda remove --name &lt;env_name&gt; --all #将环境的包全部移除，相当于移除环境#查找包conda search --full-name &lt;package_name&gt; #精确查找conda search *&lt;package_name&gt;* #模糊查找#退出当前环境source deactivate &lt;env_name&gt;#激活当前环境source activate &lt;env_name&gt;#删除condarm -rf ~/anaconda 9、安装 tensorflow-gpu 使用conda创建一个python环境，并激活进入，在保证nvidia显卡驱动正常的情况下，在该环境只执行： 1conda install tensorflow-gpu=1.8/1.0/1.10/1.11 #我用的是1.9 此命令会自动帮你安装对应版本的 cudaToolKit， cupTi ， cuDNN SDK等等，十分强大，再也不用自己照着傻逼CSDN配置各种东西了。 10、查看 cuda 和 cuDNN版本 1234#cuda 版本 （9.0）cat /usr/local/cuda/version.txt#cudnn 版本 （7.3）cat /usr/local/cuda/include/cudnn.h | grep CUDNN_MAJOR -A 2 二、ubuntu安装pycharm1、去官网下载对应的 community版本，免费。 2、tar -xvzf **进行解压到当前文件夹中； 或者直接 extract提取 3、进入到对应的 bin 文件夹，执行命令 sh ./pycharm.sh进行安装 4、 设置桌面图标 1sudo gedit /usr/share/applications/pycharm.desktop 123456789[Desktop Entry]Type=ApplicationName=PycharmGenericName=Pycharm3Comment=Pycharm3:The Python IDEExec=&quot;/home/snakeson/developer/pycharm-community-2017.2.3/bin/pycharm.sh&quot; %f #注意替换Icon=/home/snakeson/developer/pycharm-community-2017.2.3/bin/pycharm.png #注意替换 Terminal=pycharmCategories=Pycharm; 1sudo chmod +x /usr/share/applications/pycharm.desktop #添加执行权限 1将/usr/share/applications/pycharm.desktop文件拷贝到桌面，双击即可运行。 5、卸载pycharm 所有的配置都保存在解压的目录中，所以卸载只要sudo rm -r **文件夹 默认会在 home目录创建一个 隐藏目录 sudo rm -r ~/.pycharm* 删除之前创建的 pycharm.desktop文件，这样，所有的东西就全卸载干净了。 6、之前使用 conda 创建的所有的python环境，在pycharm中都可以使用。既可以在创建项目的时候指定已存在的解释环境，也可以后期在设置中更改interpreter`选项。 7、pycharm中设置鼠标滚轮调节字体大小 在设置中 keymap ，搜索increase decrease 字段即可设置 鼠标快捷键 8、pycharm设置 菜单栏 字体及大小 在设置里 override default fonts by（not recommended)中修改。 9、自动生成新建Py文件的模板 file &gt;&gt; setting &gt;&gt; editor &gt;&gt; file and code templates中，选择python script文件，添加如下代码： 12345# _*_ coding: utf-8 _*_"""@author: spring371327@time: $&#123;DATE&#125; $&#123;TIME&#125;"""]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[算法课第一次作业]]></title>
    <url>%2F2018%2F10%2F04%2F%E7%AE%97%E6%B3%95%E8%AF%BE%E7%AC%AC%E4%B8%80%E6%AC%A1%E4%BD%9C%E4%B8%9A%2F</url>
    <content type="text"><![CDATA[一、Divide and Conquer You are interested in analyzing some hard-to-obtain data from two separate databases. Each database contains n numerical values, so there are 2n values total and you may assume that no two values are the same. You’d like to determine the median of this set of 2n values, which we will define here to be the n-th smallest value. However, the only way you can access these values is through queries to the databases. In a single query, you can specify a value k to one of the two databases, and the chosen database will return the kth smallest value that it contains. Since queries are expensive, you would like to compute the median using as few queries as possible. Give an algorithm that finds the median value using at most O(logn) queries. 1、problem-solving ideas and pseudo-code首先将现实问题转化一下，变成计算机算法问题，即 找2个有序数组的并集的中位数 ，LeetCode 第四题。 (1）problem-solving ideas 求中位数需要根据数组长度是奇数还是偶数分别讨论，奇数长度时中位数为最中间的一个数，偶数长度时中位数为最中间的两个数的平均值，为了方便，可以实现一个比题目更一般化的函数，求A和B的第k小数的函数，那么中位数的问题很容易解决。 求一个有序数组的第k个数只需要O(1)的复杂度，现在有两个数组，显然花费额外空间以O(n)时间归并然后O(1)寻找不满足题目要求。既然要求log时间复杂度，一般需要使用到二分思想。 分别考虑A和B的第k/2个元素： 如果它们相等，则第k个数为其中的任意一个 如果A中的比较大，则B中前k/2个元素都不可能是第k个数了，因为这个数至少应该为A的第k/2个数，把B的前k/2去掉，然后重新寻找。 如果B中的比较大，则把A的前k/2个数去掉，重新寻找。 直到A和B中某个变为空时或者寻找第1个数时可以停止递归，直接找到结果。 注意，上面的k/2只是理想的简单情况，实际上A和B的长度可能不够k/2，或者k为奇数等，但这些不是主要问题，可以让A取第k/2个数字，然后A不够长，则取A的最后一个数字，然后B取剩下长度对应的那个数字，具体参考代码。 (2）pseudo code 12345678910111213141516171819202122232425double findMedianSortedArrays(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2) &#123; int totalLength = nums1.size() + nums2.size(); if( totalLength&amp;1 ) return findKth( nums1.begin(), nums1.size(), nums2.begin(), nums2.size(), (totalLength&gt;&gt;1)+1 ); else //除以 2.0 是为了保留小数点 return (findKth( nums1.begin(), nums1.size(), nums2.begin(), nums2.size(), (totalLength&gt;&gt;1) ) + findKth( nums1.begin(), nums1.size(), nums2.begin(), nums2.size(), (totalLength&gt;&gt;1)+1 ))/2.0;&#125;int findKth( vector&lt;int&gt;:: iterator nums1, int len1, vector&lt;int&gt;:: iterator nums2, int len2, int k )&#123; // 默认 len1 要大于 len2 if( len1&lt;len2 ) return findKth( nums2, len2, nums1, len1, k ); if( len2==0 ) return nums1[k-1]; if( k==1 ) //k==1做特判，因为后期要移位, 不做特判point-1会出现负值 return min( nums1[0], nums2[0] ); int point2 = min( k&gt;&gt;1, len2 ); int point1 = k - point2; //下面对 nums1[point1-1] 和 nums2[point2-1]的大小关系进行讨论 if( nums1[point1-1] &gt; nums2[point2-1] ) return findKth( nums1, point1, nums2+point2, len2-point2, k-point2 ); else if( nums1[point1-1] &lt; nums2[point2-1] ) return findKth( nums1+point1, len1-point1, nums2, point2, k-point1 ); else return nums1[point1-1]; &#125; 2、subproblem reduction graph 3、prove the correctness寻找两个有序数组的第K大数，那么肯定是第1个数组贡献 a 个数，第二个数组贡献 K - a 个数。首先我们假设每个数组分别贡献 K/2个数，讨论 A[k/2] 和 B[k/2] 的大小情况。 当 A[k/2] &gt; B[K/2] 时，很显然需要减少数组A贡献的数字的个数，增加数组B贡献的数组的个数，如下图： 当 A[k/2] &lt; B[K/2] 时，很显然需要增加数组A贡献的数字的个数，减少数组B贡献的数组的个数，如下图： 随着算法的执行，搜索的数组长度不断缩小，最后一定会返回对应的中位数值。 4、the complexity of this algorithm分析可得： 五、Divide and Conquer Recall the problem of ﬁnding the number of inversions. As in the course, we are given a sequence of n numbers a1,··· ,an, which we assume are all distinct, and we deﬁne an inversion to be a pair i &lt; j such that ai &gt; aj. We motivated the problem of counting inversions as a good measure of how diﬀerent two orderings are. However, one might feel that this measure is too sensitive. Let’s call a pair a significant inversion if i &lt; j and ai &gt; 3aj. Given an O(nlogn) algorithm to count the number of signiﬁcant inversions between two orderings. 1、problem-solving ideas and pseudo-code(1）problem-solving ideas 求数列的逆序数，除了暴力求解方式外，也可以使用归并排序、树状数组、线段树等结构进行计算。此处选择使用归并排序。 首先，将数组从中间切开，分为左右两半，A[0…n/2] 和 A [n/2+1…n]，分别计算这两个子问题的显著逆序数； 然后，计算跨左右两边的数对所形成的显著逆序的个数。 最后，将这三者的显著逆序数求和，即为整个数组的显著逆序数。 (2）pseudo code 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455//统计变量num为全局变量void mergesort(int begin, int end)&#123; if (begin &gt;= end) return; int mid = (begin + end) / 2; mergesort(begin, mid); mergesort(mid + 1, end); mcount(begin, mid, end); merge(begin, mid, end);&#125;void mcount(int begin, int mid, int end)&#123; int i = begin; int j = mid + 1; int k = begin; while (i &lt;= mid &amp;&amp; j &lt;= end)&#123; if (a[i] &gt; 2 * a[j])&#123; num += mid - i + 1; j++; &#125; else i++; &#125;&#125; void merge(int begin, int mid, int end)&#123; int i = begin; int j = mid + 1; int k = begin; while (i &lt;= mid &amp;&amp; j &lt;= end)&#123; if (a[i] &gt; a[j])&#123; temp[k] = a[j]; k++; j++; &#125; else&#123; temp[k] = a[i]; k++; i++; &#125; &#125; while (i &lt;= mid)&#123; temp[k] = a[i]; k++; i++; &#125; while (j &lt;= end)&#123; temp[k] = a[j]; k++; j++; &#125; for (int p = begin; p &lt;= end; p++) a[p] = temp[p];&#125; 2、subproblem reduction graph先分： 后合： 3、prove the correctness其中，计算左右两边的显著逆序数的时候，会同时将左右两边的子数组变成有序。在计算跨两边的数对所形成的显著逆序的时候，就不用进行暴力遍历，只需O(n)的遍历即可。当 L[i] &gt; 3*R[j] 时，RC += |L|-i 即可，L中位于下标 i 之后的数字就不用遍历了，自然要比 3*R[j] 大。同时，计算过程是基于归并排序的，整个算法即正确。 4、the complexity of this algorithm计算左边的时间复杂度为 T(n/2)， 计算右边的时间复杂度为 T(n/2)， 合并的时间复杂度为 O(n)，所以总的时间复杂度为： 六、Divide and ConquerGiven a table M consisting of 2n ∗ 2n blocks, we want to ﬁll it with a L-shaped module (consisting of three blocks). The L-shaped module is shown below. Please give a ﬁll method, so that the last element of the table (M2n,2n) is empty. For example: 1、problem-solving ideas and pseudo-code(1）problem-solving ideas 有一个特殊方格的棋盘覆盖问题，只不过，此题目将特殊方格定死了，只能为最右下角那个，即 P(size-1,size-1)那个小方格。 该题关键在于如何划分各L型骨牌所在位置区域。我们发现，L型骨牌占三个方格，我们可以把棋盘从中央分为四块，那么这四块子棋盘中仅一块是有特殊方格的，可以用一块骨牌使得其他三块子棋盘均被覆盖。以此为原则，无论这种分法是否最终可解，我们首先保证了每个子棋盘都有一个特殊方格，所以，分治的模型就出来了。 我们可以用递归来完成分治的任务。每次递归，chess_board(int posx,int posy,int x,int y,int size)，(posx,posy)为子棋盘左上角坐标,size为子棋盘大小，因为棋盘总为正方形，所以size为边长，那么这3个参数就确定了子棋盘的位置和大小；(x,y)表示子棋盘中特殊方格的位置，这个位置是由上层递归分配骨牌后决定的。以此为标准，递归流程为： ①判断边界，若当前棋盘大小为1，则无法再分割，递归结束。 ②定子棋盘中心位置。 ③判断特殊方格所在位置（左上，右上，左下，或右下）。 ④根据特殊方格位置确定所选L型骨牌，原特殊方格和三个L型骨牌的方格分别为四个子棋盘的特殊方格。 ⑤依据④中判断，按编号填充棋盘。 ⑥4次递归，分别对应四个子棋盘。 (2）pseudo code 12345678910111213141516171819202122232425262728293031323334353637void chess_board(int posx,int posy,int x,int y,int size)&#123; if( size==1 ) return ; size /= 2; int num = Count++; //左上角 if( posx+size&gt;x &amp;&amp; posy+size&gt;y ) chess_board(posx,posy,x,y,size); else&#123; board[posx+size-1][posy+size-1] = num; chess_board(posx,posy,posx+size-1,posy+size-1,size); &#125; //右上角 if( y&gt;=posy+size &amp;&amp; x&lt;posx+size ) chess_board(posx,posy+size,x,y,size); else&#123; board[posx+size-1][posy+size] = num; chess_board(posx,posy+size,posx+size-1,posy+size,size); &#125; //左下角 if( x&gt;=posx+size &amp;&amp; y&lt;posy+size ) chess_board(posx+size,posy,x,y,size); else&#123; board[posx+size][posy+size-1] = num; chess_board(posx+size,posy,posx+size,posy+size-1,size); &#125; //右下角 if( x&gt;=posx+size &amp;&amp; y&gt;=posy+size ) chess_board(posx+size,posy+size,x,y,size); else&#123; board[posx+size][posy+size] = num; chess_board(posx+size,posy+size,posx+size,posy+size,size); &#125;&#125; 2、subproblem reduction graph假设有如下图的一个棋盘，棋盘中有一个特殊方格： 第一次分割： 第二次分割： 第三次分割： 第四次分割： 最后解的形式如下图所示（右下角空）： 3、prove the correctness使用数学归纳法： （1）k = 1 时, 有解 （2）k = 2 时，有解： （3）设 k-1 时成立(k&gt;2)，将 2^k 2^k 棋盘分割为 4 个 2^(k-1) 2^(k-1) 子棋盘，如下图所示： 特殊方格必位于 4 个较小子棋盘之一中，其余 3 个子棋盘中无特殊方格。为了将这 3 个无特殊方格的子棋盘转化为特殊盘，我们可以用一个 L 型骨牌覆盖这 3 个较小的棋盘的汇合处，如下图所示，这 3 个子棋盘上被 L 型骨牌覆盖的方格就成为该棋盘上的特殊方格，从而将原问题化为 4 个较小规模的棋盘覆盖问题。递归的使用这种分割，直至棋盘简化为 2^1x2^1 棋盘。 综上可得，该算法正确，最终可求得想要的结果。 4、the complexity of this algorithm算法的时间复杂度递推式如下： 即： 七、OJ第一题（寻找第K大数）12345678910111213141516171819202122232425262728293031323334353637383940#include &lt;bits/stdc++.h&gt;using namespace std;class Solution &#123;public: int findKthLargest(vector&lt;int&gt;&amp; nums, int k) &#123; vector&lt;int&gt; small, big; srand(time(NULL)); int pivotIndex = rand()%nums.size(); for( int i=0; i&lt;nums.size(); i++ )&#123; if( i==pivotIndex ) continue; if( nums[i]&gt;nums[pivotIndex] ) big.push_back(nums[i]); else small.push_back(nums[i]); &#125; if( big.size() == k-1 ) return nums[pivotIndex]; else if( big.size() &gt; k-1 ) return findKthLargest( big, k ); else return findKthLargest( small, k-big.size()-1 ); &#125;&#125;;int main()&#123; int n, k; cin &gt;&gt; n &gt;&gt; k; vector&lt;int&gt; vec; int num; for( int i=0; i&lt;n; i++ )&#123; scanf("%d", &amp;num); vec.push_back(num); &#125; Solution s; cout &lt;&lt; s.findKthLargest(vec,k) &lt;&lt; endl; return 0;&#125; 八、OJ第二题（二维最近点对）12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182#include &lt;bits/stdc++.h&gt;using namespace std;vector&lt; pair&lt;double, double&gt; &gt; point;double calcDist( pair&lt;double, double&gt; p1, pair&lt;double, double&gt; p2 )&#123; return (p1.first-p2.first)*(p1.first-p2.first) + (p1.second-p2.second)*(p1.second-p2.second);&#125;bool compare_x( pair&lt;double, double&gt; p1, pair&lt;double,double&gt; p2 )&#123; return p1.first&lt;p2.first;&#125;bool compare_y( pair&lt;double, double&gt; p1, pair&lt;double,double&gt; p2 )&#123; return p1.second&lt;p2.second;&#125;pair&lt; pair&lt;double, double&gt;, pair&lt;double, double&gt; &gt; solution( vector&lt; pair&lt;double, double&gt; &gt;&amp; vec )&#123; if( vec.size()&lt;=3 )&#123; //当点的个数小于3个时，直接暴力求解,想一下为啥是3 pair&lt; pair&lt;double, double&gt;, pair&lt;double, double&gt; &gt; ans = make_pair(vec[0], vec[1]); if( vec.size()==3 )&#123; double dst01 = calcDist( vec[0], vec[1] ); double dst12 = calcDist( vec[1], vec[2] ); if( dst01&gt;dst12 ) ans = make_pair(vec[1], vec[2]); double dst02 = calcDist( vec[0], vec[2] ); if( calcDist(ans.first, ans.second)&gt;dst02 ) ans = make_pair(vec[0], vec[2]); &#125; return ans; &#125; //分开,左右两部分 sort( vec.begin(), vec.end(), compare_x ); //并不是使用pivot，直接分一半过去 vector&lt; pair&lt;double, double&gt; &gt; pointLeft( vec.size()/2 ); copy( vec.begin(), vec.begin()+vec.size()/2, pointLeft.begin() ); vector&lt; pair&lt;double, double&gt; &gt; pointRight( vec.size() - vec.size()/2 ); copy( vec.begin()+vec.size()/2, vec.end(), pointRight.begin() ); pair&lt; pair&lt;double, double&gt;, pair&lt;double, double&gt; &gt; ansLeft = solution( pointLeft ); pair&lt; pair&lt;double, double&gt;, pair&lt;double, double&gt; &gt; ansRight = solution( pointRight ); double dst = calcDist(ansLeft.first, ansLeft.second); pair&lt; pair&lt;double, double&gt;, pair&lt;double, double&gt; &gt; ans = ansLeft; if( calcDist(ansLeft.first, ansLeft.second) &gt; calcDist(ansRight.first, ansRight.second) )&#123; ans = ansRight; dst = calcDist(ansRight.first, ansRight.second); &#125; //计算中间 double pivot = ( pointLeft[pointLeft.size()-1].first + pointRight[0].first ) / 2.0; vector&lt; pair&lt;double, double&gt; &gt; pointMiddle; for( int i=0; i&lt;vec.size(); i++ )&#123; if( (pivot-vec[i].first)*(pivot-vec[i].first) &lt; dst ) pointMiddle.push_back( vec[i] ); &#125; sort( pointMiddle.begin(), pointMiddle.end(), compare_y ); for( int i=0; i&lt;pointMiddle.size(); i++ )&#123; for( int j=1; j&lt;=7 &amp;&amp; (i+j)&lt;pointMiddle.size(); j++ )&#123; if( calcDist( pointMiddle[i], pointMiddle[i+j] ) &lt; dst )&#123; dst = calcDist( pointMiddle[i], pointMiddle[i+j] ); ans = make_pair( pointMiddle[i], pointMiddle[i+j] ); &#125; &#125; &#125; return ans;&#125;int main()&#123; int n; double x, y; cin &gt;&gt; n; for( int i=0; i&lt;n; i++ )&#123; scanf("%lf %lf", &amp;x, &amp;y); point.push_back( make_pair(x,y) ); &#125; pair&lt; pair&lt;double, double&gt;, pair&lt;double, double&gt; &gt; ans; ans = solution(point); double mindst = calcDist( ans.first, ans.second ); printf("%.2f\n", sqrt(1.0*mindst)); //cout &lt;&lt; "(" &lt;&lt; ans.first.first &lt;&lt; "," &lt;&lt; ans.first.second &lt;&lt; ")" &lt;&lt; ", (" &lt;&lt; ans.second.first &lt;&lt; "," &lt;&lt; ans.second.second &lt;&lt; ")" &lt;&lt; endl; return 0;&#125;]]></content>
      <categories>
        <category>作业</category>
        <category>算法课第一次作业</category>
      </categories>
      <tags>
        <tag>作业</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[矩阵求导]]></title>
    <url>%2F2018%2F09%2F29%2F%E7%9F%A9%E9%98%B5%E6%B1%82%E5%AF%BC%2F</url>
    <content type="text"><![CDATA[最近上课，各种机器学习，深度学习的求导公式，直接蒙圈了，一个不错的教程文档，分享一下。]]></content>
      <categories>
        <category>资料</category>
      </categories>
      <tags>
        <tag>资料</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode1-10]]></title>
    <url>%2F2018%2F09%2F28%2FLeetCode1-10%2F</url>
    <content type="text"><![CDATA[1、两数之和123456789101112131415161718class Solution &#123;public: vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; nums, int target) &#123; unordered_map&lt;int, int&gt; Map; vector&lt;int&gt; ans; for(int i=0; i&lt;nums.size(); i++) Map[nums[i]] = i; for(int i=0; i&lt;nums.size(); i++)&#123; int tmp = target - nums[i]; if( Map.count(tmp) &amp;&amp; Map[tmp]!=i )&#123; ans.push_back(i); ans.push_back(Map[tmp]); break; &#125; &#125; return ans; &#125;&#125;; 2、两数相加1234567891011121314151617181920212223242526272829303132/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) &#123; ListNode* res = new ListNode(0); ListNode* tmp = res; int sum = 0; while( l1 || l2 )&#123; if( l1 )&#123; sum += l1-&gt;val; l1 = l1-&gt;next; &#125; if( l2 )&#123; sum += l2-&gt;val; l2 = l2-&gt;next; &#125; tmp-&gt;next = new ListNode(sum%10); tmp = tmp-&gt;next; sum /= 10; &#125; if( sum ) tmp-&gt;next = new ListNode(sum); return res-&gt;next; //解决的很是巧妙 &#125;&#125;; 3、无重复字符的最长子串1234567891011121314151617181920class Solution &#123;public: int lengthOfLongestSubstring(string s) &#123; int ans = 0; int i, j; map&lt;char, int&gt; mp; for( i=0,j=0; j&lt;s.length(); j++ )&#123; if( mp.count(s[j]) == 0 )&#123; //map中之前不含有此元素 mp.insert(make_pair( s[j], j )); &#125; else&#123; //map中之前含有此元素 ans = max( ans, j-i ); i = max( mp[s[j]]+1, i ); mp[s[j]] = j; &#125; &#125; ans = max( ans, j-i ); //到字符串的结尾了，需要处理 return ans; &#125;&#125;; 4、两个排序数组的中位数12345678910111213141516171819202122232425262728class Solution &#123;public: double findMedianSortedArrays(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2) &#123; int totalLength = nums1.size() + nums2.size(); if( totalLength&amp;1 ) return findKth( nums1.begin(), nums1.size(), nums2.begin(), nums2.size(), (totalLength&gt;&gt;1)+1 ); else //除以 2.0 是为了保留小数点 return (findKth( nums1.begin(), nums1.size(), nums2.begin(), nums2.size(), (totalLength&gt;&gt;1) ) + findKth( nums1.begin(), nums1.size(), nums2.begin(), nums2.size(), (totalLength&gt;&gt;1)+1 ))/2.0; &#125; int findKth( vector&lt;int&gt;:: iterator nums1, int len1, vector&lt;int&gt;:: iterator nums2, int len2, int k )&#123; // 默认 len1 要大于 len2 if( len1&lt;len2 ) return findKth( nums2, len2, nums1, len1, k ); if( len2==0 ) return nums1[k-1]; if( k==1 ) //k==1做特判，因为后期要移位, 不做特判point-1会出现负值 return min( nums1[0], nums2[0] ); int point2 = min( k&gt;&gt;1, len2 ); int point1 = k - point2; //下面对 nums1[point1-1] 和 nums2[point2-1]的大小关系进行讨论 if( nums1[point1-1] &gt; nums2[point2-1] ) return findKth( nums1, point1, nums2+point2, len2-point2, k-point2 ); else if( nums1[point1-1] &lt; nums2[point2-1] ) return findKth( nums1+point1, len1-point1, nums2, point2, k-point1 ); else return nums1[point1-1]; &#125;&#125;; 5、最长回文子串Manacher算法，国内也叫“马拉车”。虽然 RL[i]=min(RL[2*pos-i], MaxRight-i)，但是位于 i 半径右边界与 MaxRight之间的元素是不会被重复遍历的，否则会与 i 的对称 j 起冲突，也正因为如此，算法的复杂度是 O(n)。 12345678910111213141516171819202122232425262728293031323334353637class Solution &#123;public: string longestPalindrome(string s) &#123; string newString = "#"; for( int i=0; i&lt;s.length(); i++ )&#123; newString += s[i]; newString += "#"; &#125; int maxLen = 0, maxLenIndex = 0; int maxRight=0, pos=0; //代表当前最右及其对应中心元的位置 int radius[newString.length()]; for( int i=0; i&lt;newString.length(); i++ )&#123; if( i&lt;maxRight ) radius[i] = min( radius[2*pos-i], maxRight-i+1 ); //注意这里的 +1 else radius[i] = 1; while( (i+radius[i])&lt;newString.length() &amp;&amp; (i-radius[i])&gt;=0 &amp;&amp; newString[i+radius[i]]==newString[i-radius[i]] )&#123; // i+radius[i]-1为当前所到位置 radius[i] += 1; &#125; //更新 maxRight 和 pos if( (i+radius[i]-1)&gt;maxRight )&#123; maxRight = i+radius[i]-1; pos = i; &#125; if( maxLen&lt;radius[i] )&#123; maxLen = radius[i]; maxLenIndex = i; &#125; &#125; string ansString = ""; for( int i=maxLenIndex-radius[maxLenIndex]+1; i&lt;maxLenIndex+radius[maxLenIndex]-1; i++ )&#123; if( newString[i]!='#' ) ansString += newString[i]; &#125; return ansString; &#125;&#125;; 6、Z字形变换规律题，多些几个即可找到下标间的规律。 123456789101112131415161718192021222324252627282930class Solution &#123;public: string convert(string s, int numRows) &#123; if( numRows==1 ) return s; string ans = ""; int total = 2*numRows - 2; int curNum, pos; pos = 0; do&#123; ans += s[pos]; pos += total; &#125;while( pos&lt;s.length() ); for( int i=1; i&lt;numRows-1; i++ )&#123; curNum = total - 2*i; pos = i; do&#123; ans += s[pos]; pos += curNum; curNum = total - curNum; &#125;while( pos&lt;s.length() ); &#125; pos = numRows - 1; do&#123; ans += s[pos]; pos += total; &#125;while( pos&lt;s.length() ); return ans; &#125;&#125;; 7、反转整数12345678910111213141516class Solution &#123;public: int reverse(int x) &#123; long long int num = 0; int flag = x&lt;0? -1:1; x = abs(x); do&#123; num = 10*num + x%10; x /= 10; &#125;while(x); num = num*flag; if( num&gt;INT_MAX || num&lt;INT_MIN ) num = 0; return int(num); &#125;&#125;; 8、字符串转整数 (atoi)一个简单的模拟题，但不得不说leetcode的测试用例真的是强，考虑了 -1 ，给我报 +1的错，两者都考虑了，报了 -+1 的错，真的每一个可能但错误的细节都考虑到了，强！ 12345678910111213141516171819202122232425262728293031323334class Solution &#123;public: int myAtoi(string str) &#123; //先将开始的空余字符去掉 for( int index=0; index&lt;str.length(); index++ )&#123; if( str[index]!=' ' )&#123; str = str.substr(index); break; &#125; &#125; int flag = 1; if( str[0]=='-' )&#123; flag = -1; str = str.substr(1); &#125; else if( str[0]=='+' )&#123; flag = 1; str = str.substr(1); &#125; long long num = 0; for( int i=0; i&lt;str.length(); i++ )&#123; if( str[i]&gt;='0' &amp;&amp; str[i]&lt;='9' )&#123; num = num*10 + (str[i]-'0'); if( flag*num &lt; INT_MIN ) return INT_MIN; else if( flag*num &gt; INT_MAX ) return INT_MAX; &#125; else break; &#125; return flag*num; &#125;&#125;; 9、回文数将数字倒过来，比较前后两个数是否相同即可。 123456789101112class Solution &#123;public: bool isPalindrome(int x) &#123; if( x&lt;0 ) return false; int y = 0, tmp_x = x; while( tmp_x )&#123; y = 10*y+(tmp_x%10); tmp_x /= 10; &#125; return x==y; &#125;&#125;; 10、正则表达式匹配动态规划的思想来解决这道题目，对于动态规划类的题目，是比较难的，难在状态转移方程写不出来。 首先，dp[i][j]表示 s 中前 i 个字符和 p 中的前 j 个字符是否匹配。下面对 p 中的第 j 个字符是否是 * 号进行分类讨论（至于为啥是以*号为关键字符进行讨论，自己想想，脑补脑补）。 1、 p[j-1] != &#39;*&#39;： 只需要比较 s[i-1] 和 p[j-1] 是否匹配即可，匹配的条件为 s[i-1]==p[j-1] || p[j-1]==&#39;.&#39;，转移方程为： dp[i][j] = dp[i-1][j-1] &amp;&amp; (s[i-1]==p[j-1] || p[j-1]==&#39;.&#39;) 2、p[j-1] == &#39;*&#39;，分3类情况讨论： p[j-1] 的 * 号不起作用，也就是没匹配，此情况下 p[j-2] 和 p[j-1]是作废的，转移方程: dp[i][j] = dp[i][j-2] p[j-1] 的 * 号匹配一个字符，也就是 P 中的 p[j-2] 和 p[j-1] 所组成的元素和 S 中的 s[i-1]相匹配，所以状态转移方程为： dp[i][j] = dp[i-1][j-2] &amp;&amp; (s[i-1]==p[j-2] || p[j-2]==&#39;.&#39;) p[j-1] 的 * 号匹配多个字符(&gt;=2)，如下图所示，很容易写出状态转移方程为： dp[i][j] =dp[i-1][j] &amp;&amp; (s[i-1]==p[j-2] || p[j-2]==&#39;.&#39;) 综上所述，总状态转移方程为： 接下来，对初始状态进行讨论： 当 S 不空， P 为空时，dp[i][0] = false 当 S 空， P 不空时： j%2!=0 时，dp[0][j] = false j%2==0 时， dp[0][j] = dp[0][j-2] &amp;&amp; p[j-1]==&#39;*&#39; 有了以上的分析，代码基本也就写完了，如下： 123456789101112131415161718192021222324252627class Solution &#123;public: bool isMatch(string s, string p) &#123; int m = s.length(), n = p.length(); bool dp[m+1][n+1]; dp[0][0] = true; //都为空，肯定匹配 // P为空 for( int i=1; i&lt;=m; i++ ) dp[i][0] = false; // S为空 for( int j=1; j&lt;=n; j++ )&#123; if( j%2==0 ) dp[0][j] = ( dp[0][j-2] &amp;&amp; (p[j-1]=='*') ); else dp[0][j] = false; &#125; for( int i=1; i&lt;=m; i++ )&#123; for( int j=1; j&lt;=n; j++ )&#123; if( p[j-1]!='*' ) dp[i][j] = dp[i-1][j-1] &amp;&amp; ( s[i-1]==p[j-1] || p[j-1]=='.' ); else dp[i][j] = dp[i][j-2] || ( ( dp[i-1][j-2] || dp[i-1][j] ) &amp;&amp; (s[i-1]==p[j-2] || p[j-2]=='.')); &#125; &#125; return dp[m][n]; &#125;&#125;;]]></content>
      <categories>
        <category>LeetCode</category>
        <category>LeetCode1-10</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[GitHub Pages+Hexo+Next博客搭建记录]]></title>
    <url>%2F2018%2F09%2F22%2FGitHub-Pages-Hexo-Next%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E8%AE%B0%E5%BD%95%2F</url>
    <content type="text"><![CDATA[1、前言 大二的时候看见学长搭建的个人博客，感觉好高大上的样子，想着自己啥时候不再是哪个只会喊：哇、牛批、666、厉害厉害的傻逼选手，然后浪啊浪，突然有一天，CSP考试上考到了一个Markdown转HTML的大模拟题：现场狂写2小时，黑箱测试最后只得20分，从此心理对MD留下了挥之不去的阴影，然后就没有了然后，此事不来了了之。大二的时候在CSDN上写过，但是感觉CSDN的广告是越来也严重了，上面，下面，左面，右面等等四面八方全是各种广告，于是乎，时隔三年，趁着中秋没钱出去浪啊，舍友也回家了，丧尸宿舍也搭建一个简单的个人博客吧，此文简单记录一下搭建过程。本文使用的是 Github pages + Hexo + Next 主题。 2、基础环境搭建2.1 注册GitHub账号并创建IO仓库 GitHub作为全球最大的同性交友网站，在程序员心中的地位不亚与PornHub在宅男心中的地位，有过之而无不及啊，登录官网填写相关信息进行账号注册，然后创建一个和注册名相同的仓库(Repository)，注意一定要是下图这种格式[username.github.io]，因为github page每个账号只有一个。 现在，已经可以通过https://wangjibao.github.io/来访问了，后面还会在这上面做更多的设置。 2.2 安装node.js Hexo是基于Node.js的，其实Node.js就是一个JavaScript的运行环境，用来生成我们所写的静态博客页面，去官网下载安装即可，并且会自动加入系统环境变量中。 其中的 npm(Node Package Manager) 是随 node.js 一起安装的包管理工具，能解决NodeJS代码部署上的很多问题。常用命令如下: 123456npm install npm -g #安装新版本的npmnpm install #安装npm依赖包npm install &lt;Mouble Name&gt; #安装包，分为全局安装和本地安装，全局安装添加 -g 参数npm uninstall &lt;Mouble Name&gt; #卸载包npm update &lt;Mouble Name&gt; #更新包npm list -g #列出所有的全局安装包 2.3 安装Ｇit并配置SSH Key Git是一个流行的版本控制工具，使用它和GitHub进行交互。前往Git官网下载安装到本地即可。 因为你要提交代码到GitHub必须得拥有权限，但是直接使用用户名+密码不安全，所以使用 SSH Key来解决本地和服务器的连接问题。 在Git Bash中执行： cd ~/.ssh ，检查本机存在的ssh秘钥。如果提示： No such file or directory 说明你是第一次使用git。 ssh-keygen -t rsa -C &quot;17600****26@163.com&quot; 按照提示操作，最终会在用户目录下生成一个id_rsa.pub文件，这就是自己的公钥。复制里面的字符串到自己的GitHub中，settings &gt;&gt; SSH and GPG keys &gt;&gt; New SSH Key。 执行如下命令，测试是否添加成功： `ssh -T git@github.com` 同时在git bash中进行如下配置: 12git config --global user.name &quot;wangjibao&quot; #github用户名git config --global user.email &quot;17600****26@163.com #github注册邮箱 2.4 安装sublime Sublime Text3，很方便快捷的代码编辑器，后期的很多文件修改编辑操作要借助此工具进行。官网下载安装的软件本身是付费的，但我大天朝能用付费的软件，呵，开玩笑！百度一发好多激活码直接用。 2.5 安装hexo 在某个目录下建一个文件夹，此文件夹作为hexo的工作区。在该文件夹中 Git Bash Here，执行如下命令安装hexo： npm install -g hexo 安装完成后，hexo -v 查看安装版本及是否安装成功。执行 hexo init，对此工作文件夹进行初始化（特别注意，此文件夹初始必须是空的，否则会报错）。完成后，将生成如下目录结构的文件树 其中_config.yml是全局配置文件，_posts是放置博客文章的文件夹，具体各文件功能查看这里。此时，我们执行 hexo server来启动Hexo服务，在浏览器中输入 http://localhost:4000查看初始效果。 常用的 Hexo命令如下： 1234567hexo -v #查看版本信息hexo new &quot;tilte&quot; #创建新文章，放在\source\_posts目录下hexo new page *** #创建页面hexo generate #用来生成静态文件，简写： hexo ghexo server #开启服务器实现本地预览功能，简写： hexo shexo deploy #部署网址，上传到github仓库，简写： hexo dhexo clean #清除缓存(db.json)和已生成的静态文件(public),例如在更换博客主题后执行该命令 2.6 域名购买及解析 前往阿里云购买属于自己的域名，当然，不买也是可以的，直接使用 wangjibao.github.io也能访问博客，只是为了博客更加个性化一点，遂购买一个属于自己的域名。购买完成后，前往域名解析页面设置域名解析，如下图： 其中第二行的IP地址是在cmd命令框中通过 ping wangjibao.github.io 命令得到。同时，在github pages的设置页面，填写购买的域名。 最后，在source文件夹中新建名为 CNAME的文件，在文件中填入www.wangjibao.com.cn；执行 hexo g -d命令，此时，即可通过在浏览器中的地址栏输入 www.wangjibao.com.cn 进行博客的浏览。 2.7 本地与Github连接 之前已经配置好了SSH Key，此时只要修改一下_config.yml文件即可轻松实现本地博文发布。修改_config.yml如下： 其中repository的值在下图中获得，注意，此处每个字段的冒号后面都跟有一个空格，否则会出错。 在发布博文前，执行如下命令安装必要的插件： npm install hexo-deployer-git --save 2.8 配置NexT主题NexT的官方说明文档，将各基础配置讲述得非常清楚，按照官方文档一步一步配置即可。包括： 安装NexT 下载主题 启用主题 验证主题 主题设定 选择Scheme（此处选用Gemini主题） 设置语言（zh-Hans） 设置菜单 设置侧栏 设置头像 设置作者昵称 设置站点描述 设置RSS（hexo install hexo-generator-feed --save） 添加标签页面 添加分类页面 设置字体 设置代码高亮主题（night eighties） 侧边栏社交链接 开启打赏功能 设置友情链接 腾讯公益404页面 此处官网提供的是 http模式的404页面，在https模式下蹦出的404页面会出现排版问题，如firefox会报 Mixed Active Content警告，如图： 两种解决方案，一种是关掉浏览器对此站点的保护功能，但却不是很实用，因为你不能要求所有人解除对你站点的保护。 第二种解决方案是，将官网提供的404页面的代码做一下修改，具体如下： 12345678910111213&lt;!DOCTYPE HTML&gt;&lt;html&gt;&lt;head&gt; &lt;meta http-equiv="content-type" content="text/html;charset=utf-8;"/&gt; &lt;meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" /&gt; &lt;meta name="robots" content="all" /&gt; &lt;meta name="robots" content="index,follow"/&gt;&lt;/head&gt;&lt;body&gt; &lt;script type="text/javascript" src="//qzonestyle.gtimg.cn/qzone/hybrid/app/404/search_children.js" homePageName="返回主页" homePageUrl="https://ymwangzhuan.com"&gt; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 可以看到，改版后的404页面的src字段并没有指明使用的是http协议还是https协议，会自动根据你的站点做适配，问题完美解决[注意将404.html放到站点根目录的source文件夹中]。 站点建立时间 订阅微信公众号 设置背景动画 3、NexT主题个性化设计3.1 设置网站图标 Favicon在网上找一张32*32大小的 ico 图标，当然，不是 ico 格式也是可以的，如 png 等。将图标放到目录 \thems\next\source\imges 文件夹中，然后修改主题配置文件即可，操作如下图： 作为抓包组中的一员，搭建的博客必须上 wireshark 图标啊，皮一波~~，效果如下图： 3.2 修改文章底部 # 号标签样式在 \themes\next\layout\_macro\post.swing 文件中搜索 rel=&quot;tag&quot;&gt;# ，将 # 号替换成 &lt;i class=&quot;fa fa-tag&quot;&gt;&lt;/i&gt;，如下图： 3.3 文章末尾添加 本文结束 标记添加本文结束标记的步骤，其实也是主题编写的基本步骤，主要分3步： 添加模板文件 在目录 themes\next\layout\_macro中新建名为 passage-end-tag.swig的文件，并添加如下代码： 1234567&lt;div&gt; &#123;% if not is_index %&#125; &lt;div style="text-align:center;color: #ccc;font-size:14px;"&gt; -------------本文结束&lt;i class="fa fa-paw"&gt;&lt;/i&gt;感谢您的阅读------------ &lt;/div&gt; &#123;% endif %&#125; &lt;/div&gt; 导入模板文件 在文件 themes\next\layout\_macro\post.swig中找到如下代码块（第332行）: 123&#123;#####################&#125;&#123;### END POST BODY ###&#125;&#123;#####################&#125; 在此代码块的上面添加如下代码： 12345&lt;div&gt; &#123;% if not is_index %&#125; &#123;% include 'passage-end-tag.swig' %&#125; &#123;% endif %&#125;&lt;/div&gt; 配置 在主题配置文件中添加 passage-end-tag 字段，并设置为 true ： 123# 文章末尾添加“本文结束”标记passage_end_tag: enabled: true 最终效果为： 3.4 添加顶部加载条在next主题的配置文件 _config.yml 中搜索关键词 pace ，设置为 true ，还可以设置加载条的样式，修改如下图所示： 3.5 隐藏网站底部 由hexo强力驱动方案一：在目录 themes\next\layout\_partials\中打开 footer.swig文件，将对应网站底部的描述部分给注释掉即可，html的注释符 &lt;!-- **** --&gt;： 方案二：在主题配置文件中，配置 powred字段和theme字段，将其用 #号注释掉： 两者都能实现下图所示的效果： 3.6 博文置顶使用 top 属性， top 值越大，排序就越靠前，如果文章不设置 top 属性，就按照博文的推送时间排序。如果使用的next主题在5.1之后，会自带此功能，修改站点配置文件中的 order_by字段即可；如果使用的是更老的版本，修改node_modules\hexo-generator-index\lib\generator.js中的内容即可，在var posts =那一行的后面添加如下博文排序函数： 12345678910111213posts.data = posts.data.sort(function(a, b) &#123; if(a.top &amp;&amp; b.top) &#123; // 两篇文章top都有定义 if(a.top == b.top) return b.date - a.date; // 若top值一样则按照文章日期降序排 else return b.top - a.top; // 否则按照top值降序排 &#125; else if(a.top &amp;&amp; !b.top) &#123; // 以下是只有一篇文章top有定义，那么将有top的排在前面（这里用异或操作居然不行233） return -1; &#125; else if(!a.top &amp;&amp; b.top) &#123; return 1; &#125; else return b.date - a.date; // 都没定义按照文章日期降序排&#125;); 这里我们使用第二种方案，每次写文章的时候，都要手动添加 top 属性，很麻烦，这里，我们可以修改 scaffolds\post.md 文件，修改后的内容如下，其实相当于创建了一个博文的初始模板。 到此，如果文章设置了 top 属性并有值得话，根据 top 值排序，没有的话，按照博文的推送时间排序。 3.7 添加分享NexT主题支持多种方式的分享，包括 Baidu Share 、duoshuo_share、needMoreShare2、jiathis等等，这里我们使用needMoreShare2，在主题配置文件中修改对应的字段如下图所示，资深抓包民工表示对这里的很多软件好熟悉~，怕是要被打~ 修改后，执行 hexo g -d指令，效果如图： 3.8 显示当前页面的浏览进度在主题配置文件中 ctrl+f 搜索 scrollpercent，将 false 改为 true。如果想把 top按钮放在侧边栏，可以把 b2t字段设置为true ，实现效果如图所示： 3.9 首页博文自动卷起在首页显示一篇文章的部分内容，并提供一个链接跳转到全文页面是一个常见的需求。NexT 提供三种方式来控制文章在首页的显示方式。也就是说，在首页显示文章的摘录并显示 阅读全文 按钮，可以通过以下方法： 在文章中使用 &lt;!-- more --&gt; 手动进行截断，Hexo 提供的方式 在文章的 front-matter中添加 description，并提供文章摘录 自动形成摘要，在主题配置文件中将 auto_excerpt设置成 true ，并自行设定自动截取长度（默认150） 这里，我们使用第一种方式，实现效果如下图： 3.10 实现鼠标点击出现桃心将 love.js文件添加到主题目录的\source\js\src 下，找到 \themes\next\layout\_layout.swig文件， 在文件的后面， &lt;/body&gt;标签之前 添加以下代码： 12&lt;!-- 页面点击小红心 --&gt;&lt;script type="text/javascript" src="/js/src/love.js"&gt;&lt;/script&gt; 实现效果为每次鼠标点击页面的时候，会出现一个彩色的桃心，如下图所示： 3.11 添加站内搜索NexT主题支持多种搜索插件，我们这里使用 hexo-generator-searchdb插件，原理是在本地生成一个search.xml文件，搜索的时候从这个文件中根据关键字检索出相应的链接。首先执行 npm install hexo-generatordb --save 指令进行插件的安装，之后将下面的代码复制进站点配置文件的末尾。 12345search: path: search.xml field: post format: html limit: 10000 然后将主题配置文件中的对应字段设置为 true 即可。 最终，会在网站的侧栏出现搜索 选项，搜索效果如下图所示： 3.12 生成站点地图站点地图是一种文件，可以通过该文件列出网站上的网页，从而可以将个人网站内容的组织架构告知 baidu、google等搜索引擎。搜索引擎的网页爬取工具会读取此文件，以便更加高效的爬取个人网站。 1、先安装对应的插件，以下两个插件对应的是 baidu 和 google 12npm install hexo-generator-sitemap --savenpm install hexo-generator-baidu-sitemap --save 2、在站点配置文件中添加如下代码： 12345# auto create sitemapsitemap: path: sitemap.xmlbaidusitemap: path: baidusitemap.xml 运行指令 hexo g -d ，在public目录下会发现生成了 sitemap.xml 和 baidusitemap.xml 两个文件，这表示成功了。接下来就是如何操作让百度、谷歌收录我们的博客了。 3、站点收录，由于并没有想被搜索引擎检索的需求，私下里自己先玩一玩，所以，此项，To Do…. 3.13 实现统计功能在Hexo的根目录下执行 npm install hexo-wordcount --save 指令，进行字数统计模块的安装，然后修改主题配置文件，将对应的开关打开，即 false 改为true。 使用 sublime打开文件 \themes\next\layout\_macro\post.swig ，ctrl+f搜索如下代码字段，并在后面添加字、分钟。 123456&lt;span title="&#123;&#123; __('post.wordcount') &#125;&#125;"&gt; &#123;&#123; wordcount(post.content) &#125;&#125; 字&lt;/span&gt;&lt;span title="&#123;&#123; __('post.min2read') &#125;&#125;"&gt; &#123;&#123; min2read(post.content) &#125;&#125; 分钟&lt;/span&gt; 最终的效果图，如下： 3.14 上传本地图片在站点配置文件中将 post_asset_folder字段设置为 true，同时安装对应的插件 npm install hexo-asset-image --save。以后运行hexo n &quot;xxxx&quot;来生成md博文时，/source/_posts文件夹内除了xxxx.md文件还有一个同名的文件夹，该文件夹用于存储本地图片。在xxxx.md中想引入图片时，先把图片复制到xxxx这个文件夹中，然后只需要在xxxx.md中按照markdown的格式引入图片：![你想输入的替代文字](xxxx\图片名.jpg) 3.15 添加近期文章模块将下面的代码贴在 next/layout/_macro/sidebar.swig 中的 if theme.links 对应的 endif 后面，就ok了，是不是很简单。 1234567891011121314151617&#123;% if theme.recent_posts %&#125; &lt;div class=&quot;links-of-blogroll motion-element &#123;&#123; &quot;links-of-blogroll-&quot; + theme.recent_posts_layout &#125;&#125;&quot;&gt; &lt;div class=&quot;links-of-blogroll-title&quot;&gt; &lt;!-- modify icon to fire by szw --&gt; &lt;i class=&quot;fa fa-history fa-&#123;&#123; theme.recent_posts_icon | lower &#125;&#125;&quot; aria-hidden=&quot;true&quot;&gt;&lt;/i&gt; &#123;&#123; theme.recent_posts_title &#125;&#125; &lt;/div&gt; &lt;ul class=&quot;links-of-blogroll-list&quot;&gt; &#123;% set posts = site.posts.sort(&apos;-date&apos;) %&#125; &#123;% for post in posts.slice(&apos;0&apos;, &apos;5&apos;) %&#125; &lt;li&gt; &lt;a href=&quot;&#123;&#123; url_for(post.path) &#125;&#125;&quot; title=&quot;&#123;&#123; post.title &#125;&#125;&quot; target=&quot;_blank&quot;&gt;&#123;&#123; post.title &#125;&#125;&lt;/a&gt; &lt;/li&gt; &#123;% endfor %&#125; &lt;/ul&gt; &lt;/div&gt;&#123;% endif %&#125; 为了配置方便，在主题的 _config.yml 中添加了几个变量，如下： 123recent_posts_title: 近期文章recent_posts_layout: blockrecent_posts: true 3.16 右上角加fork me on github点击这里或者这里挑选你喜欢的样式，修改成你的GitHub链接，复制到themes/next/layout/_layout.swig文件中的以下位置： 123&lt;div class="&#123;&#123; container_class &#125;&#125; &#123;% block page_class %&#125;&#123;% endblock %&#125;"&gt; &lt;div class="headband"&gt;&lt;/div&gt; &lt;a href="https://github.com/wangjibao" ......&lt;/a&gt; 3.17 添加 latex 数学公式支持在 next 主题中，已经自动支持 mathjax 了，只需要在配置文件中将开关打开即可，不用像很多博客说的换markdown渲染引擎，更改markdown和latex的语法冲突，安装mathjax插件等等那么麻烦。 在主题配置文件中搜索 mathjax ，将开关设置为 true ，其中的 per_page字段如果设置为 true ，那么只有主页和文章头部带有mathjax: true 字段的博文才会加载 mathjax引擎。这里注意下，要更改默认的 cdn 地址，之前的地址已经停用了。 详见：https://github.com/iissnan/hexo-theme-next/pull/1712 https://github.com/iissnan/hexo-theme-next/pull/887 3.18 启用点击下载功能在网站的source目录下，新建download目录，和_posts、About、tags、categories等目录并列。然后，将需要分享的文件或者图片统一放到该download下。在写文章时，通过诸如[点击下载](/download/xx.exe)这样的链接，直接写入。 效果图： 4、集成第三方服务4.1 Valine评论系统针对评论系统来讲的话，多说和网易云已经倒了，畅言需要备案，Disqus，Hypercomments和LiveRe等都是国外的，不仅加载速度慢还容易被墙，找来找去，决定使用valine（2017年8月诞生的一款基于LeanCloud的极简风评论系统）。NexT主题本身就已经集成了valine，所以设置起来也比较简单。 4.1.1 注册LeanCloud，获取appid和appkey在官网注册账号并创建应用，应用选择开发版即可，毕竟穷孩子，免费的好啊。应用名字随便起，创建完成后，在 设置 &gt;&gt; 应用key 中可以看到此应用的appid和appkey。 4.1.2 配置web安全域名为了数据安全，在 设置 &gt;&gt; 安全中心中设置web安全域名，如下图： 4.1.3 创建Class对象在 存储 &gt;&gt; 数据栏中，创建两个Class，一个名为Counter，用于记录统计每篇博文的阅读次数；另一名为Comment用于记录存储每篇博文的评论。注意，此处两个Class的名字是固定的，不能更改。 可以手动修改 Counter表中time字段的值，也就是修改了博文的阅读次数，美滋滋~~~ 4.1.4 修改主题配置文件搜索 leancloud字段，将 enable字段设置为 true，app_id和app_key填写之前获得的值，此时，就可以在页面中启用博文阅读次数统计功能。 搜索valine字段，将 enable字段设置为 true，app_id和app_key填写之前获得的值，此时，就可以在页面中启用博文评论及回复功能。其中的notify字段代表有评论时邮件提醒，verify字段代表开启验证码，avatar代表评论者的头像，placeholder字段代表初始评论框中显示的文字，等等。。。 4.1.5 最终效果展示后台数据管理： 阅读次数统计： 底部评论区： 4.1.6 邮件提醒功能配置至此，已经能够使用评论系统了，但它虽然支持邮件提醒（基于密码重置提醒邮件），功能却很弱，无法提示到具体文章，也无法给评论者进行有效的回复通知，通常别人留完言，怎么还会再来你的博客看你是否回复了呢？所以，这里我们引用GitHub上某位大佬的配置，它满足了： 完善的邮件通知，自定义 SMTP 发件频率和内容不再受限 基于 Akismet 的垃圾评论自动标注和过滤 评论管理，避免直接操作数据库 …… 邮件效果如下图所示： 管理界面如下图： 4.2 卜算子统计在主题配置文件中搜索 busuanzi_count，将开关打开，并做如下图修改，即可统计站点的 UV和PV： 实现效果如下图： 第一行的 Site words total count很是刺眼，改！之前的leancloud留下来的历史问题。在 \themes\next\layout\_partials\footer.swig中第19行做如下修改： 1#&#125;&#123;&#123; totalcount(site, '0,0.0a') &#125;&#125; 字&#123;# 在\themes\next\language\zh-Hans.yml文件中，修改第36行，如下： 1234#修改前： totalcount: Site words total count#修改后： totalcount: 本站共计 5、To DO List 侧边栏添加日历 点击查看教程链接 SEO优化 CND优化 静态资源压缩（github pages提供的免费空间有限） 添加动态萌宠 先安装必要的模块 12npm install --save hexo-helper-live2dnpm install live2d-widget-model-hijiki #此行不同的萌宠，对应不同的模块 在站点配置文件的末尾添加如下代码段： 1234567891011121314151617# live2d live2d: enable: true scriptFrom: local pluginRootPath: live2dw/ pluginJsPath: lib/ pluginModelPath: assets/ model: use: live2d-widget-model-hijiki/ display: position: left width: 80 height: 300 hOffset: 20 #水平相对位移 vOffset: -200 #垂直相对位移 mobile: show: true 代码区添加点击复制按钮 隐私博文加密访问 点击查看教程链接 设置背景及透明度 打开 \themes\next\source\css\_custom\custom.styl文件，添加如下代码即可： 1234567891011body &#123; background:url(https://source.unsplash.com/random/1920x1080); background-repeat: repeat; background-attachment:fixed; background-position:50% 50%;&#125;//改变背景色和透明度.main-inner &#123; background: #fff; opacity: 0.9;&#125; 添加网易云音乐 在网易云音乐网页版，找到自己想要的歌曲，点击生成播放外链，生成如下所示的代码，将iframe模块放到主题中 layout/_macro/sidebar.swig文件的适当位置即可。 1&lt;iframe frameborder=&quot;no&quot; border=&quot;0&quot; marginwidth=&quot;0&quot; marginheight=&quot;0&quot; width=298 height=52 src=&quot;//music.163.com/outchain/player?type=2&amp;id=570240588&amp;auto=0&amp;height=32&quot;&gt;&lt;/iframe&gt; 个性化字体设置–设置代码块字体大小 NexT 从 5.0.1 版本开始提供一个 字体定制特性，编辑主题下的 source/css/_variables/custom.styl 文件，新增如下代码： 12// 代码字体的大小$code-font-size = 15px 文章顶部添加最近更新时间 在主题设置文件中搜索update，将其设置为true即可。 个性设置文章间分割线 取消博文段落自动编号 将主题配置文件中的 toc ：number 字段设置为 false 安装PDF插件 执行命令 npm install hexo-pdf --save，之后编辑博客的时候即可使用 标签：引用本地的pdf文件。 。。。。。。 6、bug解决6.1 busuanzi统计失效问题前往 http://busuanzi.ibruce.info/ 卜算子官网，可以发现有提示说 因七牛强制过期『dn-lbstatics.qbox.me』域名，与客服沟通无果，只能更换域名到『busuanzi.ibruce.info』！。所以接下来的bug修复工作就十分简单了。在主题文件 themes/next/layout/_third-party/analytics/busuanzi-counter.swig 文件中，将 &lt;script&gt; 标签中的 src字段改为： src=&quot;//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js&quot; 即可解决。]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>笔记</tag>
      </tags>
  </entry>
</search>
